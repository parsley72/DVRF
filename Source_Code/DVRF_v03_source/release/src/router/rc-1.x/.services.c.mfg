
/*
 *********************************************************
 *   Copyright 2003, CyberTAN  Inc.  All Rights Reserved *
 *********************************************************

 This is UNPUBLISHED PROPRIETARY SOURCE CODE of CyberTAN Inc.
 the contents of this file may not be disclosed to third parties,
 copied or duplicated in any form without the prior written
 permission of CyberTAN Inc.

 This software should be used as a reference only, and it not
 intended for production use!


 THIS SOFTWARE IS OFFERED "AS IS", AND CYBERTAN GRANTS NO WARRANTIES OF ANY
 KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE.  CYBERTAN
 SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE
*/

/*
 * Miscellaneous services
 *
 * Copyright 2007, Broadcom Corporation
 * All Rights Reserved.
 * 
 * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
 * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
 * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
 *
 * $Id: services.c,v 1.196 2007/10/25 07:42:26 michael Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <wait.h>
#include <net/route.h>
#include <sys/types.h>
#include <signal.h>
#include <time.h>

#include <bcmnvram.h>
#include <netconf.h>
#include <shutils.h>
#include <utils.h>
#include <code_pattern.h>
#ifdef STORAGE_SUPPORT
#include <users.h>
#endif
#include <rc.h>
#include <build_date.h>
#include <cy_conf.h>
#include <nvparse.h>
#ifdef T_MOBILE_SUPPORT
#include <tmobile.h>
#endif
#ifdef STORAGE_SUPPORT
#include <ctype.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <dirent.h>
#include <assert.h>
#endif

#ifdef STORAGE_SUPPORT
#include <disk_configuration.h>
#include <user_configuration.h>
#include <print_server.h>
#include <user_notification.h>
#include <share_export_names.h>
#include <partition_vars.h>
#include <pool_share_vars.h>
#endif

#include <security_ipc.h>

/*Added for EGHN*/
#ifdef EGHN_SUPPORT
#define EGHN
extern void eghn_init();
extern void eghn_exit();
#else
#undef EGHN
#endif
/*EGHN*/

#ifdef FTP_SUPPORT
#ifdef PROFTPD_SUPPORT
static int write_ftp_conf(const char *file_name);
#endif
#ifdef VSFTPD_SUPPORT
static int write_ftp_conf_user();
//add by michael to fix the ftp port can't be change to another one at 20081208
static int write_vsftpd_conf();
#endif
#endif

#ifdef GUEST_NETWORK_SUPPORT
#if defined( SMB3025_SUPPORT ) || defined( SMB3215_SUPPORT )
static int write_nmbd_config_file(int role, const char * file_name);
#define HOME_NMBD_CONF_FILE "/tmp/samba/lib/smb.conf"
#define GUEST_NMBD_CONF_FILE "/tmp/samba/lib/gn_smb.conf"
#endif
#endif

#ifdef STORAGE_SUPPORT
static int write_cifs_config_file(const char *file_name, all_disk_info_t *all_disk_info);
static pool_info_t *require_mounted_pool(const char *pool_name, const char *purpose, all_disk_info_t *all_disk_info);
static void create_pool_share_marker(const char *base_name, const char *pool_mount_name, const char *share_name);
static void create_marker_pool_directory(const char *base_name, const char *pool_mount_name);

static bool
pool_is_going(const pool_info_t *pool)
{
	char *mark_file;
	FILE *fp;

	/* Check for a mark left to say to omit this pool because it is about to be
	 * removed. */
	if (pool->mount_name == NULL)
		return FALSE;
	mark_file = (char *)(malloc(strlen(pool->mount_name) + 100));
	if (mark_file == NULL)
	{
		fprintf(stderr,
				"Error: failed trying to allocate %llu bytes of memory while "
				"checking to see if necessary pool `%s' is mounted.\n",
				(unsigned long long)(strlen(pool->mount_name) + 100),
				pool->name);
		return FALSE;
	}
	sprintf(mark_file, "/tmp/pools_going/%s", pool->mount_name);
	fp = fopen(mark_file, "r");
	free(mark_file);
	if (fp != NULL)
	{
		fclose(fp);
		return TRUE;
	}
	return FALSE;
}
#endif

#define IFUP (IFF_UP | IFF_RUNNING | IFF_BROADCAST | IFF_MULTICAST)
#define sin_addr(s) (((struct sockaddr_in *)(s))->sin_addr)
                                                                                                                             
#define PPPoE_REDIAL_PERIOD 30                                                                                                                            
#ifdef MPPPOE_SUPPORT
extern char pppoe_in_use;       //tallest 1216
#endif
#ifdef BCMDBG
#include <assert.h>
#endif

//wuzh port from vista-premium BSP 2008-2-27
static char
*make_var(char *prefix, int index, char *name)
{
	static char buf[100];

#ifdef BCMDBG
	assert(prefix);
	assert(name);
#endif
	if (index)
		snprintf(buf, sizeof(buf), "%s%d%s", prefix, index, name);
	else
		snprintf(buf, sizeof(buf), "%s%s", prefix, name);
	return buf;
}
//wuzh port end

int
adjust_dhcp_range(void)
{
	struct in_addr ipaddr, netaddr, netmask;

	char *lan_ipaddr = nvram_safe_get("lan_ipaddr");
	char *lan_netmask = nvram_safe_get("lan_netmask");
	char *dhcp_num = nvram_safe_get("dhcp_num");
	char *dhcp_start = nvram_safe_get("dhcp_start");

	int legal_start_ip, legal_end_ip, legal_total_ip, dhcp_start_ip;
	int set_dhcp_start_ip=0, set_dhcp_num=0;
	int adjust_ip = 0, adjust_num = 0;

	inet_aton(lan_ipaddr, &netaddr);
        inet_aton(lan_netmask, &netmask);
        inet_aton(dhcp_start, &ipaddr);
	
	legal_total_ip = 254 - get_single_ip(lan_netmask,3);
	legal_start_ip = (get_single_ip(lan_ipaddr,3) & get_single_ip(lan_netmask,3)) + 1;
	legal_end_ip = legal_start_ip + legal_total_ip - 1;
	dhcp_start_ip = atoi(dhcp_start);

	dprintf("legal_total_ip=[%d] legal_start_ip=[%d] legal_end_ip=[%d] dhcp_start_ip=[%d]\n", 
		legal_total_ip, legal_start_ip, legal_end_ip, dhcp_start_ip);

        if ((dhcp_start_ip > legal_end_ip) || (dhcp_start_ip < legal_start_ip)){
		dprintf("Illegal DHCP Start IP: We need to adjust DHCP Start ip.\n");
		set_dhcp_start_ip = legal_start_ip;
		adjust_ip = 1;
		if(atoi(dhcp_num) > legal_total_ip){
			dprintf("DHCP num is exceed, we need to adjust.");
			set_dhcp_num = legal_total_ip;
			adjust_num = 1;
		}
	}
	else{
		dprintf("Legal DHCP Start IP: We need to check DHCP num.\n");
		if((atoi(dhcp_num) + dhcp_start_ip) > legal_end_ip){
			dprintf("DHCP num is exceed, we need to adjust.\n");
			set_dhcp_num = legal_end_ip - dhcp_start_ip + 1;
			adjust_num = 1;
		}
	}

	if(adjust_ip){
		char ip[20];
		dprintf("set_dhcp_start_ip=[%d]\n", set_dhcp_start_ip);	
		snprintf(ip, sizeof(ip), "%d", set_dhcp_start_ip);
		nvram_set("dhcp_start", ip);
	}
	if(adjust_num){
		char num[5];
		dprintf("set_dhcp_num=[%d]\n", set_dhcp_num);	
		snprintf(num, sizeof(num), "%d", set_dhcp_num);
		nvram_set("dhcp_num", num);
	}
	
	return 1;
}


#ifdef VERIZON_LAN_SUPPORT
int
start_dhcp_relay(void)
{
	int ret = eval("dhcrelay", nvram_safe_get("dhcrelay_ipaddr"));

	dprintf("done\n");
	return ret;
}

int
stop_dhcp_relay(void)
{
	int ret = eval("killall", "dhcrelay");

	dprintf("done\n");
	return ret ;
}
#endif

#ifdef DHCPV6S_SUPPORT

#define LEASE_FILE_PATH "/tmp/dhcpd.leases"	
#ifdef GUEST_NETWORK_SUPPORT
#define GN_LEASE_FILE_PATH "/tmp/dhcpd-br1.leases"
#endif

static int write_dhcpd_conf(int guest_nw)
{
	struct dns_lists *dns_list = NULL;
	FILE *fp;

#ifdef UDHCPD_STATIC_SUPPORT
	char mac[20], ip[10], enable[10], name[32];
	char word[128], *next;
#endif	
	char ifname[20], file[50], lan_ip[20];
	struct in_addr ipaddr, netmask, subnet;
	char lan_mask[20], leases_file[50], pid_file[50];
	char leases_file2[50];
	
	if(!guest_nw)
	{
		sprintf(ifname, "%s", nvram_safe_get("lan_ifname"));
		sprintf(file, "/tmp/dhcpd-%s.conf", nvram_safe_get("lan_ifname"));
		sprintf(lan_ip, "%s", "lan_ipaddr");
		sprintf(lan_mask, "%s", "lan_netmask");
	}
	else
	{
		sprintf(ifname, "%s", nvram_safe_get("gn_lan_ifname"));
		sprintf(file, "/tmp/dhcpd-%s.conf", nvram_safe_get("gn_lan_ifname"));
		sprintf(lan_ip, "%s", "gn_lan_ipaddr");
		sprintf(lan_mask, "%s", "gn_lan_netmask");
	}	
	cprintf("%s: file=%s, ifname=%s, lan_ip=%s lan_mask=%s\n", __FUNCTION__, file, ifname, lan_ip, lan_mask);
	if (!(fp = fopen(file, "w"))) {
		perror(file);
		return errno;
	}
    
	//fprintf(fp, "pidfile /var/run/dhcpd.pid\n");
	
	inet_aton(nvram_safe_get(lan_ip), &ipaddr);
	inet_aton(nvram_safe_get(lan_mask), &netmask);
	
	subnet.s_addr = ipaddr.s_addr & netmask.s_addr;
	
	fprintf(fp, "subnet %s ", inet_ntoa(subnet));
	fprintf(fp, "netmask %s { \n", inet_ntoa(netmask));

	if(!guest_nw)
	{
		fprintf(fp, "range %d.%d.%d.%s", get_single_ip(nvram_safe_get(lan_ip),0),
					   get_single_ip(nvram_safe_get(lan_ip),1),
					   get_single_ip(nvram_safe_get(lan_ip),2),
					   nvram_safe_get("dhcp_start"));

		//add by michael to fix the dhcp server max lease will lose 1 when lan ipaddress in the ip pool range. at 20090508
		if( (atoi(nvram_safe_get("dhcp_start")) < get_single_ip(nvram_safe_get(lan_ip),3)) &&
	    	(atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num"))) >= get_single_ip(nvram_safe_get(lan_ip),3))
		{
			fprintf(fp, " %d.%d.%d.%d;\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num")));
		}
		else
			fprintf(fp, " %d.%d.%d.%d;\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num")) - 1);
	}else
	{
		fprintf(fp, "range %d.%d.%d.%s", get_single_ip(nvram_safe_get(lan_ip),0),
					   get_single_ip(nvram_safe_get(lan_ip),1),
					   get_single_ip(nvram_safe_get(lan_ip),2),
					   nvram_safe_get("gn_dhcp_start"));

		//add by michael to fix the dhcp server max lease will lose 1 when lan ipaddress in the ip pool range. at 20090508
		if( (atoi(nvram_safe_get("gn_dhcp_start")) < get_single_ip(nvram_safe_get(lan_ip),3)) &&
	    	(atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num"))) >= get_single_ip(nvram_safe_get(lan_ip),3))
		{
			fprintf(fp, " %d.%d.%d.%d;\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num")));
		}
		else
			fprintf(fp, " %d.%d.%d.%d;\n", get_single_ip(nvram_safe_get(lan_ip),0),
				get_single_ip(nvram_safe_get(lan_ip),1),
				get_single_ip(nvram_safe_get(lan_ip),2),
				atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num")) - 1);
	}
	//fprintf(fp, "max-lease-time 254\n");
	//fprintf(fp, "interface %s\n", ifname);
	//fprintf(fp, "wan_interface %s\n", nvram_safe_get("wan_ifname"));
	//fprintf(fp, "remaining yes\n");
	//fprintf(fp, "auto_time 30\n");		// N seconds to update lease table
	if(!guest_nw){
		sprintf(leases_file, "/tmp/dhcpd.leases");
		sprintf(pid_file, "/var/run/dhcpd.pid");
		sprintf(leases_file2, "/tmp/udhcpd.leases");
		//fprintf(fp, "lease_file /tmp/dhcpd.leases\n");
	}else{
		sprintf(leases_file, "/tmp/dhcpd-%s.leases", nvram_safe_get("gn_lan_ifname"));
		sprintf(leases_file2, "/tmp/udhcpd-%s.leases", nvram_safe_get("gn_lan_ifname"));
		sprintf(pid_file, "/var/run/dhcpd-%s.pid", nvram_safe_get("gn_lan_ifname"));
		//fprintf(fp, "lease_file /tmp/dhcpd-%s.leases\n", nvram_safe_get("gn_lan_ifname"));
	}

#ifdef UDHCPD_STATIC_SUPPORT
	/*
	for (i=0; i<10; i++) {
		snprintf(dhcp_statics, sizeof(dhcp_statics), "dhcp_statics%d", i);
		wordlist = nvram_safe_get(dhcp_statics);
		sscanf(wordlist, "%s %s %s", mac, ip, enable);
		if (!strcmp(enable, "on")) {
			fprintf(fp, "static_lease %s %d.%d.%d.%s\n",
				mac,
				get_single_ip(nvram_safe_get("lan_ipaddr"),0),
				get_single_ip(nvram_safe_get("lan_ipaddr"),1),
				get_single_ip(nvram_safe_get("lan_ipaddr"),2),
				ip);
		}
	}

	host haagen {
	   hardware ethernet 08:00:2b:4c:59:23;
	   fixed-address 192.168.1.222;
	}
	*/

#if 0 //ruby remove it. we do it later.
   if(!guest_nw)
    {	
	_foreach(word, nvram_safe_get("dhcp_statics"), next, ";", ';') {
		sscanf(word, "%s %s %s %s", mac, ip, enable, name);
		if (!strcmp(enable, "on")) {
                        fprintf(fp, "static_lease %s %d.%d.%d.%s\n",
                                mac,
                                get_single_ip(nvram_safe_get(lan_ip),0),
                                get_single_ip(nvram_safe_get(lan_ip),1),
                                get_single_ip(nvram_safe_get(lan_ip),2),
                                ip);
                }
	}
    }
#endif
#endif /*UDHCPD_STATIC_SUPPORT*/
	//fprintf(fp, "siaddr %s\n", nvram_safe_get(lan_ip));	// 20040511
	//fprintf(fp, "option subnet %s\n", nvram_safe_get("lan_netmask"));
	fprintf(fp, "option routers %s;\n", nvram_safe_get(lan_ip));
#ifdef BRCM
	fprintf(fp, "option domain-name-servers %s;\n", nvram_safe_get(lan_ip));
	fprintf(fp, "default-lease-time %s;\n", nvram_safe_get("lan_lease"));
	fprintf(fp, "max-lease-time %s;\n", nvram_safe_get("lan_lease"));
	snprintf(name, sizeof(name), "%s_wins", nvram_safe_get("dhcp_wins"));
	if (nvram_invmatch(name, ""))
		fprintf(fp, "option netbios-name-servers %s;\n", nvram_get(name));
		//fprintf(fp, "option wins %s\n", nvram_get(name));
	snprintf(name, sizeof(name), "%s_domain", nvram_safe_get("dhcp_domain"));
	if (nvram_invmatch(name, ""))
		fprintf(fp, "option domain-name %s;\n", nvram_get(name));
		
	fprintf(fp, "}");	
	fclose(fp);
#endif
	if (nvram_invmatch("wan_wins", "") && nvram_invmatch("wan_wins", "0.0.0.0"))
		fprintf(fp, "option netbios-name-servers %s;\n", nvram_safe_get("wan_wins"));
		//fprintf(fp, "option wins %s\n", nvram_safe_get("wan_wins"));

	//dns_list = get_dns_list();
        dns_list = get_dns_list(0);
	if(!dns_list || dns_list->num_servers == 0){
#ifdef XBOX_SUPPORT
		/******************start******************************/
		/*
		*	Alpha modified to fixed When DUT doesn't connect to
		*	the internet and the DHCP Client Lease Time is set to "0"
		*	(0 means one day), will obtain a two day lease.
		*	2008-04-21
		*
		*****************************************************/
		//fprintf(fp, "option lease %s\n", "172800");	// no dns, lease time default to 2 days for XBOX
		//fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
		fprintf(fp, "default-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
	  fprintf(fp, "max-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
		/******************end********************************/
#else
		//fprintf(fp, "option lease %s\n", "300");	// no dns, lease time default to 300 seconds
	fprintf(fp, "default-lease-time %d;\n", "300");
	fprintf(fp, "max-lease-time %d;\n", "300");
#endif
#ifdef DNSMASQ_SUPPORT
                //fprintf(fp, "option dns %s\n", nvram_safe_get(lan_ip));
                fprintf(fp, "option domain-name-servers %s;\n", nvram_safe_get(lan_ip));
#endif
	}
	else{
#ifdef VERIZON_LAN_SUPPORT
		//fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400*7);
		fprintf(fp, "default-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400*7);
		fprintf(fp, "max-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400*7);
#else
		//fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
		fprintf(fp, "default-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
	  fprintf(fp, "max-lease-time %d;\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
#endif
#ifdef MPPPOE_SUPPORT
		if (nvram_match("wan_proto", "pppoe"))
									fprintf(fp, "option domain-name-servers %s;\n", nvram_safe_get(lan_ip));
                	//fprintf(fp, "option dns %s\n", nvram_safe_get(lan_ip));
		else
			fprintf(fp, "option domain-name-servers %s %s %s;\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
		//fprintf(fp, "option dns %s %s %s\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
#else
//add by michael to add the router ip address as the main dns address
//#ifdef CUSTOM404_SUPPORT
#if 0
//		fprintf(fp, "option dns %s %s %s\n", nvram_safe_get("lan_ipaddr"),dns_list->dns_server[0], dns_list->dns_server[1]);
{
	int i ;
	char *dns_tmp = nvram_safe_get("wan_dns");
	//fprintf(fp,"option dns");
	fprintf(fp,"option domain-name-servers");
	for(i = 0; i<dns_list->num_servers;i++)
	{
		if(strstr(dns_tmp,dns_list->dns_server[i])){
			fprintf(fp," %s",dns_list->dns_server[i]);
		  if(i<(dns_list->num_servers-1))
		  	fprintf(fp,",");
		}else
			break;
	}

	if(i<3)
	{
		fprintf(fp," %s",nvram_safe_get("lan_ipaddr"));
		for(;i<2;i++){
			fprintf(fp," %s",dns_list->dns_server[i]);
			if(i<2)
		  	fprintf(fp,",");
		}		
	}
	fprintf(fp,"; \n");
}
	//add by michael to move the lan_ipaddr to the last dns server at 20090901
#elif 1
	int i;
	//fprintf(fp,"option dns");
	fprintf(fp,"option domain-name-servers");
	for( i = 0; i < dns_list->num_servers; i++ ){
		fprintf(fp," %s",dns_list->dns_server[i]);
#ifdef DHCPV6S_SUPPORT
		if (i < 2) { fprintf(fp, ","); }	// dns_list[] keeps 3 DNS entries at most (product spec.)
#else
		if(i<(dns_list->num_servers-1))
		  	fprintf(fp,",");
#endif
	}	
	if(i<3)
		fprintf(fp," %s",nvram_safe_get(lan_ip));
	fprintf(fp,"; \n");
#else
		//fprintf(fp, "option dns %s %s %s\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
		fprintf(fp, "option domain-name-servers %s %s %s;\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
#endif
#endif
	}
	if (nvram_invmatch("wan_domain", ""))
		fprintf(fp, "option domain-name \"%s\";\n", nvram_safe_get("wan_domain"));
		//fprintf(fp, "option domain %s\n", nvram_safe_get("wan_domain"));
	else if (nvram_invmatch("wan_get_domain", ""))
		fprintf(fp, "option domain-name \"%s\";\n", nvram_safe_get("wan_get_domain"));
		//fprintf(fp, "option domain %s\n", nvram_safe_get("wan_get_domain"));
  
  fprintf(fp, "}\n");
#ifdef UDHCPD_STATIC_SUPPORT  //ruby add for dhcp statics
  if(!guest_nw)
  {	
		_foreach(word, nvram_safe_get("dhcp_statics"), next, ";", ';') {
			sscanf(word, "%s %s %s %s", mac, ip, enable, name);
			if (!strcmp(enable, "on")) {
				fprintf(fp, "host %s {\n", name);
				fprintf(fp, "hardware ethernet %s;\n", mac);	
	      fprintf(fp, "fixed-address %d.%d.%d.%s;\n",
	              get_single_ip(nvram_safe_get(lan_ip),0),
	              get_single_ip(nvram_safe_get(lan_ip),1),
	              get_single_ip(nvram_safe_get(lan_ip),2),
	              ip); 
	     fprintf(fp, "}\n");                                     
			}
		}
  } 
#endif 
	fclose(fp);

#ifdef GUEST_NETWORK_SUPPORT
	if(guest_nw)
	{
		symlink("/usr/sbin/dhcpd", "/tmp/gn-dhcpd");
		//eval("/tmp/gn-dhcpd", file);
		//eval("/tmp/gn-dhcpd", "-cf", file, "-lf", leases_file, "-pf", pid_file, ifname);
		eval("/tmp/gn-dhcpd", "-cf", file, "-lf", leases_file, "-df", leases_file2, "-pf", pid_file, ifname);
	}else
#endif
		//eval("dhcpd", file);
		//eval("dhcpd", "-cf", file, "-lf", leases_file, "-pf", pid_file, ifname);
		eval("dhcpd", "-cf", file, "-lf", leases_file, "-df", leases_file2, "-pf", pid_file, ifname);
	dprintf("done\n");
	return 0;
}

#else /*DHCPV6S_SUPPORT*/

#define LEASE_FILE_PATH "/tmp/udhcpd.leases"	
#ifdef GUEST_NETWORK_SUPPORT
#define GN_LEASE_FILE_PATH "/tmp/udhcpd-br1.leases"
#endif
static int write_udhcpd_conf(int guest_nw)
{
	struct dns_lists *dns_list = NULL;
	FILE *fp;

#ifdef UDHCPD_STATIC_SUPPORT
	char mac[20], ip[10], enable[10], name[32];
	char word[128], *next;
#endif	
	char ifname[20], file[50], lan_ip[20];
	
	if(!guest_nw)
	{
		sprintf(ifname, "%s", nvram_safe_get("lan_ifname"));
		sprintf(file, "/tmp/udhcpd-%s.conf", nvram_safe_get("lan_ifname"));
		sprintf(lan_ip, "%s", "lan_ipaddr");
	}
	else
	{
		sprintf(ifname, "%s", nvram_safe_get("gn_lan_ifname"));
		sprintf(file, "/tmp/udhcpd-%s.conf", nvram_safe_get("gn_lan_ifname"));
		sprintf(lan_ip, "%s", "gn_lan_ipaddr");
	}	
	printf("%s: file=%s, ifname=%s, lan_ip=%s\n", __FUNCTION__, file, ifname, lan_ip);
	if (!(fp = fopen(file, "w"))) {
		perror(file);
		return errno;
	}

	fprintf(fp, "pidfile /var/run/udhcpd.pid\n");

	
	if(!guest_nw)
	{
		fprintf(fp, "start %d.%d.%d.%s\n", get_single_ip(nvram_safe_get(lan_ip),0),
					   get_single_ip(nvram_safe_get(lan_ip),1),
					   get_single_ip(nvram_safe_get(lan_ip),2),
					   nvram_safe_get("dhcp_start"));

		//add by michael to fix the dhcp server max lease will lose 1 when lan ipaddress in the ip pool range. at 20090508
		if( (atoi(nvram_safe_get("dhcp_start")) < get_single_ip(nvram_safe_get(lan_ip),3)) &&
	    	(atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num"))) >= get_single_ip(nvram_safe_get(lan_ip),3))
		{
			fprintf(fp, "end %d.%d.%d.%d\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num")));
		}
		else
			fprintf(fp, "end %d.%d.%d.%d\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("dhcp_start")) + atoi(nvram_safe_get("dhcp_num")) - 1);
	}else
	{
		fprintf(fp, "start %d.%d.%d.%s\n", get_single_ip(nvram_safe_get(lan_ip),0),
					   get_single_ip(nvram_safe_get(lan_ip),1),
					   get_single_ip(nvram_safe_get(lan_ip),2),
					   nvram_safe_get("gn_dhcp_start"));

		//add by michael to fix the dhcp server max lease will lose 1 when lan ipaddress in the ip pool range. at 20090508
		if( (atoi(nvram_safe_get("gn_dhcp_start")) < get_single_ip(nvram_safe_get(lan_ip),3)) &&
	    	(atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num"))) >= get_single_ip(nvram_safe_get(lan_ip),3))
		{
			fprintf(fp, "end %d.%d.%d.%d\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num")));
		}
		else
			fprintf(fp, "end %d.%d.%d.%d\n", get_single_ip(nvram_safe_get(lan_ip),0),
				      		 get_single_ip(nvram_safe_get(lan_ip),1),
				 	         get_single_ip(nvram_safe_get(lan_ip),2),
						 atoi(nvram_safe_get("gn_dhcp_start")) + atoi(nvram_safe_get("gn_dhcp_num")) - 1);

	}

	fprintf(fp, "max_leases 254\n");
	fprintf(fp, "interface %s\n", ifname);
	fprintf(fp, "wan_interface %s\n", nvram_safe_get("wan_ifname"));
	fprintf(fp, "remaining yes\n");
	fprintf(fp, "auto_time 30\n");		// N seconds to update lease table
	if(!guest_nw)
		fprintf(fp, "lease_file /tmp/udhcpd.leases\n");
	else
                fprintf(fp, "lease_file /tmp/udhcpd-%s.leases\n", nvram_safe_get("gn_lan_ifname"));

#ifdef UDHCPD_STATIC_SUPPORT
	/*
	for (i=0; i<10; i++) {
		snprintf(dhcp_statics, sizeof(dhcp_statics), "dhcp_statics%d", i);
		wordlist = nvram_safe_get(dhcp_statics);
		sscanf(wordlist, "%s %s %s", mac, ip, enable);
		if (!strcmp(enable, "on")) {
			fprintf(fp, "static_lease %s %d.%d.%d.%s\n",
				mac,
				get_single_ip(nvram_safe_get("lan_ipaddr"),0),
				get_single_ip(nvram_safe_get("lan_ipaddr"),1),
				get_single_ip(nvram_safe_get("lan_ipaddr"),2),
				ip);
		}
	}
	*/
    if(!guest_nw)
    {	
	_foreach(word, nvram_safe_get("dhcp_statics"), next, ";", ';') {
		sscanf(word, "%s %s %s %s", mac, ip, enable, name);
		if (!strcmp(enable, "on")) {
                        fprintf(fp, "static_lease %s %d.%d.%d.%s\n",
                                mac,
                                get_single_ip(nvram_safe_get(lan_ip),0),
                                get_single_ip(nvram_safe_get(lan_ip),1),
                                get_single_ip(nvram_safe_get(lan_ip),2),
                                ip);
                }
	}
    }
#endif
	fprintf(fp, "siaddr %s\n", nvram_safe_get(lan_ip));	// 20040511
	//junzhao add 2010.9.28 for fix the netmask of GA to 255.255.255.0
	//fprintf(fp, "option subnet %s\n", nvram_safe_get("lan_netmask"));
    	if(!guest_nw)
		fprintf(fp, "option subnet %s\n", nvram_safe_get("lan_netmask"));
	else
		fprintf(fp, "option subnet %s\n", nvram_safe_get("gn_lan_netmask"));
	//end add
	fprintf(fp, "option router %s\n", nvram_safe_get(lan_ip));
#ifdef BRCM
	fprintf(fp, "option dns %s\n", nvram_safe_get(lan_ip));
	fprintf(fp, "option lease %s\n", nvram_safe_get("lan_lease"));
	snprintf(name, sizeof(name), "%s_wins", nvram_safe_get("dhcp_wins"));
	if (nvram_invmatch(name, ""))
		fprintf(fp, "option wins %s\n", nvram_get(name));
	snprintf(name, sizeof(name), "%s_domain", nvram_safe_get("dhcp_domain"));
	if (nvram_invmatch(name, ""))
		fprintf(fp, "option domain %s\n", nvram_get(name));
	fclose(fp);
#endif
	if (nvram_invmatch("wan_wins", "") && nvram_invmatch("wan_wins", "0.0.0.0"))
		fprintf(fp, "option wins %s\n", nvram_safe_get("wan_wins"));

	//dns_list = get_dns_list();
        dns_list = get_dns_list(0);
	if(!dns_list || dns_list->num_servers == 0){
#ifdef XBOX_SUPPORT
		/******************start******************************/
		/*
		*	Alpha modified to fixed When DUT doesn't connect to
		*	the internet and the DHCP Client Lease Time is set to "0"
		*	(0 means one day), will obtain a two day lease.
		*	2008-04-21
		*
		*****************************************************/
		//fprintf(fp, "option lease %s\n", "172800");	// no dns, lease time default to 2 days for XBOX
		fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
		/******************end********************************/
#else
		fprintf(fp, "option lease %s\n", "300");	// no dns, lease time default to 300 seconds
#endif
#ifdef DNSMASQ_SUPPORT
                fprintf(fp, "option dns %s\n", nvram_safe_get(lan_ip));
#endif
	}
	else{
#ifdef VERIZON_LAN_SUPPORT
		fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400*7);
#else
		fprintf(fp, "option lease %d\n", atoi(nvram_safe_get("dhcp_lease")) ? atoi(nvram_safe_get("dhcp_lease"))*60 : 86400);
#endif
#ifdef MPPPOE_SUPPORT
		if (nvram_match("wan_proto", "pppoe"))
                	fprintf(fp, "option dns %s\n", nvram_safe_get(lan_ip));
		else
		fprintf(fp, "option dns %s %s %s\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
#else
//add by michael to add the router ip address as the main dns address
//#ifdef CUSTOM404_SUPPORT
#if 0
//		fprintf(fp, "option dns %s %s %s\n", nvram_safe_get("lan_ipaddr"),dns_list->dns_server[0], dns_list->dns_server[1]);
{
	int i ;
	char *dns_tmp = nvram_safe_get("wan_dns");
	fprintf(fp,"option dns");
	for(i = 0; i<dns_list->num_servers;i++)
	{
		if(strstr(dns_tmp,dns_list->dns_server[i]))
			fprintf(fp," %s",dns_list->dns_server[i]);
		else
			break;
	}

	if(i<3)
	{
		fprintf(fp," %s",nvram_safe_get("lan_ipaddr"));
		for(;i<2;i++)
			fprintf(fp," %s",dns_list->dns_server[i]);
		
	}	
	fprintf(fp,"\n");
}
	//add by michael to move the lan_ipaddr to the last dns server at 20090901
#elif 1
	int i;
	fprintf(fp,"option dns");
	for( i = 0; i < dns_list->num_servers; i++ )
		fprintf(fp," %s",dns_list->dns_server[i]);
	if(i<3)
		fprintf(fp," %s",nvram_safe_get(lan_ip));
	fprintf(fp,"\n");
#else
		fprintf(fp, "option dns %s %s %s\n", dns_list->dns_server[0], dns_list->dns_server[1], dns_list->dns_server[2]);
#endif
#endif
	}
	if (nvram_invmatch("wan_domain", ""))
		fprintf(fp, "option domain %s\n", nvram_safe_get("wan_domain"));
	else if (nvram_invmatch("wan_get_domain", ""))
		fprintf(fp, "option domain %s\n", nvram_safe_get("wan_get_domain"));

	fclose(fp);


#ifdef GUEST_NETWORK_SUPPORT
	if(guest_nw)
	{
		symlink("/usr/sbin/udhcpd", "/tmp/gn-udhcpd");
		eval("/tmp/gn-udhcpd", file);
	}else
#endif
		eval("udhcpd", file);

	dprintf("done\n");
	return 0;
}
#endif /*DHCPV6S_SUPPORT*/

#ifdef GUEST_NETWORK_SUPPORT
#ifdef DHCPV6S_SUPPORT

int start_gn_dhcpd(void)
{
        FILE *fp;

        if(!strcmp(nvram_safe_get("gn_enable"), "1") &&
	   !strcmp(nvram_safe_get("wk_mode"), "gateway") &&
           strcmp(nvram_safe_get("wl0_gmode"), "-1"))
        {
                /* Touch leases file */
                if (!(fp = fopen("/tmp/dhcpd-br1.leases", "a"))) {
                        perror("/tmp/dhcpd-br1.leases");
                        return errno;
                }
                fclose(fp);
        
                #if 1
                write_dhcpd_conf(1);   //Write guest network dhcp conf file
                #else
                write_udhcpd_conf(1);   //Write guest network dhcp conf file
                #endif
                 
                
        }else
	{
                remove(GN_LEASE_FILE_PATH);
	}
}

int 
stop_gn_dhcpd(void)
{
	char sigusr1[] = "-XX";
	int ret;

/*
* Process udhcpd handles two signals - SIGTERM and SIGUSR1
*
*  - SIGUSR1 saves all leases in /tmp/udhcpd.leases
*  - SIGTERM causes the process to be killed
*
* The SIGUSR1+SIGTERM behavior is what we like so that all current client
* leases will be honorred when the dhcpd restarts and all clients can extend
* their leases and continue their current IP addresses. Otherwise clients
* would get NAK'd when they try to extend/rebind their leases and they
* would have to release current IP and to request a new one which causes
* a no-IP gap in between.
*/
	sprintf(sigusr1, "-%d", SIGUSR1);
	eval("killall", sigusr1, "gn-dhcpd");
	ret = eval("killall", "gn-dhcpd");

	unlink("/tmp/gn-dhcpd");
	
	dprintf("done\n");
	return ret;
}

#else /*DHCPV6S_SUPPORT*/
int
start_gn_dhcpd(void)
{
        FILE *fp;

        if(!strcmp(nvram_safe_get("gn_enable"), "1") &&
	   !strcmp(nvram_safe_get("wk_mode"), "gateway") &&
           strcmp(nvram_safe_get("wl0_gmode"), "-1"))
        {
                /* Touch leases file */
                if (!(fp = fopen("/tmp/udhcpd-br1.leases", "a"))) {
                        perror("/tmp/udhcpd-br1.leases");
                        return errno;
                }
                fclose(fp);
        
                write_udhcpd_conf(1);   //Write guest network dhcp conf file
        }else
	{
                remove(GN_LEASE_FILE_PATH);
	}
}

int 
stop_gn_dhcpd(void)
{
	char sigusr1[] = "-XX";
	int ret;

/*
* Process udhcpd handles two signals - SIGTERM and SIGUSR1
*
*  - SIGUSR1 saves all leases in /tmp/udhcpd.leases
*  - SIGTERM causes the process to be killed
*
* The SIGUSR1+SIGTERM behavior is what we like so that all current client
* leases will be honorred when the dhcpd restarts and all clients can extend
* their leases and continue their current IP addresses. Otherwise clients
* would get NAK'd when they try to extend/rebind their leases and they
* would have to release current IP and to request a new one which causes
* a no-IP gap in between.
*/
	sprintf(sigusr1, "-%d", SIGUSR1);
	eval("killall", sigusr1, "gn-udhcpd");
	ret = eval("killall", "gn-udhcpd");

	unlink("/tmp/gn-udhcpd");
	
	dprintf("done\n");
	return ret;

}
#endif
#endif /*DHCPV6S_SUPPORT*/

int
start_dhcpd(void)
{
	FILE *fp;

#ifdef GUEST_NETWORK_SUPPORT
	start_gn_dhcpd();
#endif

	if (
#ifdef VERIZON_LAN_SUPPORT
	nvram_match("router_disable", "1") || nvram_match("lan_proto", "static")
#else
	nvram_match("router_disable", "1") || nvram_invmatch("lan_proto", "dhcp")
#endif
#ifdef UNNUMBERIP_SUPPORT
        || nvram_match("wan_proto", "unnumberip")
#endif
	)
	{
		remove(LEASE_FILE_PATH);
#ifdef GUEST_NETWORK_SUPPORT
                remove(GN_LEASE_FILE_PATH);
#endif 
                if(nvram_match("wan_proto", "unnumberip"))
                        cprintf("tallest: ================< we don't need DHCP in LAN side !! >================\n");
		return 0;
	}

#ifdef VERIZON_LAN_SUPPORT
	if(nvram_match("lan_proto", "dhcprelay"))
	{
		start_dhcp_relay();
		return 0;
	}
#endif

	/* Automatically adjust DHCP Start IP and num when LAN IP or netmask is changed */
	/* Do this on GUI code */
	//adjust_dhcp_range();

	cprintf("%s %d.%d.%d.%s %s %s\n",
		nvram_safe_get("lan_ifname"),
		get_single_ip(nvram_safe_get("lan_ipaddr"),0),
		get_single_ip(nvram_safe_get("lan_ipaddr"),1),
		get_single_ip(nvram_safe_get("lan_ipaddr"),2),
		nvram_safe_get("dhcp_start"),
		nvram_safe_get("dhcp_end"),
		nvram_safe_get("lan_lease"));

#ifdef MULTILANG_SUPPORT
	//add by michael to restore the dhcp_lease file at 20090511
	if(nvram_match("dhcp_write_lease","1"))
	{
		read_dhcp_lease();
		nvram_set("dhcp_write_lease","0");
	}
	//end by michael
#endif	
	/* Touch leases file */
#ifdef DHCPV6S_SUPPORT
	if (!(fp = fopen("/tmp/dhcpd.leases", "a"))) {
		perror("/tmp/dhcpd.leases");
		return errno;
	}
#else
	if (!(fp = fopen("/tmp/udhcpd.leases", "a"))) {
		perror("/tmp/udhcpd.leases");
		return errno;
	}
#endif
	fclose(fp);

	/* Write configuration file based on current information */
#ifdef DHCPV6S_SUPPORT
	write_dhcpd_conf(0);	//Write home network dhcp conf file
#else
	write_udhcpd_conf(0);	//Write home network dhcp conf file
#endif
	dprintf("done\n");

	return 0;	
}

int
stop_dhcpd(void)
{
	char sigusr1[] = "-XX";
	int ret;

/*
* Process udhcpd handles two signals - SIGTERM and SIGUSR1
*
*  - SIGUSR1 saves all leases in /tmp/udhcpd.leases
*  - SIGTERM causes the process to be killed
*
* The SIGUSR1+SIGTERM behavior is what we like so that all current client
* leases will be honorred when the dhcpd restarts and all clients can extend
* their leases and continue their current IP addresses. Otherwise clients
* would get NAK'd when they try to extend/rebind their leases and they
* would have to release current IP and to request a new one which causes
* a no-IP gap in between.
*/
	sprintf(sigusr1, "-%d", SIGUSR1);
#ifdef DHCPV6S_SUPPORT
	eval("killall", sigusr1, "dhcpd");
	ret = eval("killall", "dhcpd");
#else
	eval("killall", sigusr1, "udhcpd");
	ret = eval("killall", "udhcpd");
#endif
#ifdef VERIZON_LAN_SUPPORT
	stop_dhcp_relay();
#endif

#ifdef GUEST_NETWORK_SUPPORT
	stop_gn_dhcpd();
#endif

	dprintf("done\n");
	return ret;
}

#ifdef CES_MDNS_SUPPORT 
int
start_cesmdns(void)
{
	int ret = 0;
	ret = eval("cesmDNS","-o","/tmp/.mdns_host_info","-d");
	return ret;
}

int
stop_cesmdns(void)
{
	char sigquit[]="-XX";

	sprintf(sigquit,"-%d",SIGQUIT);
	eval("killall",sigquit,"cesmDNS");	
	
	return 0;
}
#endif

int
start_dns(void)
{
#ifdef BRCM
	FILE *fp;
	char word[100], *tmp;
#endif
#ifdef DNS_SUPPORT
	int i;
	FILE *fp;
	char nv_name[] = "dns_entryXX";
	char dns_entry[256];
	char ip_addr[20], domain[256], enable[2];
#endif
	int ret;
#ifdef MPPPOE_SUPPORT
	char word[100], *next;
	char got_dns[3][20];
#endif
	
	FILE *fp;

#ifdef DNS_SUPPORT
	/* Write /tmp/hosts with DNS entries */
	if (!(fp = fopen("/tmp/hosts", "w"))) {
		perror("/tmp/hosts");
		return errno;
	}
	for (i = 0; i < 10; i++) {
		sprintf(nv_name, "dns_entry%d", i);
		strcpy(dns_entry, nvram_safe_get(nv_name));
		sscanf(dns_entry, "%s %s %s", enable, ip_addr, domain);
		if (!strcmp(enable, "1"))
			fprintf(fp, "%s\t%s\n", ip_addr, domain);
	}
	fclose(fp);
#endif

//add by michael to add the router_url_address at 2008-3-2
	if(!(fp = fopen("/tmp/dns_url","w")))
	{
		perror("/tmp/dns_url");
		return errno;
	}
//	cprintf("\nnow start dnsmasq ,write [%s#%s] to the url file!\n",nvram_get("lan_ipaddr"),nvram_get("router_url_address"));
	fprintf(fp,"%s#%s",nvram_get("lan_ipaddr"),nvram_get("router_url_address"));
	fclose(fp);
//end by michael

#ifdef BRCM
	if (nvram_match("router_disable", "1"))
		return 0;
	/* Write resolv.conf with upstream nameservers */
	if (!(fp = fopen("/tmp/resolv.conf", "w"))) {
		perror("/tmp/resolv.conf");
		return errno;
	}
	foreach(word, nvram_safe_get("wan_dns"), tmp)
	fprintf(fp, "nameserver %s\n", word);
	fclose(fp);
#endif

	if(!is_exist("/tmp/resolv.conf"))
	{
//add by michael to start dns when wan is down 2008-3-2
#if 0
		if (!(fp = fopen("/tmp/resolv.conf", "w"))) 
		{
                	perror("/tmp/resolv.conf");
                	return errno;
		}
		fprintf(fp,"nameserver %s\n",nvram_get("lan_ipaddr"));
		fclose(fp);
		//return -1;
#else //wuzh modify it to fix bug 13719
		dns_to_resolv();
#endif
//end by michael
	}

#ifdef MPPPOE_SUPPORT
	if ((nvram_match("wan_proto", "pppoe")
#ifdef UNNUMBERIP_SUPPORT
		|| nvram_match("wan_proto","unnumberip")
#endif
	) && (check_wan_link(1) || nvram_match("ppp_demand_1", "1"))){
		struct in_addr wanip1, dnsip1;
		struct rtentry routeEntry;
		int dnsno = 0;

		foreach(got_dns[dnsno], nvram_safe_get("wan_get_dns_1"), next){
			dnsno ++;
		}
		sprintf(&word,"/%s/%s",nvram_safe_get("mpppoe_dname"),got_dns[0]);

		inet_aton(nvram_safe_get("wan_ipaddr_1"), &wanip1);
		//inet_aton(nvram_safe_get("wan_get_dns_1"), &dnsip1);
		inet_aton(got_dns[0], &dnsip1);

		wanip1.s_addr = wanip1.s_addr & 0x00ffffff;
		dnsip1.s_addr = dnsip1.s_addr & 0x00ffffff;

		((struct sockaddr_in *)&(routeEntry.rt_dst))->sin_addr.s_addr = dnsip1.s_addr;

		if(find_route_entry(&routeEntry)){
			eval ("route","del"
					,"-net",inet_ntoa(((struct sockaddr_in *)&(routeEntry.rt_dst))->sin_addr)
					,"netmask",inet_ntoa(((struct sockaddr_in *)&(routeEntry.rt_genmask))->sin_addr)
					,"gw",inet_ntoa(((struct sockaddr_in *)&(routeEntry.rt_gateway))->sin_addr)
			);
		}
		eval ("route","add","-net",inet_ntoa(dnsip1),
					"netmask","255.255.255.0",
					"gw",nvram_safe_get("wan_gateway_1")
		);

		ret = eval("dnsmasq",
						"-R",
						"-T","30",
						"-i", nvram_safe_get("lan_ifname"),
						//delete the dnsmasq cache
						"-c","0",
						"-r", "/tmp/resolv.conf",
						"-S",&word);
	}
	else
#endif
	{
#ifdef DNS_SUPPORT
		ret = eval("dnsmasq",
			"-R",
			"-i", nvram_safe_get("lan_ifname"),
			//delete the dnsmasq cache
			"-c","0",
			"-r", "/tmp/resolv.conf");
#else
		//Jemmy port guest network function from WRT320N 2009.9.18
#ifdef GUEST_NETWORK_SUPPORT
		if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
			!strcmp(nvram_safe_get("wk_mode"), "gateway") &&
			strcmp(nvram_safe_get("wl0_gmode"), "-1"))
		{
			ret = eval("dnsmasq",
						"-R",
						"-h",
			            "-i", nvram_safe_get("gn_lan_ifname"),
						"-i", nvram_safe_get("lan_ifname"),
						//delete the dnsmasq cache
						"-c","0",
						"-r", "/tmp/resolv.conf");
		}
		else{
			ret = eval("dnsmasq",
				"-R",
				"-h",
				"-i", nvram_safe_get("lan_ifname"),
				//delete the dnsmasq cache
				"-c","0",
				"-r", "/tmp/resolv.conf");
		}
#else
		ret = eval("dnsmasq",
			"-R",
			"-h",
			"-i", nvram_safe_get("lan_ifname"),
			//delete the dnsmasq cache
			"-c","0",
			"-r", "/tmp/resolv.conf");
#endif
#endif
	}

	dprintf("done\n");
	return ret;
}

int
stop_dns(void)
{
	int ret = eval("killall", "dnsmasq");

	dprintf("done\n");
	return ret;
}	

//wuzh port from vista-premium BSP 2008-2-27
#ifdef __CONFIG_IPV6__
/***************************************************************
*  ipv6_mode: 0=disable 1=6to4 only 2=native only 3=6to4+native!
*  ipv6_lan_prefix: prefix for LAN interface
*  ipv6_wan_prefix: prefix for WAN native support
*  ipv6_6to4_subnetid: 0~65535, used to form tunneling address
*     2002:wwxx:yyzz:ipv6_6to4_subnetid::/64
*  ipv6_dns: v6 DNS IP.
***************************************************************/
#define IPV6_6TO4_ENABLED              0x01
#define IPV6_WAN_NATIVE_ENABLED        0x02

#ifdef __CONFIG_DHCPV6S__
int
stop_dhcp6s(void)
{
	char sigusr1[] = "-XX";
	int ret;

	ret = eval("killall", "dhcp6s");

	dprintf("done\n");
	return ret;
}

int
start_dhcp6s(void)
{
	FILE *fp;
	char word[32], *next;
	char dhcp_conf_file[128];
	char dhcp_lease_file[128];
	char dhcp_ifnames[128];
	char *pc01NMask, ac01Prefix[64];
	int index;

	if (nvram_match("router_disable", "1") )
		return 0;

	/* Setup individual dhcp severs for the bridge and the every unbridged interface */

	snprintf(dhcp_ifnames,sizeof(dhcp_ifnames),"%s",nvram_safe_get("lan_ifname"));

	if (nvram_get("unbridged_ifnames"))
		foreach(word,nvram_safe_get("unbridged_ifnames"),next){

			snprintf(dhcp_ifnames,sizeof(dhcp_ifnames),
				"%s %s",dhcp_ifnames,word);
		}

	index=0;
	foreach(word, dhcp_ifnames, next){

		if (strstr(word,"br0") )
			index = 0 ;
		else
			index = 1;

		/* Skip interface if no valid config block is found */
		if (index < 0) continue;

		if (nvram_invmatch(make_var("lan",index,"_proto"),"dhcp"))
			continue;

		/* Touch leases file */
		sprintf(dhcp_lease_file,"/tmp/server6.leases");
		if (!(fp = fopen(dhcp_lease_file, "a"))) {
			perror(dhcp_lease_file);
			return errno;
		}
		fclose(fp);

		/* Write configuration file based on current information */
		sprintf(dhcp_conf_file,"/tmp/dhcp6s.conf");
		if (!(fp = fopen(dhcp_conf_file, "w"))) {
			perror(dhcp_conf_file);
			return errno;
		}

		strncpy(ac01Prefix, nvram_safe_get("ipv6_lan_prefix"), sizeof(ac01Prefix));
		pc01NMask= strchr(ac01Prefix, '/');
		if (pc01NMask==NULL)
		{  pc01NMask= "112";  }
		else
		{  *pc01NMask++= 0x00;  }

		fprintf(fp, "interface %s {\n", word);
		fprintf(fp, "server-preference %d;\n", 25);
		//fprintf(fp, "option dns_servers %s %s;\n", nvram_safe_get("ipv6_dns"), nvram_safe_get("wan0_domain"));
		//fprintf(fp, "option dns_servers %s %s;\n", "2002::2", "ibm.com");
		//fprintf(fp, "send information-only;\n");
		fprintf(fp, "link LAN {\n");
		fprintf(fp, "pool {\n");
		fprintf(fp, "range %s%x to %s%x/%s;\n", ac01Prefix, 0x1000,
		   ac01Prefix, 0x2000, pc01NMask);
		fprintf(fp, "prefix %s;\n", nvram_safe_get("ipv6_lan_prefix"));
		fprintf(fp, "};\n"); //pool
		fprintf(fp, "};\n"); //link

		fprintf(fp, "};\n"); //interface
		fclose(fp);

		eval("dhcp6s", "-c", dhcp_conf_file, word);
		index++;
	}
	dprintf("done\n");
	return 0;
}
#endif /* __CONFIG_DHCPV6S__ */

#ifdef __CONFIG_RADVD__
int
stop_radvd(void)
{
	FILE *fp;
	int ret;

	ret = eval("killall", "radvd");

	if ((fp = fopen("/proc/sys/net/ipv6/conf/all/forwarding", "r+"))) {
		fputc('0', fp);
		fclose(fp);
	}
	return ret;
}

int
start_radvd(int sintMode)
{
	FILE *fp;
	char radvd_conf_file[64];
	int ret;
	in_addr_t uintWANIP;
	
	uintWANIP= inet_network(nvram_safe_get("wan_ipaddr"));
	if (uintWANIP==0 || uintWANIP==-1
	|| (uintWANIP & 0xffff0000)==0xc0a80000
	|| (uintWANIP & 0xfff00000)==0xac100000
	|| (uintWANIP & 0xff000000)==0x0a000000)
	/*****************************************
	*  Private IP, RADVD will not be activated!
	*****************************************/
	{  return 0;  }

	sprintf(radvd_conf_file, "/tmp/radvd.conf");
	if (!(fp = fopen(radvd_conf_file, "w"))) {
		perror(radvd_conf_file);
		return errno;
	}

	/**************************
	* The RA for LAN interface:
	**************************/
	{	fprintf(fp, "interface %s {\n", nvram_safe_get("lan_ifname"));
		fprintf(fp, "AdvSendAdvert on;\n");
		fprintf(fp, "MinRtrAdvInterval %d;\n", 3);
		fprintf(fp, "MaxRtrAdvInterval %d;\n", 10);
		fprintf(fp, "AdvDefaultPreference low;\n");
		fprintf(fp, "AdvHomeAgentFlag off;\n");
		fprintf(fp, "AdvOtherConfigFlag on;\n");
#if 0
		fprintf(fp, "prefix %s {\n", nvram_safe_get("ipv6_lan_prefix"));
		fprintf(fp, "AdvOnLink on;\n");
		fprintf(fp, "AdvAutonomous on;\n");
		fprintf(fp, "};\n");
#endif
		if (nvram_match("router_disable", "0") && (sintMode & IPV6_6TO4_ENABLED)) //6to4 support.
		{	unsigned int uintSubnetID= atoi(nvram_safe_get("ipv6_6to4_subnetid"));

			fprintf(fp, "prefix 0:0:0:%x::/64 {\n", uintSubnetID);
			fprintf(fp, "AdvOnLink on;\n");
			fprintf(fp, "AdvAutonomous on;\n");
			fprintf(fp, "AdvRouterAddr off;\n");
			//fprintf(fp, "Base6to4Interface %s;\n", nvram_safe_get("wan0_ifname"));
			//wuzh modify 2008-3-6
			if(nvram_match("wan_proto", "pppoe")){
				fprintf(fp, "Base6to4Interface %s;\n", nvram_safe_get("wan_iface"));
			}
			else{
				fprintf(fp, "Base6to4Interface %s;\n", nvram_safe_get("wan_ifname"));
			}
			fprintf(fp, "AdvPreferredLifetime %d;\n", 20);
			fprintf(fp, "AdvValidLifetime %d;\n", 30);
			fprintf(fp, "};\n");
		}

		fprintf(fp, "};\n");
	}
#if 0
	if (nvram_match("router_disable", "0") && (sintMode & IPV6_WAN_NATIVE_ENABLED))
	/**************************************
	* The RA for WAN interface:
	**************************************/
	{	
		//fprintf(fp, "interface %s {\n", nvram_safe_get("wan0_ifname"));
		fprintf(fp, "interface %s {\n", nvram_safe_get("wan_ifname"));
		fprintf(fp, "AdvSendAdvert on;\n");
		fprintf(fp, "MinRtrAdvInterval %d;\n", 3);
		fprintf(fp, "MaxRtrAdvInterval %d;\n", 10);
		fprintf(fp, "AdvDefaultPreference low;\n");
		fprintf(fp, "AdvHomeAgentFlag off;\n");
		fprintf(fp, "prefix %s {\n", nvram_safe_get("ipv6_wan_prefix"));
		fprintf(fp, "AdvOnLink on;\n");
		fprintf(fp, "AdvAutonomous on;\n");
		fprintf(fp, "};\n");

		fprintf(fp, "};\n");
	}
#endif
	fclose(fp);

	if ((fp = fopen("/proc/sys/net/ipv6/conf/all/forwarding", "r+"))) {
		fputc('1', fp);
		fclose(fp);
	}

	ret = eval("radvd", "-C", radvd_conf_file);

	return ret;
}
#endif /* __CONFIG_RADVD__ */

int
stop_ipv6(void)
{
	int ret= 0;

	if (nvram_match("ipv6_mode", "0"))
  { return ret;  }

#ifdef __CONFIG_RADVD__
  ret= stop_radvd();
#endif /* __CONFIG_RADVD__ */

/* marcel 2010.10.15, use ISC's dhcp instead of dhcp6 */
//#ifdef __CONFIG_DHCPV6S__
//	ret= stop_dhcp6s();
//#endif /* __CONFIG_DHCPV6S__ */

	/*********************
	* Flush all v6 routes:
	*********************/
	{	ret = system("/usr/sbin/ip -6 route flush");
	}

	return ret;
}

int
start_ipv6(void)
{
	int ret= 0;
	int sintMode= 0;

	sintMode= atoi(nvram_safe_get("ipv6_mode"));
	if (sintMode==0)
	{	return 0;  }

/* wuzh modify 2008-2-5
 *
 * Split start_ipv6 to two parts:
 * 1. for lan: start_dhcp6s
 * 2. for wan: start_radvd
 */
/*#ifdef __CONFIG_DHCPV6S__
  if (ret= start_dhcp6s())
  {	return ret;  }
#endif  __CONFIG_DHCPV6S__ */

#ifdef __CONFIG_RADVD__
	if (ret= start_radvd(/*int*/ sintMode))
	{	return ret;  }
#endif /* __CONFIG_RADVD__ */

	if (sintMode & IPV6_WAN_NATIVE_ENABLED)
	/**************************************
	*  Setup v6 routing table:
	**************************************/
	{	char cmdline[256];
#if 0
		//sprintf(cmdline, "/usr/sbin/ip -6 route add %s dev %s metric 1", nvram_safe_get("ipv6_wan_prefix"), nvram_safe_get("wan0_ifname"));
		sprintf(cmdline, "/usr/sbin/ip -6 route add %s dev %s metric 1", nvram_safe_get("ipv6_wan_prefix"), nvram_safe_get("wan_ifname"));
		ret = system(cmdline);
#endif
		sprintf(cmdline, "/usr/sbin/ip -6 route add %s dev %s metric 1", nvram_safe_get("ipv6_lan_prefix"), nvram_safe_get("lan_ifname"));
		ret = system(cmdline);
	}

	/* Note that 6to4 is done in wan_up()! */

	return ret;
}
#endif /* __CONFIG_IPV6__ */

int
stop_dns_clear_resolv(void)
{
        int ret = eval("killall", "dnsmasq");
	char buf[80];
                                                                                                                             
	snprintf(buf, sizeof(buf), "echo "" > %s", RESOLV_FILE);
	system(buf);
                                                                                                                             
        dprintf("done\n");
        return ret;
}

#ifdef WIRELESS_WARNING_PAGE_SUPPORT
void clear_wl_warning_rule(void)
{
	if( nvram_match("warning_page_checked","1") || 		// button checked 
	   ( (nvram_match("wl0_net_mode","disabled") || nvram_invmatch("wl0_security_mode","disabled")) &&	//wireless 2.4g
	     (nvram_match("wl1_net_mode","disabled") || nvram_invmatch("wl1_security_mode","disabled")) ) )	//wireless 5g
	{
#if 0
		//nvram_set("warning_page_checked","1");
		eval("iptables","-t","nat","-F","wlwarning2wan");
		eval("iptables","-F","wlwarningaccept");
		eval("killall", "wnbibn");
#else
		system("echo \"0\" > /proc/wl_warning_page");
		eval("iptables","-t","nat","-F","wlwarning2wan");
		eval("iptables","-F","wlwarningaccept");
#endif
	}
}

int stop_wl_warning_httpd(void)
{
	int ret = eval("killall", "wm-httpd");
	unlink("/var/run/wm-httpd.pid");

	//tlhhh. Notify kernel stop wl_warning_page monitor
	system("echo \"0\" > /proc/wl_warning_page");

	dprintf("done\n");
	return ret;
}

int
start_wl_warning_httpd(void)
{
	int ret=0;

	if(nvram_invmatch("warning_page_checked","1") &&		// not checked 
	  ((nvram_invmatch("wl0_net_mode","disabled") && nvram_match("wl0_security_mode","disabled")) ||	//wireless 2.4g
	   (nvram_invmatch("wl1_net_mode","disabled") && nvram_match("wl1_security_mode","disabled"))) )	//wireless 5g
	{

		if(!is_exist("/var/run/wm-httpd.pid"))
		{
			symlink("/usr/sbin/httpd", "/tmp/wm-httpd");
			chdir("/www");
			ret = eval("/tmp/wm-httpd", "-p", nvram_safe_get("warning_http_port"), "-w");
			chdir("/");

		}
			//tlhhh. No matter if wm-httpd existed, notify kernel start wl_warning_page monitor.
			system("echo \"1\" > /proc/wl_warning_page");

	}

	dprintf("done");
	return ret;
}
#endif

#ifdef GUEST_NETWORK_SUPPORT
int 
start_gn_httpd(void)
{
	int ret;

       	if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
          !strcmp(nvram_safe_get("wk_mode"), "gateway") &&
          strcmp(nvram_safe_get("wl0_gmode"), "-1"))
       	{	
		symlink("/usr/sbin/httpd", "/tmp/gn-httpd");

		if(!is_exist("/var/run/guest-httpd.pid"))
		{
			chdir("/www");
			ret = eval("/tmp/gn-httpd", "-p", nvram_safe_get("gn_http_port"), "-G");
			chdir("/");
		}
 
	//Jemmy port form E2000 to remove https redirect in guest network 2009.11.25
#if 0
#ifdef HTTPS_SUPPORT
		if(!is_exist("/var/run/guest-httpsd.pid"))
		{
      #ifdef OPENSSL_SUPPORT
      			if(!is_exist("/tmp/cert.pem") || !is_exist("/tmp/key.pem")) {
                       		/*fixed GPL release issue +++*/
                       		eval("gen_opensslcnf");
                       		/*fixed GPL release issue ---*/
                      		 eval("gencert.sh", BUILD_SECS);
               		}
       #endif
#if defined(XYSSL_SUPPORT) && defined(SELFSIGN_SUPPORT)
		{
			char buf[64];
			sprintf(buf, "/usr/bin/selfsign %s", nvram_safe_get("lan_ipaddr"));
			system(buf);
		}
#endif
			chdir("/www");
               		ret = eval("/tmp/gn-httpd", "-S", "-p", nvram_safe_get("gn_https_port"), "-G");
               		chdir("/");
		}
#endif
#endif
       	}

	dprintf("done");
	return ret;
}
int stop_gn_httpd(void)
{
	int ret = eval("killall", "gn-httpd");
//add by michael to fix the DeviceSettings2 fail in HNAP with EGHN at 20080426
        sleep(1);
        eval("killall","gn-httpd");
//end by michael
	unlink("/var/run/guest-httpd.pid");

	//Jemmy port form E2000 to remove https redirect in guest network 2009.11.25
	//unlink("/var/run/guest-httpsd.pid");

	dprintf("done\n");
	return ret;
}

#endif
int
start_httpd(void)
{
#ifdef STORAGE_SUPPORT
	const char *server_port;
	const char *lan_ipaddr;
	FILE *fp;
	const char *wlan_ifname;
#endif
	int ret = 0;
	if(nvram_invmatch("http_enable", "0") && !is_exist("/var/run/httpd.pid")) {
		chdir("/www");
#ifdef MULTILANG_PAGE_SUPPORT
		do {
                        char buf[20];
                        char *user_language;
                        user_language = nvram_get("user_language");
                        if(user_language)
                        {
                                nvram_set("language", user_language);
                        }
                        else
                        {
                              // if(is_exist("/www/lang_pack/language") && file_to_buf("/www/lang_pack/language", buf, sizeof(buf)))
                              // {
                              //        nvram_set("language", buf);
                              //  }
                              //  else
                              //  {
                                        nvram_set("language", "EN");
                              //  }
                        }
                } while(0);

		if(nvram_match("language", "EN"))
		{
			cprintf("[HTTPD Starting on /www]\n");
		}
		else
		{
			if(chdir("/tmp/www") == 0)
				cprintf("[HTTPD Starting on /tmp/www]\n");
			else
				cprintf("[HTTPD Starting on /www]\n");
		}
#endif
		ret = eval("httpd");
		chdir("/");
	}
#ifdef GUEST_NETWORK_SUPPORT
	start_gn_httpd();
#endif
#ifdef WIRELESS_WARNING_PAGE_SUPPORT
	start_wl_warning_httpd();
#endif

#ifdef HTTPS_SUPPORT
	if(nvram_invmatch("https_enable", "0") && !is_exist("/var/run/httpsd.pid")) {

#if 0
		/* Import certificate from file */
		if(nvram_get("https_cert") && nvram_get("https_key") &&
                   !nvram_match("https_cert", "") && !nvram_match("https_key", "")) {
			nvram2file("https_cert", "/tmp/cert.pem");
			nvram2file("https_key", "/tmp/key.pem");
		}
#endif
//delete by michael for change openssl to xyssl at 20080414
#if 0
		// Generate a new certificate
		if(!is_exist("/tmp/cert.pem") || !is_exist("/tmp/key.pem")) {
			eval("gencert.sh", BUILD_SECS);		
			
#if 0
			/* Export certificate to file*/
			file2nvram("/tmp/cert.pem", "https_cert");	
			file2nvram("/tmp/key.pem", "https_key");	
			nvram_commit();
#endif
		}
#endif
//end by michael

/*-- begin wuzh add for generate cert.pem 2008-4-22 --*/
#if (defined(XYSSL_SUPPORT) || defined(POLARSSL_SUPPORT)) && defined(SELFSIGN_SUPPORT)
		{
			char buf[64];
			sprintf(buf, "/usr/bin/selfsign %s", nvram_safe_get("lan_ipaddr"));
			system(buf);
		}
#endif
/*-- end wuzh add for generate cert.pem 2008-4-22 --*/

		chdir("/www");
#ifdef MULTILANG_PAGE_SUPPORT
		if(nvram_match("language", "EN"))
		{
			cprintf("[HTTPD -S Starting on /www]\n");
		}
		else
		{
			if(chdir("/tmp/www") == 0)
				cprintf("[HTTPD -S Starting on /tmp/www]\n");
			else
				cprintf("[HTTPD -S Starting on /www]\n");
		}
#endif
		ret = eval("httpd", "-S");
		chdir("/");
	#if defined(TRENDMICRO_SSS_SUPPORT) || defined(HNAP_SUPPORT)
		/*[BUG] IR-B0009436 httpd crashed: cannot display blocking page*/
		pid_t *pid = find_pid_by_name( "check_http.sh" );
		if (0 > *pid)
		{
			cprintf("cmd=[/usr/sbin/check_http.sh]\n");
			system("/usr/sbin/check_http.sh &");
		}
	#endif //TRENDMICRO_SSS_SUPPORT || HNAP_SUPPORT
	}
#endif
//delete by michael to remove the config share folder at 20090205
#if 0
#ifdef STORAGE_SUPPORT
	server_port = nvram_safe_get("web_configuration_port");
	mkdir("/tmp/configuration_share", 0777);
	lan_ipaddr = nvram_safe_get("lan_ipaddr");
	fp = fopen("/tmp/configuration_share/NAS_Configuration.html", "w");
	if (fp == NULL)
	{
		perror("/tmp/configuration_share/NAS_Configuration.html");
		return errno;
	}
	fprintf(fp,
			"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 "
			"Transitional//EN\">\n");
	fprintf(fp, "<html lang=\"en\">\n");
	fprintf(fp, "<head>\n");
	fprintf(fp, "<title>NAS Configuration</title>\n");
	fprintf(fp,
			"<meta http-equiv=\"Content-Type\" content=\"text/html; "
			"charset=utf-8\">\n");
	fprintf(fp, "<script language=\"javascript\">\n");
	fprintf(fp, "\n");
	fprintf(fp, "function redirect_page()\n");
	fprintf(fp, "{\n");
	fprintf(fp, "    document.location.href=\"http://%s/storage/NAS_Administration.asp", lan_ipaddr);
	if ((server_port != NULL) && (server_port[0] != 0))
		fprintf(fp, ":%s", server_port);
	fprintf(fp, "\";\n");
	fprintf(fp, "}\n");
	fprintf(fp, "\n");
	fprintf(fp, "</script>\n");
	fprintf(fp, "</head>\n");
	fprintf(fp, "\n");
	fprintf(fp, "<body onload=\'setTimeout(\"redirect_page()\", 1000)\'>\n");
	fprintf(fp,
			"  <a href=\"http://%s", lan_ipaddr);
	if ((server_port != NULL) && (server_port[0] != 0))
		fprintf(fp, ":%s", server_port);
	fprintf(fp,
                      "\">If you aren't automatically re-directed in 1 second, click "
                      "here to begin your WRT610N NAS configuration</a>\n");
	fprintf(fp, "</body>\n");
	fprintf(fp, "</html>\n");
	fflush(fp);
	if (ferror(fp))
	{
		perror("/tmp/configuration_share/Configuration.html");
		return errno;
	}
	fclose(fp);

	wlan_ifname = nvram_safe_get("wlan_ifname");
	if ((wlan_ifname != NULL) && (wlan_ifname[0] != 0))
	{
		const char *wlan_ipaddr;

		wlan_ipaddr = nvram_safe_get("wlan_ipaddr");
		fp = fopen("/tmp/configuration_share/ConfigurationFromWLAN.html", "w");
		if (fp == NULL)
		{
			perror("/tmp/configuration_share/ConfigurationFromWLAN.html");
			return errno;
		}
		fprintf(fp,
				"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 "
				"Transitional//EN\">\n");
		fprintf(fp, "<html lang=\"en\">\n");
		fprintf(fp, "<head>\n");
		fprintf(fp, "<title>BroadNAS Configuration via WLAN</title>\n");
		fprintf(fp,
				"<meta http-equiv=\"Content-Type\" content=\"text/html; "
				"charset=utf-8\">\n");
		fprintf(fp, "<script language=\"javascript\">\n");
		fprintf(fp, "\n");
		fprintf(fp, "function redirect_page()\n");
		fprintf(fp, "{\n");
		fprintf(fp, "    document.location.href=\"http://%s", wlan_ipaddr);
		if ((server_port != NULL) && (server_port[0] != 0))
			fprintf(fp, ":%s", server_port);
		fprintf(fp, "\";\n");
		fprintf(fp, "}\n");
		fprintf(fp, "\n");
		fprintf(fp, "</script>\n");
		fprintf(fp, "</head>\n");
		fprintf(fp, "\n");
		fprintf(fp,
				"<body onload=\'setTimeout(\"redirect_page()\", 1000)\'>\n");
		fprintf(fp, "  <a href=\"http://%s", wlan_ipaddr);
		if ((server_port != NULL) && (server_port[0] != 0))
			fprintf(fp, ":%s", server_port);
		fprintf(fp,
				"\">If you aren't automatically re-directed in 1 second, click"
				" here to begin your BroadNAS configuration</a>\n");
		fprintf(fp, "</body>\n");
		fprintf(fp, "</html>\n");
		fflush(fp);
		if (ferror(fp))
		{
			perror("/tmp/configuration_share/ConfigurationFromWLAN.html");
			return errno;
		}
		fclose(fp);
	}
#endif
#endif
//end by michael	
	
	dprintf("done\n");
	return ret;
}

int
stop_httpd(void)
{
	int ret = eval("killall", "httpd");
//add by michael to fix the DeviceSettings2 fail in HNAP with EGHN at 20080426
#ifdef EGHN_SUPPORT
                sleep(1);
                eval("killall","httpd");
#endif
//end by michael
	unlink("/var/run/httpd.pid");
	unlink("/var/run/httpsd.pid");
//#ifdef TRENDMICRO_SSS_SUPPORT || HNAP_SUPPORT
#if defined(TRENDMICRO_SSS_SUPPORT) || defined(HNAP_SUPPORT)
	/*[BUG] IR-B0009436 httpd crashed: cannot display blocking page*/
	system("killall check_http.sh");
#endif //TRENDMICRO_SSS_SUPPORT || HNAP_SUPPORT

#ifdef GUEST_NETWORK_SUPPORT
	stop_gn_httpd();
#endif
#ifdef WIRELESS_WARNING_PAGE_SUPPORT
	stop_wl_warning_httpd();
#endif
	dprintf("done\n");
	return ret;
}

//add by michael to add the monitor_disk at 20090210
#ifdef MONITOR_USB_SUPPORT
int start_monitor_disk(void)
{
	int ret;
	ret = eval("/sbin/monitor_disk");
	dprintf("done\n");
	return ret;
}

int stop_monitor_disk(void)
{
	int ret;
	ret =eval("killall","monitor_disk");
	return ret;
}
#endif
//end by michael

int
start_upnp(void)
{
	int ret;
	char sleep_time[20];
#ifdef __CONFIG_BCMUPNP__
        char var[100],prefix[] = "wanXXXXXXXXXX_";
        char *wan_ifname;
#endif

	if (!nvram_invmatch("upnp_enable", "0"))
		return 0;

#ifdef __CONFIG_SES__
	/* UPNP conflict with SES2 , so we want to delay UPNP daemon after SES2 is configured first. */
	if(nvram_match("ses_fsm_current_states", "06:03") || nvram_match("ses_fsm_current_states", "06:01"))
		snprintf(sleep_time, sizeof(sleep_time), "%d", 6);
	else
#endif
		snprintf(sleep_time, sizeof(sleep_time), "%d", 0);

	//Jemmy Fixed 2009.4.27
#ifdef __CONFIG_UPNP__
        ret = eval("upnp", "-D",
	       "-L", nvram_safe_get("lan_ifname"),
	       "-W", nvram_safe_get("wan_iface"),
	       "-S", sleep_time,
	       "-I", nvram_safe_get("upnp_ssdp_interval"),
	       "-A", nvram_safe_get("upnp_max_age"));
#else
#ifdef __CONFIG_BCMUPNP__
        ret = eval("killall", "-SIGUSR1", "upnp");
        if (ret != 0) {
            //snprintf(prefix, sizeof(prefix), "wan%d_", wan_primary_ifunit());
            snprintf(prefix, sizeof(prefix), "wan_");
            wan_ifname = nvram_match(strcat_r(prefix, "proto", var), "pppoe") ?\
                    nvram_safe_get("pppoe_ifname") :\
                                nvram_safe_get(strcat_r(prefix, "ifname", var));
 
                ret = eval("upnp", "-D", "-W", wan_ifname);
        }
#endif
#endif

	dprintf("done\n");
	return ret;
}

int
stop_upnp(void)
{
	//int ret = eval("killall", "-USR1", "upnp");
	int ret = 0;
	eval("killall", "upnp");
	
	dprintf("done\n");
	return ret;
}

int
reinit_upnp(void)
{
	//Jemmy Fix 2009.4.27
#ifdef __CONFIG_BCMUPNP__
        int ret = eval("killall", "-USR1", "upnp");

        return ret;
#else
	return 1;
#endif
}

void set_device_LEDs(void)
{
        char cmd[64];
        FILE *fd;
       
        if (nvram_match("turn_leds", "0")) //turn off all LEDs off exept cisco connect logo
        {       
                //turn off all switch LEDs
                eval("et", "robowr", "0x0", "0x18", "0x0");
                eval("et", "robowr", "0x0", "0x1a", "0x0");
#if 0
                //turn off 2.4G wireless LED
                snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x2 0x0", nvram_safe_get("wl0_ifname"));
                wl_exec_cmd(cmd);
                snprintf(cmd, sizeof(cmd), "wl -i %s led_blinkmed 0x0", nvram_safe_get("wl0_ifname"));
                wl_exec_cmd(cmd);
                //turn off 5G wireless LED
                snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x4 0x0", nvram_safe_get("wl1_ifname"));
                wl_exec_cmd(cmd);
                snprintf(cmd, sizeof(cmd), "wl -i %s led_blinkmed 0x0", nvram_safe_get("wl1_ifname"));
                wl_exec_cmd(cmd);
                //turn off wireless security LED
                diag_led(SES_LED1,STOP_LED);
                diag_led(SES_LED2,STOP_LED);
                //turn off USB LED
                //diag_led(USB_LED, START_LED);
		eval("power_led", "7", "0");
#endif
        }else if (nvram_match("turn_leds", "1")) //turn on all LEDs AUTO
        {
                //turn all switch LEDs to AUTO
                eval("et", "robowr", "0x0", "0x18", "0x1f");
                eval("et", "robowr", "0x0", "0x1a", "0x1f");
#if 0 
                //turn on  wireless LED
                snprintf(cmd, sizeof(cmd), "wl -i %s led_blinkmed 0x500014", nvram_safe_get("wl0_ifname"));
                printf("%s\n", cmd);
                wl_exec_cmd(cmd);
                snprintf(cmd, sizeof(cmd), "wl -i %s led_blinkmed 0x500014", nvram_safe_get("wl1_ifname"));
                wl_exec_cmd(cmd);
                printf("%s\n", cmd);
                if(nvram_invmatch("wl0_gmode", "-1"))
                {
                        snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x2 0x2", nvram_safe_get("wl0_ifname"));
                        wl_exec_cmd(cmd);
                }
 
                if(nvram_invmatch("wl1_gmode", "-1"))
                {
                        snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x4 0x4", nvram_safe_get("wl1_ifname"));
                        wl_exec_cmd(cmd);
                }
                //turn on wireless security LED
                if((nvram_invmatch("security_mode_0", "disabled") && nvram_invmatch("security_mode_1", "disabled")) &&
                   (nvram_invmatch("wl0_net_mode","disabled") && nvram_invmatch("wl1_net_mode","disabled") ))
                {
                        diag_led(SES_LED2,START_LED);
                }
 
                //turn on USB LED if inserted USB device
                if (fd = fopen("/dev/scsi/host0/bus0/target0/lun0/disc", "rb"))
                {
			eval("power_led", "7", "1");
                        //diag_led(USB_LED, STOP_LED);
                        fclose(fd);
                }
#endif
        }
}

#ifdef __CONFIG_SES__
int
start_ses(void)
{
	//if(nvram_match("wl_gmode", "-1"))
	if(nvram_match("wl0_gmode", "-1") && nvram_match("wl1_gmode", "-1"))
		return 0;

	if (nvram_match("ses_enable", "1")) {
		eval("ses", "-f");
	}
	return 0;
}

int
stop_ses(void)
{
	int ret = 0;

	//if(nvram_match("wl_gmode", "-1") || nvram_match("ses_enable", "0")) {
	if(nvram_match("wl0_gmode", "-1") || nvram_match("ses_enable", "0")) {
		diag_led(SES_LED1,STOP_LED);
		diag_led(SES_LED2,STOP_LED);
	}

	if(nvram_match("wl1_gmode", "-1") || nvram_match("ses_enable", "0")) {
		//diag_led(SES_LED1,STOP_LED);
		//diag_led(SES_LED2,STOP_LED);
	}

	ret = eval("killall", "ses");

	return ret;
}
#endif	/* __CONFIG_SES__ */

static void
convert_wds(void)
{
	char wds_mac[254];
	char buf[254];
	char wl_wds[]="wl0_wdsXXX";
	int i = 0;
	int j;
	char mac[254];
	char *next;

	//Jemmy modify for dual band wireless 2008.3.1
	if(nvram_match("wl0_wds", ""))		// For Router, accept all WDS link
		strcpy(wds_mac, "*");
	else					// For AP, assign remote WDS MAC
		strcpy(wds_mac, nvram_safe_get("wl0_wds"));
	
	/* For WPA-PSK mode, we want to convert wl_wds_mac to wl0_wds0 ... wl0_wds255 */
	if(nvram_match("wl0_security_mode", "wpa_personal")) {
		foreach(mac, wds_mac, next) {
			snprintf(wl_wds, sizeof(wl_wds), "wl0_wds%d", i);
			snprintf(buf, sizeof(buf), "%s,auto,%s,psk,%s,%s", 
				mac, 
				nvram_safe_get("wl0_crypto"), 
				nvram_safe_get("wl0_ssid"), 
				nvram_safe_get("wl0_wpa_psk"));

			nvram_set(wl_wds, buf);
			i++;
		}
		
		/* Del unused entry */
		for(j = i; j < MAX_NVPARSE; j++)
			del_wds_wsec(0,j);
	}

	//Jemmy add for dual band wireless 2008.3.1
	if(nvram_match("wl1_wds", ""))		// For Router, accept all WDS link
		strcpy(wds_mac, "*");
	else					// For AP, assign remote WDS MAC
		strcpy(wds_mac, nvram_safe_get("wl1_wds"));
	
	/* For WPA-PSK mode, we want to convert wl_wds_mac to wl0_wds0 ... wl0_wds255 */
	if(nvram_match("wl1_security_mode", "wpa_personal")) {
		foreach(mac, wds_mac, next) {
			snprintf(wl_wds, sizeof(wl_wds), "wl1_wds%d", i);
			snprintf(buf, sizeof(buf), "%s,auto,%s,psk,%s,%s", 
				mac, 
				nvram_safe_get("wl1_crypto"), 
				nvram_safe_get("wl1_ssid"), 
				nvram_safe_get("wl1_wpa_psk"));

			nvram_set(wl_wds, buf);
			i++;
		}
		
		/* Del unused entry */
		for(j = i; j < MAX_NVPARSE; j++)
			del_wds_wsec(1,j);
	}
}

#ifdef __CONFIG_SES__
int
start_ses_cl(void)
{
	if (nvram_match("ses_cl_enable", "1")) {
		eval("ses_cl", "-f");
	}

	return 0;
}

int
stop_ses_cl(void)
{
	int ret = 0;

	ret = eval("killall", "ses_cl");
	return ret;
}
#endif //__CONFIG_SES__

//Jemmy port new WPS from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
int
start_nas(char *type)
{
	char cfgfile[64];
	char pidfile[64];
	
	//Jemmy modify for dual band wireless 2008.3.1, and fix 2008.3.26
	char *security_mode = nvram_safe_get("security_mode_1");

	/* The WPA and PSK mode don't support Shared Key */
	if(strstr(security_mode, "psk") || strstr(security_mode, "wpa") || !strcmp(security_mode, "disabled"))
		nvram_set("wl1_auth", "0");

	
	security_mode = nvram_safe_get("security_mode_0");
	/* The WPA and PSK mode don't support Shared Key */
	if(strstr(security_mode, "psk") || strstr(security_mode, "wpa") || !strcmp(security_mode, "disabled"))
		nvram_set("wl0_auth", "0");

#ifdef WSC_SUPPORT
#ifndef __CONFIG_WSCCMD__ //Add by crazy 20080423: Move this part to function start_wsc().
	if(strstr(security_mode, "wpa") || strstr(security_mode, "wep"))
	{
		nvram_set("wl_wsc_mode","disabled");
		nvram_set("wsc_security_auto","0");
		nvram_set("wsc_enable","0");
	}else if(nvram_match("wl_wsc_mode","disabled"))	{
		nvram_set("wl_wsc_mode","enabled");
		nvram_set("wsc_security_auto","0");
		nvram_set("wsc_enable","1");
	}
#endif /* __CONFIG_WSCCMD__ */
#endif

	/* The WPA mode need some extra parameters for WDS mode. */
	convert_wds();

	if (!type || !*type)
		type = "lan";

	//Add by crazy 20080506 ==>
	//Fix bug [EWW400-A1-LS 0012388]: When the PIN number which enter in DUT is wrong,DUT is halt.
	if(!strcmp(type, "lan"))
	{
		nvram_set("nas_kill_wsc_times", "0");
	}
	//<== End of Addition 20080506

	/* Configure NAS on the bridged interface */
	snprintf(cfgfile, sizeof(cfgfile), "/tmp/nas.%s.conf", type);
	snprintf(pidfile, sizeof(pidfile), "/tmp/nas.%s.pid", type);
	{
		char *argv[] = {"nas", cfgfile, pidfile, type, NULL};
		pid_t pid;

		_eval(argv, NULL, 0, &pid);
		dprintf("done\n");
	}

	return 0;
}

int
stop_nas(void)
{
	int ret = eval("killall", "nas");

	dprintf("done\n");
	return ret;
}
#else
int
start_eapd(void)
{
	int ret = eval("/bin/eapd");

	return ret;
}
                                                                                                                             
int
stop_eapd(void)
{
	int ret = eval("killall","eapd");

	return ret;
}
                                                                                                                             
int
start_nas(void)
{
	int ret = eval("nas");

	return ret;
}
                                                                                                                             
int
stop_nas(void)
{
	int ret = eval("killall", "nas");

	return ret;
}
#endif

int
start_ntpc(void)
{
	char *servers = nvram_safe_get("ntp_server");

#ifdef THROUGHPUT_TEST_SUPPORT
        if(nvram_match("throughput_test","1"))
                return 0;
#endif

	if (strlen(servers)) {
		char *nas_argv[] = {"ntpclient", "-h", servers, "-i", "3", "-l", "-s", NULL};
		pid_t pid;

		_eval(nas_argv, NULL, 0, &pid);
	}

	dprintf("done\n");
	return 0;
}

int
stop_ntpc(void)
{
	int ret = eval("killall", "ntpclient");

	dprintf("done\n");
	return ret;
}

#ifdef LAN_AUTO_DHCP_SUPPORT
int check_lan_ip(void)
{
	FILE *fp;

	if(!(fp=fopen("/tmp/lan_ip_check","r")))
		return 0;
	else
	{
		fclose(fp);
		return 1;
	}
}
int
start_auto_dhcp_detect(void)
{
	FILE *fp;
	char tmp_lan_ip[20];
	char tmp_netmask[20];
	int i;

	memcpy(&tmp_lan_ip, nvram_safe_get("lan_ipaddr"), 20);
	memcpy(&tmp_netmask, nvram_safe_get("lan_netmask"), 20);

#ifdef DHCPV6C_SUPPORT
	fprintf(stderr, "=====(dhcp6 doesn't do auto-dhcp-detect)=====\n");
#else
	start_dhcpc("lan");
	for(i=0; i<3; i++)
		sleep(1);
#endif

	//cprintf("tallest:=====(lan_ip = %s, %s, %s)=====\n",nvram_safe_get("lan_ipaddr"), &tmp_lan_ip, &tmp_netmask);
	if(!check_lan_ip())
	{
		cprintf("no dhcp server in lan !! starting dhcp server...\n");
		stop_dhcpc();
		sleep(3);

		eval("ifconfig", nvram_safe_get("lan_ifname"), &tmp_lan_ip);
		start_dhcpd();
	}
	
	return 0;
}
#endif

#ifdef UTELNETD_SUPPORT
int
start_telnet(void)
{
   	int ret;

#ifdef BUILD_MFG_SUPPORT
  	ret = eval("utelnetd", "-d", 
		   "-i", nvram_safe_get("lan_ifname"),
		   "-l", "/bin/sh",	// need BUSYBOX_LOGIN_SUPPORT
		   "-p", nvram_safe_get("telnet_port"));
#else
	if(nvram_invmatch("telnet_enable","1"))
		return 0;

  	ret = eval("utelnetd", "-d", 
		   "-i", nvram_safe_get("lan_ifname"),
		   "-l", "/bin/login",	// need BUSYBOX_LOGIN_SUPPORT
		   "-p", nvram_safe_get("telnet_port"));
#endif

   	return ret;
}

int
stop_telnet(void)
{
   	int ret;
   	ret = eval("killall","utelnetd");
   	return ret;
}
#endif

/*added for EGHN-bonjour*/
#ifdef EGHN
int
start_bonjour(void)
{
   	int ret = 0;

	if(nvram_match("bonjour_status","1"))
	{
		char *bonjour_argv[] = {"mDNSResponder", 
							"-n", "WRT600N", 
							"-t", "_http._tcp.", 
							"-d", "local.", 
							"-p", "80",
							NULL};
		pid_t pid;

		printf("Starting bonjour\n");

		ret = _eval(bonjour_argv, NULL, 0, &pid);
	
		printf("done\n");
	}
   	return ret;
}

int
stop_bonjour(void)
{
   	int ret;

   	ret = eval("killall","-SIGINT","mDNSResponder");

   	return ret;
}

#endif
/* EGHN */

#ifdef __CONFIG_WSCCMD__
int
start_wsc(void)
{
	char *security_mode = nvram_safe_get("security_mode_1"); //Add by crazy 20080423

	if(nvram_match("wl0_net_mode", "disabled") && nvram_match("wl1_net_mode", "disabled"))
	{
		return -1;
	}
	else if(nvram_match("wl0_net_mode", "disabled"))
	{
		nvram_set("wsc_ifname", "wl1");
                //Jemmy add for disabled 2.4G band wps 2008.11.25
                nvram_set("wl0_wsc_mode","disabled");
	}
	else if(nvram_match("wl1_net_mode", "disabled"))
	{
		nvram_set("wsc_ifname", "wl0");
                //Jemmy add for disabled 5G band wps 2008.11.25
                nvram_set("wl1_wsc_mode","disabled");
	}

	//Add by crazy 20080423: For dual band test.
	if(strstr(security_mode, "wpa") || strstr(security_mode, "radius")) //|| strstr(security_mode, "wep"))
	{//Enable WPS-WEP.
		nvram_set("wl1_wsc_mode","disabled");
		nvram_set("wsc_ifname", "wl0");
	}
	else if(nvram_match("wl1_wsc_mode","disabled")) 
	{
                //Jemmy add for enable 2.4G band wps 2008.11.25
                if(nvram_invmatch("wl1_net_mode", "disabled"))
			nvram_set("wl1_wsc_mode","enabled");
	}
	
	security_mode = nvram_safe_get("security_mode_0");

	if(strstr(security_mode, "wpa") || strstr(security_mode, "radius")) // || strstr(security_mode, "wep"))
	{//Enable WPS-WEP
		nvram_set("wl0_wsc_mode","disabled");
		nvram_set("wsc_ifname", "wl1");
	}
	else if(nvram_match("wl0_wsc_mode","disabled"))	
	{
                //Jemmy add for enable  5G band wps 2008.11.25
                if(nvram_invmatch("wl0_net_mode", "disabled"))
			nvram_set("wl0_wsc_mode","enabled");
	}

	//Chcck dual band WPS status. 
	if(nvram_match("wl0_wsc_mode","disabled") && nvram_match("wl1_wsc_mode","disabled"))
	{
		nvram_set("wsc_security_auto","0");
		nvram_set("wsc_enable","0");
	}
	else 
	{                
		nvram_set("wsc_enable","1");
	}
	//<--End add
	
	//if((!nvram_match("wsc_cli","1")) && nvram_match("wsc_mode","enabled"))
	if((!nvram_match("wsc_cli","1")) && nvram_match("wsc_enable","1"))
	{
		if (nvram_match("wsc_restart", "no")) {

			nvram_set("wsc_restart", "normal");
		}
		else
		{
			char *wsc_argv[] = {"/bin/wsccmd", NULL};
			pid_t pid;

			dprintf("Starting wsc\n");
			nvram_set("wsc_restart", "yes");

			_eval(wsc_argv, NULL, 0, &pid);
		}
	}
	return 0;

}

int
stop_wsc(void)
{
   	int ret;

	//if((!nvram_match("wsc_cli","1")) && nvram_match("wl_wsc_mode","enabled"))
	if(!nvram_match("wsc_cli","1"))
	{
		if (nvram_match("wsc_restart", "no")) {
			return 0;
		}
		else
		{
			nvram_set("wsc_restart", "yes");
		   	ret = eval("killall","wsccmd");
		}
	}
   	return ret;

}
#endif

//Jemmy add when porting BSP.5.20.20 2008.10.13
#ifdef __CONFIG_WPS__
int
start_wps(void)
{
	char *security_mode;
	char *wps_argv[] = {"/bin/wps_monitor", NULL};
	pid_t pid;

	if(nvram_match("wl0_net_mode", "disabled")
#ifdef SIMUL_DUAL_BAND_SUPPORT
	&& nvram_match("wl1_net_mode", "disabled")
#endif
	)
	{
		return -1;
	}

	printf("Enter <%s>...\n", __FUNCTION__);

	nvram_set("wps_status", "0");
	nvram_set("wps_method", "1");
	nvram_set("wps_config_command", "0");
        nvram_set("wps_pbc_method_hw", "0");
        nvram_set("wsc_count2","0");
        nvram_set("wsc_steps","0");

	//Jemmy add for disabled 2.4G band wps 2008.11.25
	if(nvram_match("wl0_net_mode", "disabled"))
		nvram_set("wl0_wps_mode","disabled");
	else
		nvram_set("wl0_wps_mode","enabled");

#ifdef SIMUL_DUAL_BAND_SUPPORT
	if(nvram_match("wl1_net_mode", "disabled"))
		nvram_set("wl1_wps_mode","disabled");
	else    
		nvram_set("wl1_wps_mode","enabled");
	
	security_mode = nvram_safe_get("security_mode_1");

	//Add by Jemmy 2009.6.10 For dual band test.
	if(strstr(security_mode, "wpa") || strstr(security_mode, "radius")) //|| strstr(security_mode, "wep"))
	{//Enable WPS-WEP.
		nvram_set("wl1_wps_mode","disabled");
	}
	else if(nvram_match("wl1_wps_mode","disabled"))
	{
		//Jemmy add for enable 2.4G band wps 2008.11.25
		if(nvram_invmatch("wl1_net_mode", "disabled"))
			nvram_set("wl1_wps_mode","enabled");
	}
#endif
	security_mode = nvram_safe_get("security_mode_0");

	if(strstr(security_mode, "wpa") || strstr(security_mode, "radius")) // || strstr(security_mode, "wep"))
	{//Enable WPS-WEP
		nvram_set("wl0_wps_mode","disabled");
	}
	else if(nvram_match("wl0_wps_mode","disabled"))
	{
		//Jemmy add for enable  5G band wps 2008.11.25
		if(nvram_invmatch("wl0_net_mode", "disabled"))
			nvram_set("wl0_wps_mode","enabled");
	}

	if (nvram_match("wps_restart", "1")) {
		nvram_set("wps_restart", "0");
	}
	else {
		nvram_set("wps_restart", "0");
		nvram_set("wps_proc_status", "0");
	}

	nvram_set("wps_sta_pin", "00000000");

	eval("killall","wps_monitor");
	eval("killall","wps_ap");
	eval("killall","wps_enr");
	_eval(wps_argv, NULL, 0, &pid);

	return 0;
}
                                                                                                                             
int
stop_wps(void)
{
	int ret = 0;

	ret = eval("killall","wps_monitor");
	ret = eval("killall","wps_ap");

	return ret;
}
#endif

//add by michael to change the apply action of macfilter at 20080802
void start_macfilter(void)
{
	char maclist[1024];
	char cmd[1024];
	struct wl_assoc_mac *wlmac=NULL;
	int i,count_wl;

	memset(cmd,0,sizeof(cmd));
	memset(maclist,0,sizeof(maclist));
	strcpy(maclist,nvram_safe_get("wl_maclist"));

	if(nvram_invmatch("wl0_net_mode","disabled"))
	{
		/* set the maclist in 2.4 Band*/
		if(!strcmp(maclist,"\0"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl0_ifname"));
		}
		else
		{
			/* first clean the mac list */
			snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl0_ifname"));
			wl_exec_cmd(cmd);
	
			/*set the new maclist*/
			snprintf(cmd,sizeof(cmd),"wl -i %s mac %s",nvram_safe_get("wl0_ifname"),maclist);
		}
		wl_exec_cmd(cmd);
	
		/* set the mac mode in 2.4G */
		memset(cmd,0,sizeof(cmd));
		if (!strcmp(nvram_safe_get("wl_macmode"),"disabled"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 0",nvram_safe_get("wl0_ifname"));
		}
		else if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 1",nvram_safe_get("wl0_ifname"));
		}
		else
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 2",nvram_safe_get("wl0_ifname"));
		}
		wl_exec_cmd(cmd);
		
#if 0
		/* reset the ssid to make the setting effective*/
		memset(cmd,0,sizeof(cmd));
		snprintf(cmd,sizeof(cmd),"wl -i %s ssid %s",nvram_safe_get("wl0_ifname"),nvram_safe_get("wl0_ssid"));
		wl_exec_cmd(cmd);
#else
		wlmac = get_wl_band_assoc_mac(&count_wl,"wl0");
		for(i=0; i<count_wl;i++)
		{
			char var[18]={},*next=NULL;		
			int match = 0,in_list = 0;
			char list_tmp[1024];
			memset(list_tmp,0,sizeof(list_tmp));
			strncpy(list_tmp,maclist,sizeof(maclist));

			// check whether the mac addr is in the maclist
			foreach(var,list_tmp,next)
			{
				if(!strcasecmp(var,wlmac[i].mac))
				{
					in_list = 1;
					break;
				}
			}

			/* if it is in the maclist , judge the macmode*/
			if(in_list == 1)
			{
				if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))	//need to do deauthenticate
					match = 1;
			}
			else
			{
				if(!strcmp(nvram_safe_get("wl_macmode"),"allow"))	//need to do deauthenticate 
					match = 1;
			}

			if(match == 1)
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s deauthenticate %s",nvram_safe_get("wl0_ifname"),wlmac[i].mac);
				wl_exec_cmd(cmd);
			}
		}	
		if(wlmac)free(wlmac);
		wlmac=NULL;
#endif
		sleep(1);	
	
		//Jemmy add for guest network 2009.10.8 		
#ifdef GUEST_NETWORK_SUPPORT
 		if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
	   	   !strcmp(nvram_safe_get("wk_mode"), "gateway"))
		{
			/* set the maclist in 2.4 Band*/
			if(!strcmp(maclist,"\0"))
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl0.1_ifname"));
			}
			else
			{
				/* first clean the mac list */
				snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl0.1_ifname"));
				wl_exec_cmd(cmd);
	
				/*set the new maclist*/
				snprintf(cmd,sizeof(cmd),"wl -i %s mac %s",nvram_safe_get("wl0.1_ifname"),maclist);
			}
			wl_exec_cmd(cmd);
	
			/* set the mac mode in 2.4G */
			memset(cmd,0,sizeof(cmd));
			if (!strcmp(nvram_safe_get("wl_macmode"),"disabled"))
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s macmode 0",nvram_safe_get("wl0.1_ifname"));
			}
			else if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s macmode 1",nvram_safe_get("wl0.1_ifname"));
			}
			else
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s macmode 2",nvram_safe_get("wl0.1_ifname"));
			}
			wl_exec_cmd(cmd);
		
			wlmac = get_wl_band_assoc_mac(&count_wl,"wl0.1");
			for(i=0; i<count_wl;i++)
			{
				char var[18]={},*next=NULL;		
				int match = 0,in_list = 0;
				char list_tmp[1024];
				memset(list_tmp,0,sizeof(list_tmp));
				strncpy(list_tmp,maclist,sizeof(maclist));

				// check whether the mac addr is in the maclist
				foreach(var,list_tmp,next)
				{
					if(!strcasecmp(var,wlmac[i].mac))
					{
						in_list = 1;
						break;
					}
				}

				/* if it is in the maclist , judge the macmode*/
				if(in_list == 1)
				{
					if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))	//need to do deauthenticate
						match = 1;
				}
				else
				{
					if(!strcmp(nvram_safe_get("wl_macmode"),"allow"))	//need to do deauthenticate 
						match = 1;
				}

				if(match == 1)
				{
					snprintf(cmd,sizeof(cmd),"wl -i %s deauthenticate %s",nvram_safe_get("wl0.1_ifname"),wlmac[i].mac);
					wl_exec_cmd(cmd);
				}
			}	
			if(wlmac)free(wlmac);
			wlmac=NULL;
			sleep(1);
		}
#endif
	}
#ifdef SIMUL_DUAL_BAND_SUPPORT
	if(nvram_invmatch("wl1_net_mode","disabled"))
	{
		/* set the maclist in 5g Band*/
		memset(cmd,0,sizeof(cmd));
		if(!strcmp(maclist,"\0"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl1_ifname"));
		}
		else
		{
			/* first clean the mac list */
			snprintf(cmd,sizeof(cmd),"wl -i %s mac none",nvram_safe_get("wl1_ifname"));
			wl_exec_cmd(cmd);
	
			/*set the new maclist*/
			snprintf(cmd,sizeof(cmd),"wl -i %s mac %s",nvram_safe_get("wl1_ifname"),maclist);
		}
		wl_exec_cmd(cmd);
	
		/* set the mac mode in 5G */
		memset(cmd,0,sizeof(cmd));
		if (!strcmp(nvram_safe_get("wl_macmode"),"disabled"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 0",nvram_safe_get("wl1_ifname"));
		}
		else if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 1",nvram_safe_get("wl1_ifname"));
		}
		else
		{
			snprintf(cmd,sizeof(cmd),"wl -i %s macmode 2",nvram_safe_get("wl1_ifname"));
		}
		wl_exec_cmd(cmd);
		
#if 0
		/*solution 1 : reset ssid*/
		/* reset the ssid to make the setting effective*/
		memset(cmd,0,sizeof(cmd));
		snprintf(cmd,sizeof(cmd),"wl -i %s ssid %s",nvram_safe_get("wl1_ifname"),nvram_safe_get("wl1_ssid"));
		wl_exec_cmd(cmd);
#else
		/* solution 2 : deauthenticate command */
		wlmac = get_wl_band_assoc_mac(&count_wl,"wl1");
		for(i=0; i<count_wl;i++)
		{
			char var[18]={},*next=NULL;		
			int match = 0,in_list = 0;
			char list_tmp[1024];
			memset(list_tmp,0,sizeof(list_tmp));
			strncpy(list_tmp,maclist,sizeof(maclist));

			// check whether the mac addr is in the maclist
			foreach(var,list_tmp,next)
			{
				if(!strcasecmp(var,wlmac[i].mac))
				{
					in_list = 1;
					break;
				}
			}

			/* if it is in the maclist , judge the macmode*/
			if(in_list == 1)
			{
				if(!strcmp(nvram_safe_get("wl_macmode"),"deny"))	//need to do deauthenticate
					match = 1;
			}
			else
			{
				if(!strcmp(nvram_safe_get("wl_macmode"),"allow"))	//need to do deauthenticate 
					match = 1;
			}

			if(match == 1)
			{
				snprintf(cmd,sizeof(cmd),"wl -i %s deauthenticate %s",nvram_safe_get("wl1_ifname"),wlmac[i].mac);
				wl_exec_cmd(cmd);
			}
		}	
		if(wlmac)free(wlmac);
#endif
	}	
#endif
}
//end by michael

//Jemmy add for speed up restarting wireless 2008.5.14
void start_wireless(void)
{
#ifdef __CONFIG_WSCCMD__ //Add by crazy 20080520: Reset the timer of STA PIN mode
	nvram_set("wsc_sta_pin_timer", "0");
#endif

	if(nvram_invmatch("wl0_net_mode", "disabled"))
	{
		ifconfig("eth1", IFUP, NULL, NULL);
		eval("wlconf", "eth1", "up");
	}
#ifdef SIMUL_DUAL_BAND_SUPPORT
	if(nvram_invmatch("wl1_net_mode", "disabled"))
	{
		ifconfig("eth2", IFUP, NULL, NULL);	
		eval("wlconf", "eth2", "up");
	}	
#endif
	if(check_hw_type()==BCM4718_BCM53115_CHIP || check_hw_type()==BCM47186_BCM53125_CHIP){
		char cmd[32];
		if(nvram_match("wl0_gmode", "-1"))
		{
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x2 0x0", nvram_safe_get("wl0_ifname"));
			wl_exec_cmd(cmd);
		}else
		{
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x2 0x2", nvram_safe_get("wl0_ifname"));
			wl_exec_cmd(cmd);
		}

#ifdef SIMUL_DUAL_BAND_SUPPORT
		if(nvram_match("wl1_gmode", "-1"))
		{
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x4 0x0", nvram_safe_get("wl1_ifname"));
			wl_exec_cmd(cmd);
		}else{
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x4 0x4", nvram_safe_get("wl1_ifname"));
			wl_exec_cmd(cmd);
		}
#endif
	}else{
#if 0
		if(nvram_match("wl0_gmode", "-1")
#ifdef SIMUL_DUAL_BAND_SUPPORT
			&& nvram_match("wl1_gmode", "-1")
#endif
		)
		{
			char cmd[32];
			cprintf("both wireless band is disabled, off led!\n");
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x2 0x2", nvram_safe_get("wl0_ifname"));
			wl_exec_cmd(cmd);
#ifdef SIMUL_DUAL_BAND_SUPPORT
			snprintf(cmd, sizeof(cmd), "wl -i %s gpioout 0x4 0x4", nvram_safe_get("wl1_ifname"));
			wl_exec_cmd(cmd);
#endif
		}
#else
		wl_led_control();
#endif
	}

	//Jemmy add for turn on/off wireless security LED 2009.12.2
	/* Turn on the Security LED when Wireless Security is enabled */
	if(check_hw_type() == BCM4704_BCM5325F_EWC_CHIP || check_hw_type() == BCM4705_BCM5397_EWC_CHIP || check_hw_type() == BCM4718_BCM53115_CHIP|| check_hw_type() == BCM4717_BCM53115S_CHIP || check_hw_type() == BCM47186_BCM53125_CHIP) {
#ifdef SIMUL_DUAL_BAND_SUPPORT
		if((nvram_match("security_mode_0", "disabled") || nvram_match("security_mode_1", "disabled")) || (nvram_match("wl0_net_mode","disabled") || nvram_match("wl1_net_mode","disabled")))
		{
#else
		if(nvram_match("security_mode_0", "disabled") || nvram_match("wl0_net_mode", "disabled"))
		{
#endif
			diag_led(SES_LED2,STOP_LED);
		}
		else{
			diag_led(SES_LED2,START_LED);
		}
	}

#if 0
        char cValue[10]="";
        strcpy(cValue,nvram_safe_get("wl1_txpwr"));
        if(strlen(cValue)>0 && atoi(cValue)>0)
        {
                char cmd[32];
                sprintf(cmd,"wl -i eth1 txpwr1 -q %s",cValue);
                wl_exec_cmd(cmd);
        }
        strcpy(cValue,nvram_safe_get("wl0_txpwr"));
        if(strlen(cValue)>0 && atoi(cValue)>0)
        {
                char cmd[32];
                sprintf(cmd,"wl -i eth2 txpwr1 -q %s",cValue);
                wl_exec_cmd(cmd);
        }
#endif
	start_firewall();	
#ifdef __CONFIG_WSCCMD__
	start_wsc(); //Add by crazy 20080428: To start wsccmd must be earlier than to start nas.
#endif
	//Jemmy port NEW WPS from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
	start_nas("lan");
#else
	start_eapd();
	start_nas();
#endif
#ifdef __CONFIG_WPS__
	start_wps();
#endif
#ifdef WIRELESS_WARNING_PAGE_SUPPORT
	start_wl_warning_httpd();
	clear_wl_warning_rule();
#endif
}
void stop_wireless(void)
{
#ifdef __CONFIG_WSCCMD__
	stop_wsc(); //Add by crazy 20080428: To start wsccmd must be earlier than to start nas.
#endif
	//Jemmy port NEW WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	stop_wps(); //Add by crazy 20080428: To start wsccmd must be earlier than to start nas.
#endif
	stop_nas();

#ifdef __CONFIG_WPS__
	stop_eapd();
#endif
	stop_firewall();
	eval("wlconf", "eth1", "down");	
	ifconfig("eth1", 0, NULL, NULL);
#ifdef SIMUL_DUAL_BAND_SUPPORT
	eval("wlconf", "eth2", "down");	
	ifconfig("eth2", 0, NULL, NULL);
#endif
#ifdef WIRELESS_WARNING_PAGE_SUPPORT
	stop_wl_warning_httpd();
#endif
}
//Jemmy end;

#ifdef WAN_DETECT_SUPPORT
//add by michael to change the procedure of wan_auto_detect at 20091008
int
start_monitor_cable(void)
{
	eval("/sbin/monitor_cable");
}

int
stop_monitor_cable(void)
{
	eval("killall","monitor_cable");
}

int
start_wan_auto_detect(void)
{
	eval("/sbin/wan_auto_detect");
}

int
stop_wan_auto_detect(void)
{
	eval("killall","wan_auto_detect");
}
//end by michael
#endif

void set_dhcp_statics_to_arp()
{
        char *wordlist = nvram_safe_get("dhcp_statics");
        char *tmpStart = NULL, *tmpEnd = NULL;
        int iLoop,iLen;
        char cBuffer[128];
        char ip[4];
        char cCmd[64];
        char mac[18];
        char* tmp;
        printf("set_dhcp_statics_to_arp\n");
        eval("arp","-c");
        iLen = strlen(wordlist);
        tmpStart=wordlist;
        for(iLoop=0;iLoop<iLen;)
        {
                if(*tmpStart==' ')
                {  
                        iLoop++;
                        tmpStart++;
                }
                tmpEnd = strchr(tmpStart, ';');
                if(tmpEnd)
                {
                        iLoop+=tmpEnd-tmpStart+1;
                        //*tmpEnd=0;
                        memset(cBuffer,0,sizeof(cBuffer));
                        strncpy(cBuffer,tmpStart,tmpEnd-tmpStart);
                        printf("tmpStart(%s)\n",cBuffer);
                        //get_single_ip(nvram_safe_get("lan_ipaddr")
                        memset(mac,0,sizeof(mac));
                        strncpy(mac,cBuffer,17);
                        strncpy(ip,cBuffer+18,3);
                        tmp=strchr(ip,' ');
                        if(tmp)
                        {
                                *tmp=0;
                        }
                        sprintf(cCmd,"%d.%d.%d.%s",get_single_ip(nvram_safe_get("lan_ipaddr"),0),
                        get_single_ip(nvram_safe_get("lan_ipaddr"),1),
                        get_single_ip(nvram_safe_get("lan_ipaddr"),2),
                        ip);
                        eval("arp","-s",cCmd,mac);
                        tmpStart=wordlist+iLoop;
                }
                else
                {
                        memset(mac,0,sizeof(mac));
                        strncpy(mac,tmpStart,17);
                        strncpy(ip,tmpStart+18,3);
                        tmp=strchr(ip,' ');
                        if(tmp)
                        {
                                *tmp=0;
                        }
                        sprintf(cCmd,"%d.%d.%d.%s",get_single_ip(nvram_safe_get("lan_ipaddr"),0),
                        get_single_ip(nvram_safe_get("lan_ipaddr"),1),
                        get_single_ip(nvram_safe_get("lan_ipaddr"),2),
                        ip);
                        eval("arp","-s",cCmd,mac);
                        printf("tmpStart(%s)\n",tmpStart);
                        break;
                }
        }
}

void flush_kernel_conntrack(void)
{
	//tlhhh. Notify kernel to flush all MAC entries
	system("echo \"=|\" > /proc/unblock_proc");
}

void
start_nlinkd(void)
{
	system("nlinkd &");

	//added by tlhhh. Notify kernel enable hnd for non-HTTP traffic.
	if ( nvram_match("tmsss_enabled", "1") )
		system( "echo \"1\" > /proc/hnd_proc" );

	return ;
}

int
stop_nlinkd(void)
{
	int ret = 0;

	ret = eval("killall", "nlinkd");
	sleep(3);
	
	ret = eval("killall", "-9", "nlinkd");
	unlink("/var/run/nlinkd.pid");
	
	if(nvram_match("unblock_reset", "1"))
	{
		unlink("/tmp/unblock.list");
		//tlhhh. Notify kernel to flush all MAC entries
		flush_kernel_conntrack();
	}

	//added by tlhhh. Notify kernel disable hnd for non-HTTP traffic.
	system( "echo \"0\" > /proc/hnd_proc" );

	dprintf("done\n");
	return ret ;

}

int
start_services(void)
{
	start_syslog();
#ifdef UTELNETD_SUPPORT
	start_telnet(); //by david@ 2008-05-13, move here to speed up mfg telnet startup.
#endif

#if 0
	//sync the patch from TPE team to fix the WiFi 20/40M coexistence issue at 20100402
	{
		char cmd[32];
		snprintf(cmd,sizeof(cmd),"wl -i %s obss_coex 1",nvram_safe_get("wl0_ifname"));
		wl_exec_cmd(cmd);
//#ifdef SIMUL_DUAL_BAND_SUPPORT
//		snprintf(cmd,sizeof(cmd),"wl -i %s obss_coex 1",nvram_safe_get("wl1_ifname"));
//		wl_exec_cmd(cmd);
//#endif
	}
#endif

	start_tftpd();
	start_cron();
	start_httpd();
	start_dns();
#ifdef CES_MDNS_SUPPORT
	start_cesmdns();
#endif
#ifdef LAN_AUTO_DHCP_SUPPORT
	start_auto_dhcp_detect();
#else
	start_dhcpd();
#endif	
	//Jemmy move to here for wps 2009.5.19
	start_upnp();

#ifdef __CONFIG_WSCCMD__
	start_wsc(); //Add by crazy 20080428: To start wsccmd must be earlier than to start nas.
#endif
	//Jemmy port NEW WPS from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
	start_nas("lan");
#else
	start_eapd();
	start_nas();
#endif
#ifdef __CONFIG_WPS__
	start_wps();
#endif

	//John zhu@2008.03.31 committed
#if defined( ZEBRA_SUPPORT ) || defined( ROUTED_SUPPORT )
	start_zebra();
#endif /*ZEBRA_SUPPORT || ROUTED_SUPPORT*/

	//Fixed 05/09/2007
#ifdef RIPD_SUPPORT
	start_ripd();
#endif

#ifdef SNMP_SUPPORT
 	start_snmp();
#endif	
#ifdef EOU_SUPPORT
	start_eou();
#endif
#ifdef PPPOE_SERVER_SUPPORT
	start_pppoe_server();
#endif
#ifdef PPPOE_RELAY_SUPPORT
	start_pppoe_relay();
#endif
#ifdef STORAGE_SUPPORT
	start_nfs();
//add to support netbois to access GUI at 20090605
	start_nmbd();
	//Disable by YY, we only need to be up when USB is pluged.
#if 0
	if(strcmp(nvram_safe_get("partition_name_0"), ""))
	{
		printf("Disk connected, start samba\n");
		start_cifs();
	}
	else
	{
		printf("No disk, do not start samba.\n");	
	}
#else
	start_cifs();
#endif
#endif
#ifdef MEDIA_SERVER_SUPPORT
	stop_media_server();
	start_media_server();
#endif
#ifdef FTP_SUPPORT
//michael add stop_ftp to fix the double mount ftp bug at 20081205
	stop_ftp();
	if(strcmp(nvram_safe_get("partition_name_0"), ""))
	{
		printf("Disk connected, start ftp server\n");
		start_ftp();
	}
#endif
	//added by tlhhh 2010-10-28
	start_nlinkd();
#ifdef __CONFIG_SES__

	if(nvram_match("ses_fsm_current_states", "06:03") || nvram_match("ses_fsm_current_states", "06:01")) {	// SES2 completed
		cprintf("%d: Waiting for SES2 to finish all session .....\n", time(NULL));
		start_ses();
		//start_ses_cl();
		int i;
		for(i=0;i<8;i++) sleep(1);
		cprintf("%d: Continue to execute other services .....\n", time(NULL));
	}
	else
		start_ses();
		//start_ses_cl();
#endif /* __CONFIG_SES__ */

#ifdef SYMC_OUTBREAK_SUPPORT
	start_outbreak();
#endif

#if 0	//Lai 2010.04.26 removed it.
#ifdef WSC_SUPPORT 
#ifdef SES_SUPPORT
	//AP must keep its wsc_ap_role(withReg) when SES do self-config and ready to restart all services
	if(nvram_match("ses_config","0"))
#endif

	nvram_set("wsc_ap_role","proxy");
	nvram_set("wsc_count2","0");
#ifndef __CONFIG_WSCCMD__
	start_wsc();
#endif
#ifdef SES_SUPPORT
	nvram_set("ses_config","0");
#endif
#endif
#endif
#ifdef LLTD_SUPPORT
	start_lltd();
#endif

/*added for EGHN*/
#ifdef EGHN
	if(!strcmp(nvram_safe_get("eghn_enabled"), "1"))
	{
		eghn_init();
		start_bonjour();
	}
#endif
/*EGHN*/

//wuzh add 2008-5-5
#ifdef __CONFIG_IPV6__
/* marcel 2010.10.15, use ISC's dhcp instead of dhcp6 */
//	#ifdef __CONFIG_DHCPV6S__
//  	start_dhcp6s();
//	#endif /* __CONFIG_DHCPV6S__ */

	/***************
	*	Restart radvd:
	***************/
	{
		char tmp[64];
        	snprintf(tmp, sizeof(tmp), "-%d", SIGHUP);
		eval("killall", tmp, "radvd");
	}
#endif
#ifdef WAN_DETECT_SUPPORT
	if(nvram_match("wan_proto","dhcp"))
		start_monitor_cable();
#endif
	set_dhcp_statics_to_arp();
	dprintf("done\n");
	return 0;
}

int
stop_services(void)
{
#ifdef SNMP_SUPPORT
 	stop_snmp();
#endif	
#ifdef __CONFIG_SES__
	stop_ses();
	//stop_ses_cl();
#endif /* __CONFIG_SES__ */
	//Jemmy port New WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	stop_wps();
#endif

	stop_nas();
	//Jemmy port New WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	stop_eapd();
#endif

	//Jemmy Fixed 2009.4.27
	stop_upnp();

	stop_dhcpd();
	//stop_dns();
#ifdef CES_MDNS_SUPPORT
	stop_cesmdns();
#endif
	stop_dns_clear_resolv();
	//add by michael to fix the UI can't be show after do save in index.asp at 20091120	
	if(nvram_match("hnap_flag","1"))
	{
		stop_httpd();
		nvram_set("hnap_flag","0");
	}
	stop_cron();
	stop_tftpd();
	stop_syslog();
#ifdef ZEBRA_SUPPORT
	stop_zebra();
#endif

	//Fixed 05/09/2007
#ifdef RIPD_SUPPORT
	stop_ripd();
#endif

#ifdef EOU_SUPPORT
	stop_eou();
#endif
#ifdef PPPOE_SERVER_SUPPORT
	stop_pppoe_server();
#endif
#ifdef PPPOE_RELAY_SUPPORT
	stop_pppoe_relay();
#endif
#ifdef FTP_SUPPORT
	stop_ftp();
#endif
#ifdef MEDIA_SERVER_SUPPORT
	stop_media_server();
#endif
#ifdef STORAGE_SUPPORT
	stop_cifs();
	stop_nfs();
	//Jemmy add from WRT320N 2009.9.24
#ifdef GUEST_NETWORK_SUPPORT
	stop_nmbd();
#endif

#endif

	stop_nlinkd();

#ifdef SYMC_OUTBREAK_SUPPORT
	stop_outbreak();
#endif
#ifdef LLTD_SUPPORT
	stop_lltd();
#endif
#ifdef __CONFIG_WSCCMD__
	stop_wsc();
#endif
#ifdef UTELNETD_SUPPORT
	stop_telnet();
#endif

/*added for EGHN*/
#ifdef EGHN
	eghn_exit();
	stop_bonjour();
#endif
/*EGHN*/

//wuzh add 2008-5-5
//#ifdef __CONFIG_DHCPV6S__
//	stop_dhcp6s();
//#endif /* __CONFIG_DHCPV6S__ */

#ifdef WAN_DETECT_SUPPORT
	stop_monitor_cable();
#endif
	dprintf("done\n");
	return 0;
}

/////////////////////////////////////////////////////
int
start_resetbutton(void)
{
	int ret = 0;

	ret = eval("resetbutton");

	dprintf("done\n");
	return ret;
}

int 
stop_resetbutton(void)
{
	int ret = 0;

	ret = eval("killall","-9","resetbutton");

	dprintf("done\n");
	return ret ;
}

int
start_iptqueue(void)
{
	int ret = 0;

	ret = eval("iptqueue");

	dprintf("done\n");
	return ret;
}

int 
stop_iptqueue(void)
{
	int ret = 0;

	ret = eval("killall","-9","iptqueue");

	dprintf("done\n");
	return ret ;
}

int
start_tftpd(void)
{
#ifdef VERIZON_WAN_SUPPORT
	if(nvram_invmatch("enable_tftpd","1"))
		return 0;
#endif
	int ret = 0;
	pid_t pid;
	char *tftpd_argv[] = { "tftpd",
				"-s","/tmp",	// chroot to /tmp
				"-c",		// allow new files to be created 
				"-l",		// standalone
				"-P", CODE_PATTERN,	// code pattern
			      NULL
	};

	ret = _eval(tftpd_argv, NULL, 0, &pid); 

	dprintf("done\n");
	return ret;
}

int 
stop_tftpd(void)
{
	int ret;

	ret = eval("killall","-9","tftpd");

	dprintf("done\n");
	return ret ;
}

int
start_cron(void)
{
	int ret = 0;
	struct stat buf;

#ifdef THROUGHPUT_TEST_SUPPORT
	if(nvram_match("throughput_test","1"))
		return 0;
#endif
	/* Create cron's database directory */
	if( stat("/var/spool", &buf) != 0 ){
		mkdir("/var/spool", 0700);
		mkdir("/var/spool/cron", 0700);
	}
	mkdir("/tmp/cron.d", 0700);
	
//modified by michael to change 2 to 5 minute at 20080502
//	buf_to_file("/tmp/cron.d/check_ps", "*/2 * * * * root /sbin/check_ps\n");
	buf_to_file("/tmp/cron.d/check_ps", "*/5 * * * * root /sbin/check_ps\n");
#ifdef SYSLOG_SUPPORT
//	buf_to_file("/tmp/cron.d/rotatelog", "*/2 * * * * root /usr/sbin/rotatelog.sh 1000\n");
	buf_to_file("/tmp/cron.d/rotatelog", "*/5 * * * * root /usr/sbin/rotatelog.sh 1000\n");
//end by michael
#endif

	//Jemmy port guest network function from WRT320N 2009.9.18
//#ifdef GUEST_NETWORK_SUPPORT
	//if(nvram_match("gn_enable", "1") &&  nvram_invmatch("wl0_gmode", "-1") && nvram_invmatch("wk_mode", "router"))
//	buf_to_file("/tmp/cron.d/check_gn", "*/1 * * * * root /sbin/check_gn\n");
//#endif
	ret = eval("cron"); 
	
		
	dprintf("done\n");
	return ret;
}

int 
stop_cron(void)
{
	int ret = 0;

	ret = eval("killall","-9","cron");

	dprintf("done\n");
	return ret ;
}
/*add  by John@20080331*/
#ifdef ROUTED_SUPPORT
int
start_routed(void)
{
#define LAN_SIDE 1
#define WAN_SIDE 2
#define BOTH_SIDE 3
	//FILE *fp;
	char *lr, *lt, *wr, *wt;
	char ift[5];
	int side, ret;

	lt = nvram_safe_get("dr_lan_tx");
	lr = nvram_safe_get("dr_lan_rx");
	wt = nvram_safe_get("dr_wan_tx");
	wr = nvram_safe_get("dr_wan_rx");

	if(!strcmp(lt, "0") && !strcmp(lr, "0") && !strcmp(wt, "0") && !strcmp(wr, "0"))
	{
		printf("zebra disabled.\n");
		return 0;
	}
#ifdef UNNUMBERIP_SUPPORT
	if(nvram_invmatch("wan_proto", "unnumberip"))
	{
		printf("zebra disabled.\n");
		return 0;
	}
#endif

	if(strcmp(lt, "0") && strcmp(lr, "0") && strcmp(wt, "0") && strcmp(wr, "0"))
	{
		side = BOTH_SIDE;
	}
	else if(strcmp(lt, "0") && strcmp(lr, "0"))
	{
		side = LAN_SIDE;
	}
	else
	{
		side = WAN_SIDE;
	}

	sprintf(ift, "%d", side);
	ret = eval("routed",  "-s", "-g", "--Side", ift);
#ifdef FIXED_RESTART
	check_lock(1, "/tmp/.routed_started");
	//nvram_set("routed_started", "1");
#endif
	dprintf("done\n");

	return ret;
}
                                                                                                               
int stop_routed(void)
{
	int ret;
#ifdef FIXED_RESTART
	if(!check_lock(0, "/tmp/.routed_started"))
	//if(strcmp(nvram_safe_get("routed_started"), "1"))
		return 0;
	//nvram_set("routed_started", "0");
#endif

	ret = eval("killall", "routed");
	//Send SIGTERM to let routed clear dynamic route
	//ret = eval("killall", "-SIGTERM", "routed");
	//ret = kill_ps("routed", SIGTERM, 0);

	dprintf("done\n");

	return ret;
}
                                                                                                               
#else

/* Written by Sparq in 2002/07/16 */
int
start_zebra(void)
{
	FILE *fp;
	int  ret1, ret2;

	char *lt = nvram_safe_get("dr_lan_tx");
	char *lr = nvram_safe_get("dr_lan_rx");
	char *wt = nvram_safe_get("dr_wan_tx");
	char *wr = nvram_safe_get("dr_wan_rx");
	char *lf = nvram_safe_get("lan_ifname");
	char *wf = nvram_safe_get("wan_ifname");

//	printf("Start zebra\n");
	if ( !strcmp(lt, "0") && !strcmp(lr, "0") &&
	     !strcmp(wt, "0") && !strcmp(wr, "0") ){
		printf("zebra disabled.\n");
		return 0;
	}

#if OEM == LINKSYS
	if ( nvram_match("wk_mode", "gateway")
#ifdef UNNUMBERIP_SUPPORT
        && nvram_invmatch("wan_proto", "unnumberip")
#endif
	){
		printf("zebra disabled.\n");
		return 0;
	}
#endif

	/* Write configuration file based on current information */
	if (!(fp = fopen("/tmp/zebra.conf", "w"))) {
		perror("/tmp/zebra.conf");
		return errno;
	}
	fclose(fp);

	if (!(fp = fopen("/tmp/ripd.conf", "w"))) {
		perror("/tmp/ripd.conf");
		return errno;
	}
	fprintf(fp, "router rip\n");
	fprintf(fp, "  network %s\n", lf);
	fprintf(fp, "  network %s\n", wf);
	fprintf(fp, "redistribute connected\n");
	//fprintf(fp, "redistribute kernel\n");
        fprintf(fp, "redistribute kernel\n");//2006.12.19 modify for cdrouter v3.3 item 173(cdrouter_rip_30) bug
	//fprintf(fp, "redistribute static\n");
	
	fprintf(fp, "interface %s\n", lf);
	if( strcmp(lt, "0") != 0 )
		fprintf(fp, "  ip rip send version %s\n", lt);
	if( strcmp(lr, "0") != 0 )
		fprintf(fp, "  ip rip receive version %s\n", lr);
	
	/*Fixed 05/07/2007*/
	fprintf(fp, "interface wan:%s\n", wf);
	
	fprintf(fp, "interface %s\n", wf);
	if( strcmp(wt, "0") != 0 )
		fprintf(fp, "  ip rip send version %s\n", wt);
	if( strcmp(wr, "0") != 0 )
		fprintf(fp, "  ip rip receive version %s\n", wr);

	fprintf(fp, "router rip\n");
	if( strcmp(lt, "0") == 0 )
		fprintf(fp, "  distribute-list private out %s\n",lf);
	if( strcmp(lr, "0") == 0 )
		fprintf(fp, "  distribute-list private in  %s\n",lf);
	if( strcmp(wt, "0") == 0 )
		fprintf(fp, "  distribute-list private out %s\n",wf);
	if( strcmp(wr, "0") == 0 )
		fprintf(fp, "  distribute-list private in  %s\n",wf);
	fprintf(fp, "access-list private deny any\n");

	//fprintf(fp, "debug rip events\n");
	//fprintf(fp, "log file /tmp/ripd.log\n");
	fflush(fp);
	fclose(fp);

	ret1 = eval("zebra", "-d", "-f", "/tmp/zebra.conf");
	ret2 = eval("ripd",  "-d", "-f", "/tmp/ripd.conf");

//	printf("Start RET=%d, %d\n",ret1,ret2);
//	printf("Start zebra done\n");

	dprintf("done\n");
	return ret1 | ret2 ;
//	return 0 ;
}

/* Written by Sparq in 2002/07/16 */
int
stop_zebra(void)
{
	int  ret1, ret2;

//	printf("Stop zebra !\n");

	ret1 = eval("killall", "zebra");
	ret2 = eval("killall", "ripd");

//	printf("Stop RET=%d, %d\n",ret1,ret2);
//	printf("Stop zebra done!\n");

	dprintf("done\n");
	return ret1 | ret2 ;
}
#endif

int
start_syslog(void)
{
	int ret = 0;
	char *loglevel = NULL;

#ifdef SYSLOG_SUPPORT
	char ipaddr[20];
	//add by michael to add the romote log at 2008-3-2
	int enable = atoi(nvram_safe_get("log_enable"));

	if(enable == 0)
		return ret ;	

	sprintf(ipaddr,"%d.%d.%d.%s",get_single_ip(nvram_safe_get("lan_ipaddr"),0),
			get_single_ip(nvram_safe_get("lan_ipaddr"),1),
			get_single_ip(nvram_safe_get("lan_ipaddr"),2),
			nvram_safe_get("log_ipaddr"));
	//end by michael

#ifdef SYS_KLOGD_SUPPORT
	/*John@2010.09.20,adjust the console_loglevel to the level in nvram*/
        if (loglevel = nvram_get("console_loglevel"))
                ret = eval("klogd", "-c", loglevel);
        else
                ret = eval("klogd");
	//ret = eval("klogd");
#endif

	if(nvram_invmatch("log_ipaddr", "0"))
		ret += eval("syslogd","-R", ipaddr);
	else
		ret += eval("syslogd","-m","0","-O", LOG_FILE);

	dprintf("done\n");
#endif
	return ret;
}

int
stop_syslog(void)
{
	int ret;

	ret = eval("killall","klogd");
	ret += eval("killall","syslogd");
	ret += eval("killall","-9","rotatelog.sh");
	ret += eval("killall","-9","sleep");

	dprintf("done\n");
	return ret ;
}


int
start_redial(void)
{
	int ret;
	pid_t pid;
	char *redial_argv[] = { "/tmp/ppp/redial",
				nvram_safe_get("ppp_redialperiod"),
			      NULL
	};

	symlink("/sbin/rc", "/tmp/ppp/redial");

	ret = _eval(redial_argv, NULL, 0, &pid); 

	dprintf("done\n");
	return ret;
}

int 
stop_redial(void)
{
	int ret;

        ret = eval("killall","-9","redial");

	dprintf("done\n");
	return ret ;
}


int
stop_pppoe(void)
{
        int ret;
	int i;

	unlink("/tmp/ppp/link");
        nvram_safe_unset("pppoe_ifname0");
#ifdef MPPPOE_SUPPORT
        unlink("/tmp/ppp/link_1");
        nvram_safe_unset("pppoe_ifname1");
#endif
        ret = eval("killall", "pppoecd");
/*Taide modify to fix CRDC bug IR-B0015758 2010_10_20*=begin */
	for(i = 0;i<3;i++)
		usleep(250000);
/*end by Taide*----------------------------------------------*/
        ret = eval("killall", "-9", "pppoecd");
        ret += eval("killall", "ip-up");
        ret += eval("killall", "ip-down");

        dprintf("done\n");
        return ret ;
}

int
stop_singe_pppoe(int pppoe_num)
{
        int ret;
        char pppoe_pid[15], pppoe_ifname[15];
        char ppp_unlink[2][20]={"/tmp/ppp/link","/tmp/ppp/link_1"};
        char ppp_wan_dns[2][20]={"wan_get_dns","wan_get_dns_1"};
                                                                                                                             
        sprintf(pppoe_pid,"pppoe_pid%d",pppoe_num);
        sprintf(pppoe_ifname,"pppoe_ifname%d",pppoe_num);
        dprintf("start! stop pppoe %d, pid %s \n",pppoe_num,nvram_safe_get(pppoe_pid));
                                                                                                                             
        ret = eval("kill",nvram_safe_get(pppoe_pid));
        unlink(ppp_unlink[pppoe_num]);
        nvram_unset(pppoe_ifname);
                                                                                                                             
        nvram_set(ppp_wan_dns[pppoe_num],"");
        stop_dns_clear_resolv();
                                                                                                                             
        dprintf("done\n");
        return ret ;
}

#ifdef DHCPV6C_SUPPORT
int start_dhcpc(char *wan_or_lan)
{
	char *wan_ifname = NULL;
	char *lan_ifname = NULL;
	FILE *dhclient_fp = NULL;
	char dhcp_argv[256];


	cprintf("tallest:=====( wan_or_lan=%s )=====\n",wan_or_lan);

	if(!strncmp(wan_or_lan,"wan", 3)) {
		wan_ifname = nvram_safe_get("wan_ifname");
	}
	else if(!strncmp(wan_or_lan,"lan", 3)) {
		lan_ifname = nvram_safe_get("lan_ifname");
	}
	else { return 1; }	

	dhclient_fp = fopen("/tmp/dhcpc-wan.conf", "w");
	if (!dhclient_fp)
		return 1;
		
	fprintf(dhclient_fp, "request subnet-mask, routers, domain-name, domain-name-servers;\n");
	fprintf(dhclient_fp, "require subnet-mask, routers, domain-name-servers,\n");
	fprintf(dhclient_fp, "dhcp-lease-time, dhcp-server-identifier;\n");
	fclose(dhclient_fp);
	
	symlink("/sbin/rc", "/tmp/dhcpc");
	
	memset(dhcp_argv, 0, sizeof(dhcp_argv));
	sprintf(dhcp_argv, "/usr/sbin/dhclient -nw -cf %s -sf %s -lf %s -pf %s %s &",
			"/tmp/dhcpc-wan.conf", 
			"/tmp/dhcpc", 
			"/tmp/dhcpc-wan.leases",
			"/var/run/dhcpc-wan.pid", 
			(wan_ifname? wan_ifname : lan_ifname));
	nvram_set("wan_iface", nvram_safe_get("wan_ifname"));
	system(dhcp_argv);

	return 0;
}
#else /*DHCPV6C_SUPPORT*/

#if 1
int start_dhcpc(char *wan_or_lan)
{
	pid_t pid;
	char *hostname;
	char *wan_ifname = "";
        char *lan_ifname = "";
	char dhcp_pid[30];

	cprintf("tallest:=====( wan_or_lan=%s )=====\n",wan_or_lan);

	if(!strncmp(wan_or_lan,"lan", 3))
	{
	cprintf("tallest:=====( wan_or_lan=%s is Lan !!)=====\n",wan_or_lan);
		hostname = nvram_safe_get("lan_hostname");
		lan_ifname = nvram_safe_get("lan_ifname");
		strcpy(dhcp_pid,"/var/run/lan_udhcpc.pid");
	}
	else
	{
	cprintf("tallest:=====( wan_or_lan=%s is wan !!)=====\n",wan_or_lan);
		hostname = nvram_safe_get("wan_hostname");
		wan_ifname = nvram_safe_get("wan_ifname");
		lan_ifname = nvram_safe_get("lan_ifname");
		strcpy(dhcp_pid,"/var/run/wan_udhcpc.pid");
	}
	
	char *dhcp_argv[] = { "udhcpc",
		"-i", wan_ifname,
		"-l", lan_ifname,
		"-p", dhcp_pid,
		"-s", "/tmp/udhcpc",
		hostname && *hostname ? "-H" : NULL,
		hostname && *hostname ? hostname : NULL,
		NULL
	};


	symlink("/sbin/rc", "/tmp/udhcpc");

	if(!strncmp(wan_or_lan,"wan", 3))
	{
#ifdef L2TP_SUPPORT
		if(strcmp(nvram_safe_get("wan_proto"), "l2tp") != 0)
#endif
		nvram_set("wan_iface", nvram_safe_get("wan_ifname"));

		nvram_set("wan_get_dns","");
	}

	_eval(dhcp_argv, NULL, 0, &pid);

	return 0;
}
#else
int start_dhcpc(void)
{
	pid_t pid;
	char *wan_hostname = nvram_safe_get("wan_hostname");
	char *wan_ifname = nvram_safe_get("wan_ifname");
	char *lan_ifname = nvram_safe_get("lan_ifname");
	char *wan_proto = nvram_safe_get("wan_proto");
	char *dhcp_argv[] = { "udhcpc",
		"-i", wan_ifname,
		"-l", lan_ifname,
		"-p", "/var/run/udhcpc.pid",
		"-s", "/tmp/udhcpc",
		wan_hostname && *wan_hostname ? "-H" : NULL,
		wan_hostname && *wan_hostname ? wan_hostname : NULL,
		NULL
	};


	symlink("/sbin/rc", "/tmp/udhcpc");

#ifdef L2TP_SUPPORT
	if(strcmp(wan_proto, "l2tp") != 0)
#endif
	nvram_set("wan_iface", nvram_safe_get("wan_ifname"));

	nvram_set("wan_get_dns","");

	_eval(dhcp_argv, NULL, 0, &pid);

	return 0;
}
#endif /*0*/
#endif /*DHCPV6C_SUPPORT*/

#ifdef DHCPV6C_SUPPORT
int stop_dhcpc(void)
{
  char cmd[120] = "";
  FILE *fp;

  cprintf("stop_dhcpc \n");

  fp = fopen("/var/run/dhcpc-wan.pid", "r");
  if (fp == NULL)
          return 0;
  
  //command option "-r" : release ip
  sprintf(cmd, "/usr/sbin/dhclient -r -sf %s -lf %s -pf %s %s",
	"/tmp/dhcpc", 
	"/tmp/dhcpc-wan.leases", 
	"/var/run/dhcpc-wan.pid", 
	nvram_safe_get("wan_ifname"));
  system(cmd);
  close(fp);
  remove("/tmp/dhcpc-wan.leases");
  remove("/var/run/dhcpc-wan.pid");

  return eval("killall", "dhclient");
}

#else /*DHCPV6C_SUPPORT*/
int
stop_dhcpc(void)
{
	int ret = 0;
	
#ifdef L2TP_SUPPORT
	if (nvram_match("wan_proto", "l2tp")) {
		char sigusr[] = "-XX";
		sprintf(sigusr, "-%d", SIGUSR2);
		//sleep(1);
		eval("killall", sigusr, "udhcpc");
		/*Taide 2010_9_23 	RDQA bug 0024857********   begin*/		
		   int i ;
                  for(i = 0;i < 5 ; i++)
                 {                	  
	           	usleep(200000);			   
                 }
		/*Taide********************************end*/	
	}
//	else //if without mark this line, can't kill udhcpc,only doing release action
#endif
		ret += eval("killall","udhcpc");

	dprintf("done\n");
	return ret ;
}
#endif /*DHCPV6C_SUPPORT*/

#ifdef WAN_AUTO_DETECT_SUPPORT
int start_auto(void)
{
	int i;

	nvram_set("wan_proto","auto_pppoe");

	nvram_set("wan_mtu",(get_mtu("auto_pppoe"))->max);
	start_pppoe(PPPOE0);
	for(i=0; i<5; i++)
	{
		sleep(1);
	}

	if(check_wan_link(0))
	{
		cprintf("tallest:=====( pppoe connected!! )=====\n");
		return 1;
	}
	else
	{
		cprintf("tallest:=====( pppoe connecting faile!! )=====\n");

		unlink("/tmp/ppp/link");
		nvram_safe_unset("pppoe_ifname0");
	        eval("killall","-9","pppoecd");
	        eval("killall", "ip-up");
	        eval("killall", "ip-down");

		nvram_set("wan_proto","");
	}

	nvram_set("wan_proto","auto_dhcp");
	start_dhcpc("wan");
	for(i=0; i<5; i++)
	{
		sleep(1);
	}

	if(check_wan_link(0))
	{
		cprintf("tallest:=====( dhcp connected!! )=====\n");
		return 1;
	}
	else
	{
		cprintf("tallest:=====( dhcp connecting faile!! )=====\n");
		stop_dhcpc();
		nvram_set("wan_proto","");
	}
	
	nvram_set("wan_proto","auto");
	start_wan_done(nvram_safe_get("wan_ifname"));
	return 0;
}
#endif

//Jemmy add for porting New WPS from BSP.5.20.20 2008.11.17
#if defined(__CONFIG_WSCCMD__) || defined(__CONFIG_WPS__)
extern void RAND_bytes(unsigned char *buf, int num);
//#define RANDOM_SSID_LENGTH  6
#define RANDOM_SSID_LENGTH  4
static void generate_ssidAndKey()
{
	char tmp[100], prefix[] = "wlXXXXXXXXXX_";
	char random_ssid[33] = {0};
	unsigned char random_key[65] = {0};
	int i = 0;
	unsigned short key_length;
	int prefix_ssid_len = 0;
	
	RAND_bytes((unsigned char *)&key_length, sizeof(key_length));
	key_length = ((((long)key_length + 56791 ) * 13579 ) % 8) + 8;
								 
	sprintf(prefix,"wl%s_", "0");
	
	/* random a ssid */
#if 0
	sprintf(random_ssid, "Broadcom_");
	
	while (i < RANDOM_SSID_LENGTH) {
		RAND_bytes(&random_ssid[9 + i], 1);
		if ((islower(random_ssid[9 + i]) || isdigit(random_ssid[9 + i])) && (random_ssid[9 + i] < 0x7f)) {
			i++;
		}
	}
#else
	sprintf(random_ssid, "Cisco_WPS_");	//for CES Router
	//sprintf(random_ssid, "linksys_WPS_");
	prefix_ssid_len = strlen(random_ssid);

#ifdef SIMUL_DUAL_BAND_SUPPORT
	while (i < RANDOM_SSID_LENGTH) 
	{
		RAND_bytes(&random_ssid[prefix_ssid_len + i], 1);
		if ((islower(random_ssid[prefix_ssid_len + i]) || isdigit(random_ssid[prefix_ssid_len + i])) 
				&& (random_ssid[prefix_ssid_len + i] < 0x7f)) 
		{
			i++;
		}
	}

	nvram_set("wl1_ssid", random_ssid);

	i = 0;
#endif

	while (i < RANDOM_SSID_LENGTH) 
	{
		RAND_bytes(&random_ssid[prefix_ssid_len + i], 1);
		if ((islower(random_ssid[prefix_ssid_len + i]) || isdigit(random_ssid[prefix_ssid_len + i])) 
				&& (random_ssid[prefix_ssid_len + i] < 0x7f)) 
		{
			i++;
		}
	}
#endif
	
	nvram_set(strcat_r(prefix, "ssid", tmp), random_ssid);
	i = 0;
	
	/* random a key */
	while (i < key_length) {
		RAND_bytes(&random_key[i], 1);
		if ((islower(random_key[i]) || isdigit(random_key[i])) && (random_key[i] < 0x7f)) {
			i++;
		}
	}
	random_key[key_length] = 0;
	
	nvram_set(strcat_r(prefix, "wpa_psk", tmp), random_key);
	
	/* Set default config to wps-psk, tkip */
	nvram_set(strcat_r(prefix, "akm", tmp), "psk psk2");
	nvram_set(strcat_r(prefix, "auth", tmp), "0");
	nvram_set(strcat_r(prefix, "wep", tmp), "disabled");
	nvram_set(strcat_r(prefix, "crypto", tmp), "tkip+aes");
	//Jemmy add for porting New WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	nvram_set(strcat_r(prefix, "wps_config_state", tmp), "1");
	nvram_set(strcat_r(prefix, "wps_reg", tmp), "enabled");
#else
	nvram_set(strcat_r(prefix, "wsc_reg", tmp), "enabled");
#endif

	//for web page
	nvram_set(strcat_r(prefix, "security_mode", tmp), "wpa2_mixed");
	nvram_set("security_mode_0", "psk psk2");

#ifdef SIMUL_DUAL_BAND_SUPPORT
	nvram_set("wl1_wpa_psk", random_key);

	/* Set default config to wps-psk, tkip */
	nvram_set("wl1_akm", "psk psk2");
	nvram_set("wl1_auth", "0");
	nvram_set("wl1_wep", "disabled");
	nvram_set("wl1_crypto", "tkip+aes");
	//Jemmy add for porting New WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	nvram_set("wl1_wps_config_state", "1");
	nvram_set("wl1_wps_reg", "enabled");
#else
	nvram_set("wl1_wsc_reg", "enabled");
#endif
	//Jemmy add for new wireless security web page 2009.9.21
	nvram_set("wl1_security_mode", "wpa2_mixed");
	nvram_set("security_mode_1", "psk psk2");
#endif/*SIMUL_DUAL_BAND_SUPPORT*/

	nvram_set("wl0_akm", "psk psk2");
	nvram_set("wl0_auth", "0");
	nvram_set("wl0_wep", "disabled");
	nvram_set("wl0_crypto", "tkip+aes");
	//Jemmy add for porting New WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WPS__
	nvram_set("wl0_wps_config_state", "1");
	nvram_set("wl0_wps_reg", "enabled");
	nvram_set("wl_wps_config_state", "1");
	nvram_set("wl_wps_reg", "enabled");
#else
	nvram_set("wsc_config_state", "1");
	nvram_set("wl_wsc_reg", "enabled");
#endif

	nvram_commit();

	return;
}
#if 0
static void check_security()
{
	char prefix[] = "wlXXXXXXXXXX_";
	char random_ssid[33] = {0};
	int i = 0;
	int prefix_ssid_len = 0;

	if(nvram_match("wl0_security_mode", "disabled") && nvram_match("wl1_security_mode", "disabled"))
	{
		generate_ssidAndKey();
		return;
	}
	else 
	{
		sprintf(random_ssid, "linksys_WPS_");
		prefix_ssid_len = strlen(random_ssid);
		while (i < RANDOM_SSID_LENGTH) 
		{
			RAND_bytes(&random_ssid[prefix_ssid_len + i], 1);
			if ((islower(random_ssid[prefix_ssid_len + i]) || isdigit(random_ssid[prefix_ssid_len + i])) 
					&& (random_ssid[prefix_ssid_len + i] < 0x7f)) 
			{
				i++;
			}
		}
		if(nvram_match("wl0_security_mode", "disabled"))
		{//Copy security from wl1, but ssid is generated
			nvram_set("wl0_ssid", random_ssid);
			nvram_set("wl0_wpa_psk", nvram_safe_get("wl1_wpa_psk"));
			nvram_set("wl0_akm", nvram_safe_get("wl1_akm"));
			nvram_set("wl0_auth", nvram_safe_get("wl1_auth"));
			nvram_set("wl0_wep", nvram_safe_get("wl1_wep"));
			nvram_set("wl0_wep_bit", nvram_safe_get("wl1_wep_bit"));
			nvram_set("wl0_wep_buf", nvram_safe_get("wl1_wep_buf"));
			nvram_set("wl0_key", nvram_safe_get("wl1_key"));
			nvram_set("wl0_key1", nvram_safe_get("wl1_key1"));
			nvram_set("wl0_key2", nvram_safe_get("wl1_key2"));
			nvram_set("wl0_key3", nvram_safe_get("wl1_key3"));
			nvram_set("wl0_key4", nvram_safe_get("wl1_key4"));
			nvram_set("wl0_crypto", nvram_safe_get("wl1_crypto"));
			nvram_set("wl0_wsc_reg", nvram_safe_get("wl1_wsc_reg"));
			nvram_set("wl0_security_mode", nvram_safe_get("wl1_security_mode"));
			nvram_set("security_mode_0", nvram_safe_get("security_mode_1"));
		}
		else if(nvram_match("wl1_security_mode", "disabled"))
		{//Copy security from wl0, but ssid is generated
			nvram_set("wl1_ssid", random_ssid);
			nvram_set("wl1_wpa_psk", nvram_safe_get("wl0_wpa_psk"));
			nvram_set("wl1_akm", nvram_safe_get("wl0_akm"));
			nvram_set("wl1_auth", nvram_safe_get("wl0_auth"));
			nvram_set("wl1_wep", nvram_safe_get("wl0_wep"));
			nvram_set("wl1_wep_bit", nvram_safe_get("wl0_wep_bit"));
			nvram_set("wl1_wep_buf", nvram_safe_get("wl0_wep_buf"));
			nvram_set("wl1_key", nvram_safe_get("wl0_key"));
			nvram_set("wl1_key1", nvram_safe_get("wl0_key1"));
			nvram_set("wl1_key2", nvram_safe_get("wl0_key2"));
			nvram_set("wl1_key3", nvram_safe_get("wl0_key3"));
			nvram_set("wl1_key4", nvram_safe_get("wl0_key4"));
			nvram_set("wl1_crypto", nvram_safe_get("wl0_crypto"));
			nvram_set("wl1_wsc_reg", nvram_safe_get("wl0_wsc_reg"));
			nvram_set("wl1_security_mode", nvram_safe_get("wl0_security_mode"));
			nvram_set("security_mode_1", nvram_safe_get("security_mode_0"));
		}
	}
}
#endif
#endif

#ifdef GUEST_NETWORK_SUPPORT
int start_gn_services(void)
{ 
	printf("Jemmy start guest network services...");

	if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
	    strcmp(nvram_safe_get("wl0_gmode"), "-1") &&
	   !strcmp(nvram_safe_get("wk_mode"), "gateway"))
	{
		nvram_set("wl0.1_bss_enabled", "1");
		nvram_set("wl0_vifs", "wl0.1");
	}
	else
	{
		nvram_set("wl0.1_bss_enabled", "0");
		nvram_set("wl0_vifs", "");
	}

	start_wireless();
	start_guest_network();		
	start_gn_httpd();
	start_gn_dhcpd();
	start_gn_nmbd();
	start_dns();

	return 0;
}

int stop_gn_services(void)
{
	clear_gn_conntrack();
	if(strcmp(nvram_safe_get("gn_enable"), "1") || 
		!strcmp(nvram_safe_get("wl0_gmode"), "-1") ||
		strcmp(nvram_safe_get("wk_mode"), "gateway"))
	{
		stop_gn_httpd();
	}

	stop_dns();
	stop_gn_dhcpd();
	stop_gn_nmbd();
	stop_guest_network();
	stop_wireless();

	return 0;
}
#endif

int is_nlinkd_exist()
{
    FILE *fp = NULL;

    fp = fopen("/var/run/nlinkd.pid", "r");
	if (fp == NULL)
		return 0;
	else
	{
		fclose(fp);
	}

	return 1;
}

int
start_single_service(void)
{
	char *service;

	service = nvram_get("action_service");

	if(!service)
		kill(1, SIGHUP);

	printf("Restart service=[%s]\n",service);

	//wuzh add to fix bug 12728 2008-7-29
	nvram_set("action_service_bottom", service);

	//add by michael to fix the DevicesSetting in hnap fails with EGHN at 20080426
	nvram_set("action_service","");
	//end by michael

#ifdef MPPPOE_SUPPORT
	pppoe_in_use = NOT_USING; // tallest 1216
#endif

	if(!strcmp(service,"dhcp")){
		stop_dhcpd();
		start_dhcpd();
		set_dhcp_statics_to_arp();
	}
#ifdef TRENDMICRO_SSS_SUPPORT
	else if( !strcmp(service, "UI_tmSSS_setPolicy")) {
		nvram_set("WAIT_tmsss_setPolicy","1");
//		stop_cron();
		stop_firewall();
#if 0 /*ryan delete*/
		system( "killall syslogd" );
#endif
		stop_nlinkd();

//		start_cron();
		start_firewall();
		start_nlinkd();

		nvram_unset("WAIT_tmsss_setPolicy");
	}
	else if( !strcmp(service, "tmSSS_setPolicy")) {
		nvram_set("WAIT_tmsss_setPolicy","1");
//		stop_cron();
		stop_firewall();
#if 0 /*ryan delete*/
		system( "killall syslogd" );
#endif


		stop_nlinkd();
//		start_cron();
		start_firewall();

		//added by tlhhh. Notify kernel enable hnd for non-HTTP traffic.
		cprintf("=======%s[%d]========\n", __func__, __LINE__);
		start_nlinkd();

		nvram_unset("WAIT_tmsss_setPolicy");
	}
#endif
	else if(!strcmp(service,"start_pppoe")){
		stop_singe_pppoe(PPPOE0);
		start_pppoe(PPPOE0);
	}
	else if(!strcmp(service,"stop_pppoe")){
		stop_singe_pppoe(PPPOE0);
		if(nvram_match("ppp_demand","1")){      // Connect On Demand
			start_pppoe(PPPOE0);
			start_dns();
		}else
			stop_redial();
		//SET_LED(RELEASE_IP);
	}
#ifdef MPPPOE_SUPPORT // tallest 1222
	else if(!strcmp(service,"start_pppoe_1")){
		stop_singe_pppoe(PPPOE1);
		start_pppoe(PPPOE1);
	}
	else if(!strcmp(service,"stop_pppoe_1")){
		stop_singe_pppoe(PPPOE1);
		if(nvram_match("ppp_demand_1","1")){      // Connect On Demand
			start_pppoe(PPPOE1);
		}else
			stop_redial();
		//SET_LED(RELEASE_IP);
	}
#endif
	else if(!strcmp(service,"start_pptp") || !strcmp(service,"start_l2tp") || !strcmp(service,"start_heartbeat")){
		unlink("/tmp/ppp/log");
		stop_lan();
		stop_wan();
		//stop_pppoe();
		start_lan();
		start_wl();
		start_wan(BOOT);
		//start_pppoe(BOOT);
	}
	else if(!strcmp(service,"stop_pptp") || !strcmp(service,"stop_l2tp") || !strcmp(service,"stop_heartbeat")){
#if OEM == LINKSYS
		//wuzh add 2008-4-26
		//Fix CRDC IP-B0006763
		if(nvram_match("ppp_demand","1")){	// Connect On Demand
			stop_wan();
			stop_lan();
			start_lan();
			start_wl();
			start_wan(BOOT);
		}
		else{	// Keep Alive
			stop_wan();
		}
#elif OEM == PCI_OEM || OEM == ELSA
		stop_wan();
#else	// nonbrand	(2003-04-11 by honor)
		if(nvram_match("ppp_demand","1")){	// Connect On Demand
			stop_wan();
			stop_lan();
			start_lan();
			start_wan(BOOT);
		}
		else{	// Keep Alive
			stop_wan();
		}
		//SET_LED(RELEASE_IP);
#endif
	}
	else if(!strcmp(service,"filters")){
		stop_cron();
		start_cron();
		//stop_iptqueue();
		//start_iptqueue();
		stop_firewall();
		start_firewall();
#ifdef MULTICAST_SUPPORT
		stop_igmp_proxy();
		start_igmp_proxy();
#endif
#ifdef IGMP_X_MLD_SUPPORT
		stop_mld_proxy();
		start_mld_proxy();
#endif
#ifdef PARENTAL_CONTROL_SUPPORT
		stop_parental_control();
		start_parental_control();
#endif
	}
	else if(!strcmp(service,"forward")){
		stop_firewall();
		start_firewall();
#ifdef PARENTAL_CONTROL_SUPPORT
		stop_parental_control();
		start_parental_control();
#endif
	}
	else if(!strcmp(service,"forward_upnp")){
#ifdef __CONFIG_WPS__
               stop_wps();
#endif
		stop_upnp();
		stop_firewall();
		start_upnp();
		start_firewall();
#ifdef __CONFIG_WPS__
               	start_wps();
#endif
	}
	//add by michael to change the qos restart way from rcrestart to start_single_services at 20080506
	else if(!strcmp(service,"wiredqos")){
		stop_voip_qos();
		stop_firewall();
		start_firewall();
		start_voip_qos();
	}
	//end by michael
	//John zhu@2008.04.012 
	else if(!strcmp(service,"routing")){
	//modified by John to fix the fulltest bugs at 20080419
	/*
	   stop_routed();
	   stop_firewall();
	   sleep(1);
	   start_firewall();
	   set_routes();
	   start_routed();
   */
#ifdef ROUTED_SUPPORT
		stop_routed();
#else
		stop_zebra();
#endif
		del_routes(nvram_safe_get("del_static_route"));
		nvram_set("del_static_route", "");
		stop_firewall();
		sleep(1);
		start_firewall();
		set_routes();
		nvram_set("add_static_route", "");
#ifdef ROUTED_SUPPORT
		start_routed();
#else
		start_zebra();
#endif
			//end by John
	}
	else if(!strcmp(service,"static_route_del")){
		if(nvram_safe_get("action_service_arg1")){
			del_routes(nvram_safe_get("action_service_arg1"));
			if(nvram_invmatch("dr_setting", "0"))
			{
				stop_zebra();
				sleep(1);
				start_zebra();
			}

		}
	}
#ifdef SNMP_SUPPORT
 	else if(!strcmp(service,"snmp")){
 		stop_snmp();
 		start_snmp();
 	}
#endif
#ifdef DNS_SUPPORT
	else if (!strcmp(service, "dns")) {
		stop_dns();
		start_dns();
	}
#endif	
#ifdef STORAGE_SUPPORT
	else if (!strcmp(service, "storage")) {
		stop_cifs();
		start_cifs();
		stop_nfs();
		start_nfs();
	}
	else if (!strcmp(service, "cifs")) {
		stop_cifs();
		start_cifs();
	}
	else if (!strcmp(service, "nfs")) {
		stop_nfs();
		start_nfs();
	}
	else if (!strcmp(service, "nas_admin")) {
		stop_firewall();
		start_firewall();
#ifdef FTP_SUPPORT
 	        stop_ftp();
		if(strcmp(nvram_safe_get("partition_name_0"), ""))
		{
			printf("Disk connected, start ftp server\n");
                	start_ftp();
		}
#endif
        }

#endif
#ifdef MEDIA_SERVER_SUPPORT
	 else if (!strcmp(service, "media_server")) {
#ifdef IGMP_SNOOP_SUPPORT
		 if (nvram_match("multicast_pass", "1") && nvram_match("MServer","1") )
			 eval("ifconfig","eth2:0","down");
#endif
#ifdef MEDIA_SERVER_SUPPORT
		 stop_media_server();
		 sleep(1);
		 start_media_server();
#endif
#ifdef IGMP_SNOOP_SUPPORT
		 if (nvram_match("multicast_pass", "1") && nvram_match("MServer","1") )
		 {
			 printf("sleeping.......done!\n");
			 sleep(1);
			 printf("sleeping.......done!\n");
			 sleep(1);
			 eval("ifconfig","eth2:0","127.0.0.4","netmask","255.255.255.255");
		 }
#endif

		 //Jemmy add for forbid guest network user to access TwonkyMedia 2009.9.26
#ifdef GUEST_NETWORK_SUPPORT
		 {
			 char rule[256];

			 sprintf(rule, "iptables -D INPUT -i %s -p tcp --dport 9000 -j DROP", nvram_safe_get("gn_lan_ifname"));
			 system(rule);

			 if(!strcmp(nvram_safe_get("gn_enable"), "1") &&  nvram_invmatch("wl0_gmode", "-1"))
			 {		
				 if (nvram_match("MServer", "1"))
				 {
					 sprintf(rule, "iptables -I INPUT -i %s -p tcp --dport 9000 -j DROP", nvram_safe_get("gn_lan_ifname"));
					 system(rule);
				 }
			 }
		 }
#endif
	 }
#endif
#ifdef FTP_SUPPORT
	 else if (!strcmp(service, "ftp_server")) {
		 stop_ftp();
		 if(strcmp(nvram_safe_get("partition_name_0"), ""))
		 {
			 printf("Disk connected, start ftp server\n");
			 start_ftp();
		 }
		 stop_firewall();
		 start_firewall();
	 }
#endif
	else if(!strcmp(service,"ddns_update")){
		nvram_set("ddns_change","update");
		stop_ddns();
		start_ddns();
	}
	else if(!strcmp(service,"ddns_save")){
		nvram_set("ddns_change","save");
		stop_process_monitor();
		start_process_monitor();
		stop_ddns();
		start_ddns();
	}
	
	else if(!strcmp(service,"start_ping")){
		char *ip = nvram_safe_get("ping_ip");
		//		if(!check_wan_link(0))
		//			buf_to_file(PING_TMP, "Network is unreachable\n");

		if(strchr(ip, ' ') || strchr(ip, '`') || strchr(ip, '|') || strchr(ip, '/') || strchr(ip, '>'))		// Fix Ping.asp bug, user can execute command in Ping.asp
			buf_to_file(PING_TMP, "Invalid IP Address or Domain Name\n");
			
		else if(nvram_invmatch("ping_times","") && nvram_invmatch("ping_ip","")){
			char cmd[80];
			/*John@2008.05.16,reponse correct message while ping ip(broadcast ipaddr)
			 * such as 10.0.0.255 etc*/
			struct in_addr ip_n;
			// ip_n.s_addr =  inet_addr(ip);
			// if(((ip_n.s_addr>>24)==0xff)||((ip_n.s_addr>>16)==0xffff)||((ip_n.s_addr>>8)==0xffffff)                                                    ||(ip_n.s_addr==0xffffffff))
			if( inet_aton(ip,&ip_n) && (((ip_n.s_addr>>24)==0xff)||((ip_n.s_addr>>16)==0xffff)||((ip_n.s_addr>>8)==0xffffff) ||(ip_n.s_addr==0xffffffff)))
							//end by John
				buf_to_file(PING_TMP, "Unknown host\n");
			else{
				snprintf(cmd, sizeof(cmd), "ping -c %s -s %s -f %s %s &", nvram_safe_get("ping_times"), nvram_safe_get("ping_size"), PING_TMP, ip);
				printf("cmd=[%s]\n",cmd);
				eval("killall", "ping");
				unlink(PING_TMP);

				system(cmd);    
			}
		}
	}
	else if(!strcmp(service,"start_traceroute")){
		char *ip = nvram_safe_get("traceroute_ip");
		//		if(!check_wan_link(0))
		//			buf_to_file(TRACEROUTE_TMP, "Network is unreachable\n");

		if(strchr(ip, ' ') || strchr(ip, '`') || strchr(ip, '|') || strchr(ip, '/') || strchr(ip, '>'))	// Fix Traceroute.asp bug, users can execute command in Traceroute.asp 
			buf_to_file(TRACEROUTE_TMP, "Invalid IP Address or Domain Name\n");

		else if(nvram_invmatch("traceroute_ip","")){
			/* Some site block UDP packets, so we want to use ICMP packets */
			char cmd[80];
			/*John@2008.04.28,reponse message:Unkown host while traceroute 0*/
			struct in_addr ip_n;
			ip_n.s_addr =  inet_addr(ip);
			if(ip_n.s_addr==0)
				buf_to_file(TRACEROUTE_TMP, "Unknown host 0\n");
			else{
				char cmd[80];
				snprintf(cmd, sizeof(cmd), "/usr/sbin/traceroute -I -O %s -T 2 %s &", TRACEROUTE_TMP, ip);
				printf("cmd=[%s]\n",cmd);
				eval("killall", "traceroute");
				unlink(TRACEROUTE_TMP);
				system(cmd);
			}
		}
	}
#ifdef HSIAB_SUPPORT
	else if(!strcmp(service,"hsiab_register")){
		//stop_hsiabd();
		stop_firewall();
		start_firewall();
	}
#endif
	else if(!strcmp(service,"tftp_upgrade")){
		if(nvram_invmatch("remote_upgrade","1") || nvram_invmatch("remote_management","1"))
			stop_wan();
		stop_httpd();
		stop_zebra();
		stop_upnp();
		stop_cron();
#ifdef EOU_SUPPORT
		stop_eou();
#endif
#ifdef STORAGE_SUPPORT
		stop_cifs();
#endif
#ifdef MEDIA_SERVER_SUPPORT
		stop_media_server();
#endif
#ifdef FTP_SUPPORT
		stop_ftp();
#endif
#ifdef SES_SUPPORT
		stop_ses();
#endif
	}
	else if(!strcmp(service,"http_upgrade")){
#if TRENDMICRO_SSS_SUPPORT //marcel Dec.22.2008  stop TrendMicro HND while doing HTTP upgrade
		stop_nlinkd();
#endif
//		stop_wan();
		stop_zebra();
		stop_upnp();
		stop_cron();
#ifdef STORAGE_SUPPORT
		stop_cifs();
#endif
#ifdef MEDIA_SERVER_SUPPORT
		stop_media_server();
#endif
#ifdef FTP_SUPPORT
		stop_ftp();
#endif
#ifdef EOU_SUPPORT
		stop_eou();
#endif
#ifdef SES_SUPPORT
		stop_ses();
#endif
	}
	else if(!strcmp(service,"default_wireless")){
		//usleep(500000);
		//stop_httpd();	
#ifdef CES_MDNS_SUPPORT
		stop_cesmdns();
#endif
#ifdef GUEST_NETWORK_SUPPORT
	 	if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
		   !strcmp(nvram_safe_get("wk_mode"), "gateway"))
		{
			/* two case need rc restart
			 * 1 - when wireless 2.4G swtich enable to disable first time
			 * 2 - when wireless 2.4G switch disable to enable fitst time
			*/
			if ( (!strcmp(nvram_safe_get("wl0_gmode"), "-1") && !strcmp(nvram_safe_get("wl0.1_bss_enabled"), "1") ) || 
			     (strcmp(nvram_safe_get("wl0_gmode"), "-1") && strcmp(nvram_safe_get("wl0.1_bss_enabled"), "1") ) )
			{
				stop_gn_services();
				sleep(1);
				start_gn_services();
			}else
			{
				stop_wireless();
				sleep(1);
				start_wireless();
			}
		}else
#endif
		{
			stop_wireless();
			sleep(1);
			start_wireless();
		}
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
#ifdef CES_MDNS_SUPPORT
		start_cesmdns();
#endif
		//start_httpd();

	}
	else if(!strcmp(service,"wireless")){
#ifdef CES_MDNS_SUPPORT
		stop_cesmdns();
#endif
		//Jemmy add for speed up restart wirelss 2008.5.14
#if 0
		stop_services();
		stop_lan();
		start_lan();
		start_services();
		dns_to_resolv();
#ifdef T_MOBILE_SUPPORT
		/*security mode:turn on GLED, nonsecurity mode: turn off GLED*/
		if(!strcmp(nvram_safe_get("wl_security_mode"), "disabled"))
			tled_off(GLED);
		else
			tled_on(GLED);
#endif
#ifdef MULTICAST_SUPPORT
		stop_igmp_proxy();
		start_igmp_proxy();
#endif
		stop_firewall();
		start_firewall();
#else
#ifdef GUEST_NETWORK_SUPPORT
	 	if(!strcmp(nvram_safe_get("gn_enable"), "1") && 
		   !strcmp(nvram_safe_get("wk_mode"), "gateway"))
		{
			/* two case need rc restart
			 * 1 - when wireless 2.4G swtich enable to disable first time
			 * 2 - when wireless 2.4G switch disable to enable fitst time
			*/
			if ( (!strcmp(nvram_safe_get("wl0_gmode"), "-1") && !strcmp(nvram_safe_get("wl0.1_bss_enabled"), "1") ) || 
			     (strcmp(nvram_safe_get("wl0_gmode"), "-1") && strcmp(nvram_safe_get("wl0.1_bss_enabled"), "1") ) )
			{
				stop_gn_services();
				sleep(1);
				start_gn_services();
			}else
			{
				stop_wireless();
				sleep(1);
				start_wireless();
			}
		}else
#endif
		{
		stop_wireless();
		sleep(1);
		start_wireless();
		}
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
#endif
#ifdef CES_MDNS_SUPPORT
		start_cesmdns();
#endif

	}
#ifdef GUEST_NETWORK_SUPPORT
	else if(!strcmp(service, "gn_services"))
	{
		//add by michael to fix the hotspot setup can't work on WinXP SP3 OS at 20091022
		//usleep(500000);
		//stop_httpd();
#ifdef CES_MDNS_SUPPORT
		stop_cesmdns();
#endif
		stop_gn_services();
		nvram_set("gn_approval_list", "");
		nvram_set("gn_cur_account", "0");
		sleep(1);
		start_gn_services();	
#ifdef CES_MDNS_SUPPORT
		start_cesmdns();
#endif
		//start_httpd();
	}
#endif
//add by michael to change the apply action of macfilter
	else if(!strcmp(service,"macfilter"))
	{
		start_macfilter();
	}
//end by michael
//add by michael to change the implementation of hnap setdevicesetting2 at 20080806
	else if(!strcmp(service,"hnap_devicesetting2"))
	{
#ifdef __CONFIG_WPS__
               stop_wps();
#endif
		stop_upnp();
		stop_firewall();
		stop_httpd();
		//Jemmy fix IR-B0013801: After Hotspot setup completes successfully & renamed router to e300-m, Windows Vista still lists the router's default name CiscoHotspot13154 2009.11.25
#ifdef LLTD_SUPPORT
		stop_lltd();
#endif

#ifdef SNMP_SUPPORT
		stop_snmp();
		start_snmp();
#endif
		start_httpd();
		start_firewall();
		start_upnp();
#ifdef __CONFIG_WPS__
	      	start_wps();
#endif
		//Jemmy fix IR-B0013801: After Hotspot setup completes successfully & renamed router to e300-m, Windows Vista still lists the router's default name CiscoHotspot13154 2009.11.25
#ifdef LLTD_SUPPORT
		start_lltd();
#endif

	}
//add by michael to change the implementation of hnap setroutersetting at 20080811
	else if(!strcmp(service,"hnap_routersettings"))
	{
#ifdef __CONFIG_WPS__
               	stop_wps();
#endif
		stop_upnp();
		stop_firewall();
		//restert dhcpd to fix the set domain name in hnap SetRouterSettings did not work 
		stop_dhcpd();
		start_dhcpd();
		start_firewall();
		start_upnp();
#ifdef __CONFIG_WPS__
               	start_wps();
#endif

	}
//end by michael
//add by michael to change the implementation of hnap wansetting at 20080827
	else if (!strcmp(service,"hnap_wan")) {
		stop_wan();
		system("killall udhcpc");
		start_wan(BOOT);
	}
//end by michael
//add by michael to improve the hnap set_lansetting_2 implementation at 20081016
#ifdef HNAP_SPEC_V12_SUPPORT
	else if(!strcmp(service,"hnap_lan_restart"))
	{
		//stop_httpd();
		stop_dhcpd();
		start_dhcpd();
		//start_httpd();
			set_dhcp_statics_to_arp();
	}
#endif
	else if(!strcmp(service,"hnap_devicesetting"))
	{		
#ifdef STORAGE_SUPPORT
		stop_nmbd();		
		start_nmbd();	
#endif
		//Jemmy add for restart UPnP/MediaServer/Netbios when change machine name 2009.11.6
#if ((LINKSYS_MODEL == E300) || (LINKSYS_MODEL == E3200) || (LINKSYS_MODEL == E4200))
		stop_upnp();
#ifdef MEDIA_SERVER_SUPPORT
		stop_media_server();
#endif
#ifdef FTP_SUPPORT
		stop_ftp();	
#endif
#ifdef __CONFIG_WPS__
		stop_wps();
#endif
#ifdef __CONFIG_WSCCMD__
		stop_wsc(); 
#endif		
		//Jemmy fix IR-B0013801: After Hotspot setup completes successfully & renamed router to e300-m, Windows Vista still lists the router's default name CiscoHotspot13154 2009.11.25
#ifdef LLTD_SUPPORT
		stop_lltd();
#endif

		sleep(1);
		start_upnp();
#ifdef FTP_SUPPORT
		start_ftp();
#endif
#ifdef MEDIA_SERVER_SUPPORT
		start_media_server();
#endif
#ifdef __CONFIG_WPS__
		start_wps();
#endif

#ifdef __CONFIG_WSCCMD__
		start_wsc(); //Add by crazy 20080428: To start wsccmd must be earlier than to start nas.
#endif
#endif
		//Jemmy fix IR-B0013801: After Hotspot setup completes successfully & renamed router to e300-m, Windows Vista still lists the router's default name CiscoHotspot13154 2009.11.25
	
#ifdef LLTD_SUPPORT
		start_lltd();
#endif

	}
#ifdef WSC_SUPPORT
	else if(!strcmp(service,"wsc_restart")){
		stop_nas();
		eval("wlconf",nvram_safe_get("wl0_ifname"),"down");
		eval("wlconf",nvram_safe_get("wl0_ifname"),"up");
                //Jemmy modify for porting new WPS from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
		start_nas("lan");
#else	
		eval("wlconf",nvram_safe_get("wl0_ifname"),"start");
		start_nas();
#endif
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
	}
#ifdef __CONFIG_WSCCMD__
	else if(!strcmp(service,"restart_wsc")){
		stop_wsc();
		start_wsc();
	}
#endif
	else if(!strcmp(service,"restart_nas_wsc")){
		sleep(2);
		//Jemmy modify for porting new WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WSCCMD__
		stop_nas();
		stop_wsc(); 
		nvram_set("wsc_method", "1");  //Jemmy add it 2008.11.21
#endif
#ifdef __CONFIG_WPS__
		stop_wps();
		stop_nas();
		stop_eapd();
#endif

		if(nvram_invmatch("wl0_net_mode", "disabled"))
		{
			system("wlconf eth1 down");
		}
#ifdef SIMUL_DUAL_BAND_SUPPORT
		if(nvram_invmatch("wl1_net_mode", "disabled"))
			
		{
			system("wlconf eth2 down");
		}
#endif
		sleep(1);
		if(nvram_invmatch("wl0_net_mode", "disabled"))
		{
			system("wlconf eth1 up");
#ifdef __CONFIG_WPS__
			system("wlconf eth1 start");
#endif
		}
#ifdef SIMUL_DUAL_BAND_SUPPORT
		if(nvram_invmatch("wl1_net_mode", "disabled"))
		{
			system("wlconf eth2 up");
#ifdef __CONFIG_WPS__
			system("wlconf eth2 start");
#endif
		}
#endif
		//Jemmy modify for porting new WPS from BSP.5.20.20 2008.11.17
#ifdef __CONFIG_WSCCMD__
		nvram_set("wsc_ap_role","proxy"); //Add by Yogo 0521
		start_wsc();
		start_nas("lan");
#endif
#ifdef __CONFIG_WPS__
		start_eapd();
		start_nas();
		start_wps();
#endif
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
	}
	else if (!strcmp(service,"wsc_pushbutton"))
	{
#ifndef __CONFIG_WSCCMD__ //Debug by crazy 20080410: for wsccmd test
                //Jemmy modify when port wireless from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
		if(wsc_button_pressed()){
			nvram_set("wsc_ap_role","withReg");
			nvram_set("wsc_config_method","pbc");
			nvram_set("wsc_count2","1");
			stop_wsc();
			sleep(3);
			send_config_to_wsc();
			start_wsc();
		}
#else
		//Just for web page.
		nvram_set("wsc_result", "3");
		nvram_set("wsc_barwidth", "0");
		nvram_set("wsc_steps", "0");
		nvram_set("wsc_webpage_method", "pbc");

		nvram_set("wps_sta_pin","00000000");   //yogo modify ----0521
		nvram_set("wsc_count2","1");
		nvram_set("wsc_sta_pin_timer", "0");

		/*Alpha 2010.05.06 add to fix the WPS progress bar issues. */
		nvram_set("wps_config_command", "1");
#if ((LINKSYS_MODEL == WRT610N) || (LINKSYS_MODEL == E300))                                                                                  
		system("killall check_wps_led");
		system("/sbin/check_wps_led 0 2 0 &");
#endif

		//Jemmy modify when port wireless from BSP.5.20.20 2008.10.15
		nvram_set("wps_method", "2");
		nvram_set("wps_upnp","0");
		nvram_set("wl_wps_reg","enabled");
		nvram_set("wps_event", "1");
		wps_gui_set("pushbutton");
#endif
#else
		nvram_set("wsc_ap_role","withReg"); //Add by Yogo 0521
                nvram_set("wsc_sta_pin","0");   //yogo modify ----0521
		nvram_set("wsc_count2","1");
                nvram_set("wsc_sta_pin_timer", "0");

		if(strcmp("1", nvram_safe_get("wsc_config_state")))
		{
			generate_ssidAndKey();
		}

		//Just for web page.
		nvram_set("wsc_result", "3");
		nvram_set("wsc_barwidth", "0");
		nvram_set("wsc_steps", "0");
		nvram_set("wsc_webpage_method", "pbc");
		
		stop_wsc();

		system("killall check_wps_led");
		system("/sbin/check_wps_led 0 2 0 &");

		nvram_set("wsc_method", "2");
		nvram_set("wsc_proc_status", "0");
		nvram_set("wsc_config_command", "1");

		start_wsc();
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif		
		sleep(1);
		
		nvram_set("wsc_event", "1");
#endif
	}
	else if (!strcmp(service,"wsc_enterpin"))
	{
#ifndef __CONFIG_WSCCMD__ //Debug by crazy 20080410: for wsccmd test
        //Jemmy add for porting New WPS from BSP.5.20.20 2008.11.17
#ifndef __CONFIG_WPS__
		if(nvram_invmatch("wsc_result","3") && 
		   nvram_invmatch("wsc_result","4")){
			nvram_set("wsc_ap_role","withReg");
			nvram_set("wsc_config_method","pin");
			nvram_set("wsc_count2","1");
			stop_wsc();
			sleep(3);
			send_config_to_wsc();
			start_wsc();
		}
#else  //else __CONFIG_WPS__
		//Just for web page.
		nvram_set("wsc_result", "3");
		nvram_set("wsc_barwidth", "0");
		nvram_set("wsc_steps", "0");
		nvram_set("wsc_webpage_method", "pin");

#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
		sleep(2);

		nvram_set("wps_method", "1");  
		nvram_set("wps_sta_pin", nvram_safe_get("wsc_enr_pin"));
		nvram_set("wsc_enr_pin", "");
		nvram_set("wps_upnp","0");
		nvram_set("wl_wps_reg","enabled"); 
		//nvram_set("wps_config_command", "1");
		wps_gui_set("enterpin");
#endif // endif __CONFIG_WPS__

#else  //else __CONFIG_WSCCMD__ 
		nvram_set("wsc_ap_role","withReg"); //Add by Yogo 0521
		if(nvram_invmatch("wsc_result","3") && 
			nvram_invmatch("wsc_result","4"))
		{
		nvram_set("wsc_count2","1");

		if(strcmp("1", nvram_safe_get("wsc_config_state")))
		{
			generate_ssidAndKey();
		}
#if 0 //for dual band
		else 
		{
			check_security();
		}
#endif

		//Just for web page.
		nvram_set("wsc_result", "3");
		nvram_set("wsc_barwidth", "0");
		nvram_set("wsc_steps", "0");
		nvram_set("wsc_webpage_method", "pin");
		
		stop_nas();
		stop_wsc();
		
		if(nvram_invmatch("wl0_net_mode", "disabled"))
		{
			system("wlconf eth1 down");
		}
#ifdef SIMUL_DUAL_BAND_SUPPORT
		if(nvram_invmatch("wl1_net_mode", "disabled"))
		{
			system("wlconf eth2 down");
		}
#endif
		sleep(1);
		
		if(nvram_invmatch("wl0_net_mode", "disabled"))
		{
			system("wlconf eth1 up");
		}
		
#ifdef SIMUL_DUAL_BAND_SUPPORT
		if(nvram_invmatch("wl1_net_mode", "disabled"))
		{
			system("wlconf eth2 up");
		}
#endif	
		nvram_set("wsc_method", "1");	
		//sleep(5);
		start_wsc();
		start_nas("lan");
#ifdef EGHN_SUPPORT
		//add by michael to add  eghn patch  at 20080619
		system("killall -21 httpd");   // 21 mean signal SIGURG
#endif
		sleep(5);
		nvram_set("wsc_sta_pin", nvram_safe_get("wsc_enr_pin"));
		nvram_set("wsc_enr_pin", "");
		nvram_set("wsc_proc_status", "0");
		nvram_set("wsc_config_command", "1");
		}
#endif
	}
#ifdef __CONFIG_WSCCMD__	//Lai 2010.04.26 removed it.
	else if (!strcmp(service,"wsc_getconfig"))
	{
		nvram_set("wsc_ap_role","proxy");
		stop_wsc();
		sleep(3);
		start_wsc();
	}
	else if (!strcmp(service,"wsc_reset"))
	{
		wl_gui_reset();
		nvram_set("wsc_ap_role","proxy");
		nvram_set("wsc_count2","0");
		nvram_commit();
		stop_wsc();
		sleep(3);
		start_wsc();
	}
	else if (!strcmp(service,"wsc_default"))
	{
		nvram_set("wsc_ap_role","proxy");
		nvram_commit();
		stop_wsc();
		sleep(3);
		start_wsc();
	}
#endif
	//Jemmy add for detect wps button 2009.6.23
	else if (!strcmp(service, "diagWPSButton"))
	{
		eval("killall", "diagwpsbutton");
		sleep(1);
		eval("diagwpsbutton");	
	}
#endif	//end of WSC_SUPPORT

	else if(!strcmp(service,"commit")){
		nvram_commit();
	}
	else if(!strcmp(service,"dhcp_release")){
		char sigusr[] = "-XX";
		sprintf(sigusr, "-%d", SIGUSR2);
		sleep(1);
#if 0
		eval("killall", sigusr, "udhcpc");
#else
		eval("killall", sigusr, "dhclient");	//for new dhcp client app	2010-11-11 Alpha
#endif
		SET_LED(RELEASE_IP);
	}
	else if(!strcmp(service,"turn_led")){
		set_device_LEDs();
	}
	else if(!strcmp(service,"management")){
		int i;
/*
#ifdef TRENDMICRO_SSS_SUPPORT
		stop_TMSSS_new();
#endif
*/
#ifdef __CONFIG_WPS__
               	stop_wps();
#endif
                //set_device_LEDs();
		stop_upnp();
/*Taide  modify to fix RDQA bug  0024020---------2010_8_3   begin*/		
		  
              for( i = 0;i < 5 ; i++)				
              {                	  
	        	usleep(300000);			   
               }
/*Taide------------------end*/
		start_upnp();
#ifdef __CONFIG_WPS__
               	start_wps();
#endif
//add by michael to support custom404 page at 20081215
#ifdef CUSTOM404_SUPPORT
		stop_dns();
		start_dns();
#endif
		stop_httpd();
		start_httpd();
		start_firewall();
/*
#ifdef TRENDMICRO_SSS_SUPPORT
		start_TMSSS();
#endif
*/
#ifdef SNMP_SUPPORT
		stop_snmp();
		start_snmp();
#endif
#if 0
		//Jemmy add for SIP ALG button 2009.2.12
#ifdef ALG_MODULE_SUPPORT && ((LINKSYS_MODEL == E300) || (LINKSYS_MODEL == E3200) || (LINKSYS_MODEL == E4200))
		system("echo 3 > /proc/net/del_ip_conntrack");
#ifdef LINUX26
		eval("rmmod", "nf_nat_sip");
		eval("rmmod", "nf_conntrack_sip");

		if (nvram_match("nf_alg_sip", "1"))
		{
			eval("insmod", "nf_conntrack_sip");
			eval("insmod", "nf_nat_sip");
		}
#else
		eval("rmmod", "ip_nat_sip");
		eval("rmmod", "ip_conntrack_sip");
		if (nvram_match("nf_alg_sip", "1"))
		{
			eval("insmod", "ip_conntrack_sip");
			eval("insmod", "ip_nat_sip");
		}
#endif
#endif
#endif
	}
#ifdef HSIAB_SUPPORT
	else if(!strcmp(service,"start_hsiabsys")){
		stop_dns();
		start_dns();	
	
		stop_dhcpd();
		start_dhcpd();	
	
		stop_process_monitor();
		start_process_monitor();	

		eval("wlconf", nvram_safe_get("wl0_ifname"), "down");
		eval("wlconf", nvram_safe_get("wl0_ifname"), "up");
		//Jemmy add for port new wireless from BSP.5.20.22 2008.11.20
#ifdef __CONFIG_WPS__
		eval("wlconf", nvram_safe_get("wl0_ifname"), "start");
#endif	
		eval("hsiab_fw");
	}
#endif
#ifdef SES_SUPPORT
	else if(!strcmp(service,"ses_led")){
		char *led_argv[] = { "ses_led",
				     "9999",
				     "25",
				     NULL
		};
		pid_t pid;
	
		eval("killall", "ses_led");
		_eval(led_argv, NULL, 0, &pid);
	}
#endif
#ifdef SYMC_OUTBREAK_SUPPORT
	else if(!strcmp(service,"outbreak")) {
		stop_outbreak();
		if(check_wan_link(0)) {
			stop_firewall();
			start_firewall();
		}
		else {
			stop_br_firewall();
			start_br_firewall();
		}
		start_outbreak();
	}
#endif
	else if(!strcmp(service,"dhcp")) {
		stop_dhcpd();
                start_dhcpd();
	}
	else if (!strcmp(service, "") && !strcmp(nvram_safe_get("notify_service"), "brcm_notify_service")) {
		/* BRCM notfiy_rc has its own handling function */
		nvram_unset("notify_service");
	}
	/***********Start********************************/
	//Jemmy port from WRV600 2008.4.11
	else if(!strcmp(service,"upnp_dhcp_renew"))
	{
		char sigusr[] = "-XX";

		sprintf(sigusr, "-%d", SIGUSR1);
#if 0
		eval("killall", sigusr, "udhcpc");
#else
		eval("killall", sigusr, "dhclient");	//for new dhcp client app	2010-11-11 Alpha
#endif
		//kill_ps("udhcpc", SIGUSR1, 0);
	}
	else if(!strcmp(service,"upnp_teminate"))
	{
		char *wan_proto_name = nvram_safe_get("wan_proto");
		if(!strcmp(wan_proto_name, "dhcp"))
		{
			nvram_set("wan_ipaddr","0.0.0.0");
			nvram_set("wan_netmask","0.0.0.0");
			nvram_set("wan_gateway","0.0.0.0");
			nvram_set("wan_get_dns","");
			nvram_set("wan_lease","0");
			
			unlink("/tmp/get_lease_time");
			unlink("/tmp/lease_time");

#if 0
			eval("killall", "-17", "udhcpc");
#else
			eval("killall", "-17", "dhclient");	//for new dhcp client app	2010-11-11 Alpha
#endif
			SET_LED(RELEASE_IP);
		
		}
		else if(!strcmp(wan_proto_name, "pppoe"))
		{
			unlink("/tmp/ppp/log");
			unlink("/tmp/ppp/link");

			stop_singe_pppoe(PPPOE0);
			if(nvram_match("ppp_demand","1"))
			{      // Connect On Demand
				start_pppoe(PPPOE0);
#ifdef DNS_COMPACT
		    		start_dns(1);
#else
		    		start_dns();
#endif
			}

		}
		else if(!strcmp(wan_proto_name, "pptp") || !strcmp(wan_proto_name, "l2tp") || !strcmp(wan_proto_name, "heartbeat"))
		{
#if OEM == LINKSYS
		#if LINKSYS_MODEL == WRV600
			stop_wan();
			stop_lan();
			start_lan();
			start_wan(BOOT);
		#else
			stop_wan();
		#endif
	/************ End of tanghui ********************/
#elif OEM == PCI_OEM || OEM == ELSA
			stop_wan();
#else	// nonbrand	(2003-04-11 by honor)
			if(nvram_match("ppp_demand","1")){	// Connect On Demand
				stop_wan();
				clean_arp_binding();
				stop_lan();
				start_lan();
				do_arp_binding();
				start_arp_broadcast();
				start_wan(BOOT);
			}
			else{	// Keep Alive
				stop_wan();
			}
#endif
		}
#ifdef __CONFIG_WPS__
               	stop_wps();
#endif
		stop_upnp();
		start_upnp();
#ifdef __CONFIG_WPS__
               	start_wps();
#endif

	}
	//{{ wuzh add to support WAN connection detection 2008-9-18
	else if(!strcmp(service,"wan_auto_detect")){
#ifdef WAN_DETECT_SUPPORT
		if(nvram_match("wan_proto","dhcp"))
		{
			stop_wan();
			start_wan(BOOT);
		}
#else
		struct detect_wans * detect = NULL;

		nvram_set("wan_auto_detect_result", "UNKNOWN");
		
		//detect dhcp mode first
		detect = detect_dhcp("vlan2", NULL , "AUTO");
		if(detect && detect->proto == PROTO_DHCP)
		{
			cprintf("=====( auto detect - dhcp connected!! )=====\n");
			nvram_set("wan_auto_detect_result", "DHCP");
			free(detect);
			detect = NULL;
		}else{
			//free the detect first!
			if(detect)
				free(detect);
			detect = NULL;
			//detect pppoe mode
			detect = detect_pppoe("vlan2", NULL, "AUTO");
			if(detect){
				if(detect->proto == PROTO_PPPOE) nvram_set("wan_auto_detect_result", "DHCPPPPoE");
		
				free(detect);
				detect = NULL;
			}
		}
		nvram_set("wan_detect_done","1");	
#endif		
	}
	//}}
	/***********End*********************************/
	else{
		//nvram_unset("action_service");
		nvram_unset("action_service_arg1");
		kill(1, SIGHUP);
	}

#ifdef WSC_SUPPORT
        if(strcmp(service,"wireless"))
#endif
//add by michael to fix the DevicesSetting in hnap fails with EGHN at 20080426
        //nvram_set("action_service","");
//end by michael
	nvram_set("action_service_arg1","");

	//wuzh add to fix bug 12728 2008-7-29
	nvram_set("action_service_bottom","");
	return 0;
}

//add by michael to add dhcp-pptp
#ifdef PPTP_DHCPC_SUPPORT
static inline unsigned long
inet_atoul(char *cp)
{
	struct in_addr in;

	(void) inet_aton(cp, &in);
	return in.s_addr;
}
#endif
//end by michael

int
start_pptp(int status)
{
	int ret;
	FILE *fp;
	char *pptp_argv[] = { "pppd",
			      NULL
	};
	char username[80],passwd[80];
//add by michael to add dhcp-pptp at 20080331
#ifdef PPTP_DHCPC_SUPPORT
	unsigned long tmp_pptp_server_ip = 0, tmp_wan_netmask = 0, tmp_wan_gateway = 0;

	if(nvram_invmatch("sel_pptp_dhcp", "1"))
#endif
//end by michael
	stop_dhcpc();
	stop_pppoe();

	if(nvram_match("aol_block_traffic","0")){
		snprintf(username, sizeof(username), "%s", nvram_safe_get("ppp_username"));
		snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("ppp_passwd"));
	}
	else{
		if(!strcmp(nvram_safe_get("aol_username"),"")){
			snprintf(username, sizeof(username), "%s", nvram_safe_get("ppp_username"));
			snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("ppp_passwd"));
		}
		else{
			snprintf(username, sizeof(username), "%s", nvram_safe_get("aol_username"));
			snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("aol_passwd"));
		}		
	}

	if(status != REDIAL){
		mkdir("/tmp/ppp", 0777);
		symlink("/sbin/rc", "/tmp/ppp/ip-up");
		symlink("/sbin/rc", "/tmp/ppp/ip-down");
		symlink("/dev/null", "/tmp/ppp/connect-errors");

		/* Generate options file */
	       	if (!(fp = fopen("/tmp/ppp/options", "w"))) {
       	        	perror("/tmp/ppp/options");
       	        	return -1;
	       	}
	       	fprintf(fp, "defaultroute\n");  //Add a default route to the system routing tables, using the peer as the gateway
      	 	fprintf(fp, "usepeerdns\n");    //Ask the peer for up to 2 DNS server addresses
       		fprintf(fp, "pty 'pptp %s --nolaunchpppd'\n",nvram_safe_get("pptp_server_ip")); 
       		fprintf(fp, "user '%s'\n",username);
       		//fprintf(fp, "persist\n");        // Do not exit after a connection is terminated.

       		fprintf(fp, "mtu %s\n",nvram_safe_get("wan_mtu"));
	
		if(nvram_match("ppp_demand", "1")){ //demand mode
       			fprintf(fp, "idle %d\n",nvram_match("ppp_demand", "1") ? atoi(nvram_safe_get("ppp_idletime"))*60 : 0);
       			fprintf(fp, "demand\n");         // Dial on demand
       			fprintf(fp, "persist\n");        // Do not exit after a connection is terminated.
	       		fprintf(fp, "%s:%s\n",PPP_PSEUDO_IP,PPP_PSEUDO_GW);   // <local IP>:<remote IP>
       			fprintf(fp, "ipcp-accept-remote\n");        
       			fprintf(fp, "ipcp-accept-local\n");        
       			fprintf(fp, "connect true\n"); 
       			fprintf(fp, "noipdefault\n");          // Disables  the  default  behaviour when no local IP address is specified
       			fprintf(fp, "ktune\n");         // Set /proc/sys/net/ipv4/ip_dynaddr to 1 in demand mode if the local address changes
		}
		else{	// keepalive mode
			start_redial();
		}

    	  	fprintf(fp, "default-asyncmap\n"); // Disable  asyncmap  negotiation
		fprintf(fp, "nopcomp\n");	// Disable protocol field compression
		fprintf(fp, "noaccomp\n");	// Disable Address/Control compression 
       		fprintf(fp, "noccp\n");         // Disable CCP (Compression Control Protocol)
       		fprintf(fp, "novj\n");          // Disable Van Jacobson style TCP/IP header compression
       		fprintf(fp, "nobsdcomp\n");     // Disables BSD-Compress  compression
       		fprintf(fp, "nodeflate\n");     // Disables Deflate compression
		fprintf(fp, "lcp-echo-interval 30\n");     // Don't send an LCP echo-request frame to the peer
       		fprintf(fp, "lock\n");
       		fprintf(fp, "noauth");
	
       		fclose(fp);

       		/* Generate pap-secrets file */
       		if (!(fp = fopen("/tmp/ppp/pap-secrets", "w"))) {
       	        	perror("/tmp/ppp/pap-secrets");
        	       	return -1;
       		}
       		fprintf(fp, "\"%s\" * \"%s\" *\n",
			username,
			passwd);
       		fclose(fp);
		chmod("/tmp/ppp/pap-secrets", 0600);

       		/* Generate chap-secrets file */
       		if (!(fp = fopen("/tmp/ppp/chap-secrets", "w"))) {
        	       	perror("/tmp/ppp/chap-secrets");
               		return -1;
       		}
       		fprintf(fp, "\"%s\" * \"%s\" *\n",
			username,
			passwd);
       		fclose(fp);
		chmod("/tmp/ppp/chap-secrets", 0600);

		/* Enable Forwarding */
		if ((fp = fopen("/proc/sys/net/ipv4/ip_forward", "r+"))) {
			fputc('1', fp);
			fclose(fp);
		} else
			perror("/proc/sys/net/ipv4/ip_forward");
	}

//add by michael to add dhcp-pptp at 20080331
#ifdef PPTP_DHCPC_SUPPORT
	if(nvram_invmatch("sel_pptp_dhcp", "1"))
	{
#endif	
	/* Bring up  WAN interface */
	ifconfig(nvram_safe_get("wan_ifname"), IFUP,
		 nvram_safe_get("wan_ipaddr"), nvram_safe_get("wan_netmask"));

#ifdef PPTP_DHCPC_SUPPORT
		tmp_pptp_server_ip = inet_atoul(nvram_safe_get("pptp_server_ip"));
		tmp_wan_gateway = inet_atoul(nvram_safe_get("wan_pptp_gateway"));
		tmp_wan_netmask = inet_atoul(nvram_safe_get("wan_netmask"));
		if((tmp_pptp_server_ip & tmp_wan_netmask) != (tmp_wan_gateway & tmp_wan_netmask))
			route_add(nvram_safe_get("wan_ifname"), 0, nvram_safe_get("pptp_server_ip"), nvram_safe_get("wan_pptp_gateway"), "255.255.255.255");
	}
#endif
//end by michael 

	ret = _eval(pptp_argv, NULL, 0, NULL); 
	
	if (nvram_match("ppp_demand", "1")){
		/* Trigger Connect On Demand if user press Connect button in Status page */
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
		//if(nvram_match("action_service","start_pptp")){
		if(nvram_match("action_service","start_pptp") || nvram_match("hnap_force_to_dial","1")){
			//force_to_dial();
                        force_to_dial(nvram_safe_get("action_service"));
			nvram_set("action_service","");
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
			nvram_set("hnap_force_to_dial","");	
		}
		/* Trigger Connect On Demand if user ping pptp server */
		else
			eval("listen", nvram_safe_get("lan_ifname"));
	}

	dprintf("done\n");
	return ret;
}

int
stop_pptp(void)
{
	int ret;

	unlink("/tmp/ppp/link");
        ret = eval("killall","-9","pppd");
        ret += eval("killall","-9","pptp");
        ret += eval("killall","-9","listen");

	dprintf("done\n");
	return ret ;
}
//=========================================tallest============================================
/*
 * This functin build the pppoe instuction & execute it.
 */
int
start_pppoe(int pppoe_num)
{
        char idletime[20], retry_num[20],param[4];
        char username[80], passwd[80];
                                                                                                                             
        char ppp_username[2][20]={"ppp_username","ppp_username_1"};
        char ppp_passwd[2][20]={"ppp_passwd","ppp_passwd_1"};
        char ppp_demand[2][20]={"ppp_demand","ppp_demand_1"};
        char ppp_service[2][20]={"ppp_service","ppp_service_1"};
        char ppp_ac[2][10]={"ppp_ac","ppp_ac_1"};
        char wanip[2][15]={"wan_ipaddr","wan_ipaddr_1"};
        char wanmask[2][15]={"wan_netmask","wan_netmask_1"};
        char wangw[2][15]={"wan_gateway","wan_gateway_1"};
        char pppoeifname[15];
                                                                                                                             
        pid_t pid;
                                                                                                                             
        sprintf(pppoeifname,"pppoe_ifname%d",pppoe_num);
        nvram_set(pppoeifname,"");
                                                                                                                             
        dprintf("start session %d\n",pppoe_num);
#ifdef MPPPOE_SUPPORT
        /* 1. To avoid multi-session pppoe dialing in same time.
         * 2. "pppoe_in_use" this flag init value is NOT_USING.
         * 3. "pppoe_in_use" will be set to USING after the exec. "_eval()" function.
         * 4. "pppoe_in_use" will be set to NOT_USING in ppp.c "ipup_main()" function.
         */
        if((pppoe_in_use == USING) && nvram_invmatch(ppp_demand[pppoe_num],"1")){       //tallest 1216
                wait_pppoe(8);
        }
                                                                                                                             
        if(nvram_invmatch("mpppoe_enable","1") && pppoe_num == PPPOE1)  return 1;
#endif
        sprintf(idletime,"%d",atoi(nvram_safe_get("ppp_idletime"))*60);
        snprintf(retry_num, sizeof(retry_num), "%d", (atoi(nvram_safe_get("ppp_redialperiod"))/5)-1);
                                                                                                                             
        if(nvram_match("aol_block_traffic","1") && pppoe_num == PPPOE0){
                if(!strcmp(nvram_safe_get("aol_username"),"")){
                        snprintf(username, sizeof(username), "%s", nvram_safe_get("ppp_username"));
                        snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("ppp_passwd"));
                }
                else{
                        snprintf(username, sizeof(username), "%s", nvram_safe_get("aol_username"));
                        snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("aol_passwd"));
                }
                                                                                                                             
        }
        else{
                snprintf(username, sizeof(username), "%s", nvram_safe_get(ppp_username[pppoe_num]));
                snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get(ppp_passwd[pppoe_num]));
        }
        sprintf(param,"%d",pppoe_num);
                                                                                                                             
        char *pppoe_argv[] = { "pppoecd",
                nvram_safe_get("wan_ifname"),
                "-u", username,
                "-p", passwd,
                "-r", nvram_safe_get("wan_mtu"),//del by honor, add by tallest.
                "-t", nvram_safe_get("wan_mtu"),
                "-i", nvram_match(ppp_demand[pppoe_num], "1") ? idletime : "0",
#ifdef VERIZON_WAN_SUPPORT
                "-v", "10", 	// retrasmits time (sec).
		"-I", "60",	// Send an LCP echo-request frame to the server every 60 seconds
                "-N", "6", // To avoid kill pppd when pppd has been connecting.
                "-T", "6",      // pppd will presume the server to be dead if 6 LCP echo-requests are sent without receiving a valid LCP echo-reply
#else
                "-I", "30",     // Send an LCP echo-request frame to the server every 30 seconds
                "-N", retry_num, // To avoid kill pppd when pppd has been connecting.
                "-T", "5",      // pppd will presume the server to be dead if 3 LCP echo-requests are sent without receiving a valid LCP echo-reply
#endif
                "-P", param,    // PPPOE session number.
#if LOG_PPPOE == 2
                "-d",
#endif
                "-C", "disconnected_pppoe", //by tallest 0407
                NULL,           /* set default route */
#ifdef UNNUMBERIP_SUPPORT
                NULL,           /* using unnumber ip */
#endif
                NULL, NULL,     /* pppoe_service */
                NULL, NULL,     /* pppoe_ac */
                NULL,           /* pppoe_keepalive */
                NULL
        }, **arg;
        /* Add optional arguments */
        for (arg = pppoe_argv; *arg; arg++);
                                                                                                                             
        if (pppoe_num == PPPOE0) { // PPPOE0 must set default route.
                *arg++ = "-R";
        }
#ifdef UNNUMBERIP_SUPPORT
        if (nvram_match("wan_proto","unnumberip")) { /* using unnumber ip */ // tallest must be change...
                *arg++ = "-n";
        }
#endif
        if (nvram_invmatch(ppp_service[pppoe_num], "")) {
                *arg++ = "-s";
                *arg++ = nvram_safe_get(ppp_service[pppoe_num]);
        }
        if (nvram_invmatch(ppp_ac[pppoe_num], "")) {
                *arg++ = "-a";
                *arg++ = nvram_safe_get(ppp_ac[pppoe_num]);
        }
        if (nvram_match("ppp_static", "1")) {
                        *arg++ = "-L";
                        *arg++ = nvram_safe_get("ppp_static_ip");
        }
        //if (nvram_match("pppoe_demand", "1") || nvram_match("pppoe_keepalive", "1"))
                *arg++ = "-k";
                                                                                                                             
        mkdir("/tmp/ppp", 0777);
        symlink("/sbin/rc", "/tmp/ppp/ip-up");
        symlink("/sbin/rc", "/tmp/ppp/ip-down");
        symlink("/sbin/rc", "/tmp/ppp/set-pppoepid"); // tallest 1219
        unlink("/tmp/ppp/log");

	_eval(pppoe_argv, NULL, 0, &pid);
#ifdef MPPPOE_SUPPORT
        pppoe_in_use = USING ;  //tallest 1216
#endif
                                                                                                                             
        if (nvram_match(ppp_demand[pppoe_num], "1")) {
                start_tmp_ppp(pppoe_num);
                cprintf("------------------------------------------------------------------------------\n");
                char tmpifname[15];
                sprintf(tmpifname,"pppoe_ifname%d",pppoe_num);
                cprintf("pppoe%d ifname=%s ip=%s , netmask=%s, gw=%s\n",
                        pppoe_num,
                        nvram_safe_get(tmpifname),
                        nvram_safe_get(wanip[pppoe_num]),
                        nvram_safe_get(wanmask[pppoe_num]),
                        nvram_safe_get(wangw[pppoe_num]));
                cprintf("------------------------------------------------------------------------------\n");
        }
        dprintf("done. session %d\n",pppoe_num);
        return 0;
}
                                                                                                                             
/*
 * Get the IP, Subnetmask, Geteway from WAN interface
 * and set to NV ram.
 */
void
start_tmp_ppp(int num){
                                                                                                                             
        int timeout = 5;
        char pppoeifname[15];
        char wanip[2][15]={"wan_ipaddr","wan_ipaddr_1"};
        char wanmask[2][15]={"wan_netmask","wan_netmask_1"};
        char wangw[2][15]={"wan_gateway","wan_gateway_1"};
        //char wanif[2][15]={"wan_ifname","wan_ifname_1"};
        //char *wan_ifname = nvram_safe_get("wan_ifname");
        struct ifreq ifr;
        int s;
                                                                                                                             
        dprintf("start session %d\n",num);
                                                                                                                             
        sprintf(pppoeifname,"pppoe_ifname%d",num);
                                                                                                                             
        if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
                return;
                                                                                                                             
        /* Wait for ppp0 to be created */
        while (ifconfig(nvram_safe_get(pppoeifname), IFUP, NULL, NULL) && timeout--)
                sleep(1);
                                                                                                                             
        strncpy(ifr.ifr_name, nvram_safe_get(pppoeifname), IFNAMSIZ);
                                                                                                                             
        /* Set temporary IP address */
        timeout = 3;
        while (ioctl(s, SIOCGIFADDR, &ifr) && timeout--){
                perror(nvram_safe_get(pppoeifname));
                printf("Wait %s inteface to init (1) ...\n",nvram_safe_get(pppoeifname));
                sleep(1);
        };
        nvram_set(wanip[num], inet_ntoa(sin_addr(&(ifr.ifr_addr))));
        nvram_set(wanmask[num], "255.255.255.255");
                                                                                                                             
        /* Set temporary P-t-P address */
        timeout = 3;
        while (ioctl(s, SIOCGIFDSTADDR, &ifr) && timeout--){
                perror(nvram_safe_get(pppoeifname));
                printf("Wait %s inteface to init (2) ...\n",nvram_safe_get(pppoeifname));
                sleep(1);
        }
        nvram_set(wangw[num], inet_ntoa(sin_addr(&(ifr.ifr_dstaddr))));
                                                                                                                             
#ifdef MPPPOE_SUPPORT // tallest 1208
        if((num == 1 && nvram_match("mpppoe_enable","1"))
        || (num == 0 && nvram_invmatch("mpppoe_enable","1")))
        {
                start_wan_done(nvram_safe_get(pppoeifname));
        }
#else
        start_wan_done(nvram_safe_get(pppoeifname));
#endif
                                                                                                                             
        // if user press Connect" button from web, we must force to dial
#if 0
        if(nvram_match("action_service","start_pppoe") || nvram_match("action_service","start_pppoe_1")){
                sleep(3);
                force_to_dial(nvram_safe_get("action_service"));
                nvram_set("action_service","");
        }
#else
	//wuzh modify to fix bug 12728
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
        if(nvram_match("action_service_bottom","start_pppoe") || nvram_match("action_service_bottom","start_pppoe_1") || nvram_match("hnap_force_to_dial","1")){
                sleep(3);
                force_to_dial(nvram_safe_get("action_service_bottom"));
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
		nvram_set("hnap_force_to_dial","");	
        }
#endif                                                                                                                             
        close(s);
        dprintf("done session %d\n",num);
        return;
}
                                                                                                                             
//=====================================================================================================

#ifdef L2TP_SUPPORT
int
start_l2tp(int status)
{
	int ret;
	FILE *fp;
	char *l2tp_argv[] = { "l2tpd",
			      NULL
	};
	char l2tpctrl[64];
	char username[80],passwd[80];

	//stop_dhcpc();
	stop_pppoe();
	stop_pptp();

	if(nvram_match("aol_block_traffic","0")){
		snprintf(username, sizeof(username), "%s", nvram_safe_get("ppp_username"));
		snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("ppp_passwd"));
	}
	else{
		if(!strcmp(nvram_safe_get("aol_username"),"")){
			snprintf(username, sizeof(username), "%s", nvram_safe_get("ppp_username"));
			snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("ppp_passwd"));
		}
		else{
			snprintf(username, sizeof(username), "%s", nvram_safe_get("aol_username"));
			snprintf(passwd, sizeof(passwd), "%s", nvram_safe_get("aol_passwd"));
		}		
	}

	if(status != REDIAL){
		mkdir("/tmp/ppp", 0777);
		symlink("/sbin/rc", "/tmp/ppp/ip-up");
		symlink("/sbin/rc", "/tmp/ppp/ip-down");
		symlink("/dev/null", "/tmp/ppp/connect-errors");

                /* Generate L2TP configuration file */
                if (!(fp = fopen("/tmp/l2tp.conf", "w"))) {
                        perror("/tmp/l2tp.conf");
                        return -1;
                }
                fprintf(fp, "global\n");			// Global section
                fprintf(fp, "load-handler \"sync-pppd.so\"\n");	// Load handlers
                fprintf(fp, "load-handler \"cmd.so\"\n");
                fprintf(fp, "listen-port 1701\n");		// Bind address
                fprintf(fp, "section sync-pppd\n");		// Configure the sync-pppd handler
                fprintf(fp, "section peer\n");			// Peer section
                fprintf(fp, "peer %s\n", nvram_safe_get("l2tp_server_ip"));
                fprintf(fp, "port 1701\n");
                fprintf(fp, "lac-handler sync-pppd\n");
                fprintf(fp, "section cmd\n");			// Configure the cmd handler
       		fclose(fp);

		/* Generate options file */
	       	if (!(fp = fopen("/tmp/ppp/options", "w"))) {
       	        	perror("/tmp/ppp/options");
       	        	return -1;
	       	}
	       	fprintf(fp, "defaultroute\n");  //Add a default route to the system routing tables, using the peer as the gateway
      	 	fprintf(fp, "usepeerdns\n");    //Ask the peer for up to 2 DNS server addresses
       		//fprintf(fp, "pty 'pptp %s --nolaunchpppd'\n",nvram_safe_get("pptp_server_ip")); 
       		fprintf(fp, "user '%s'\n",username);
       		//fprintf(fp, "persist\n");        // Do not exit after a connection is terminated.

       		fprintf(fp, "mtu %s\n",nvram_safe_get("wan_mtu"));
	
		if(nvram_match("ppp_demand", "1")){ //demand mode
       			fprintf(fp, "idle %d\n",nvram_match("ppp_demand", "1") ? atoi(nvram_safe_get("ppp_idletime"))*60 : 0);
       			//fprintf(fp, "demand\n");         // Dial on demand
       			//fprintf(fp, "persist\n");        // Do not exit after a connection is terminated.
	       		//fprintf(fp, "%s:%s\n",PPP_PSEUDO_IP,PPP_PSEUDO_GW);   // <local IP>:<remote IP>
       			fprintf(fp, "ipcp-accept-remote\n");        
       			fprintf(fp, "ipcp-accept-local\n");        
       			fprintf(fp, "connect true\n"); 
       			fprintf(fp, "noipdefault\n");          // Disables  the  default  behaviour when no local IP address is specified
       			fprintf(fp, "ktune\n");         // Set /proc/sys/net/ipv4/ip_dynaddr to 1 in demand mode if the local address changes
		}
		else{	// keepalive mode
			start_redial();
		}

    	  	fprintf(fp, "default-asyncmap\n"); // Disable  asyncmap  negotiation
		fprintf(fp, "nopcomp\n");	// Disable protocol field compression
		fprintf(fp, "noaccomp\n");	// Disable Address/Control compression 
       		fprintf(fp, "noccp\n");         // Disable CCP (Compression Control Protocol)
       		fprintf(fp, "novj\n");          // Disable Van Jacobson style TCP/IP header compression
       		fprintf(fp, "nobsdcomp\n");     // Disables BSD-Compress  compression
       		fprintf(fp, "nodeflate\n");     // Disables Deflate compression
		fprintf(fp, "lcp-echo-interval 30\n");     // Don't send an LCP echo-request frame to the peer
       		fprintf(fp, "lock\n");
       		fprintf(fp, "noauth");
	
       		fclose(fp);

       		/* Generate pap-secrets file */
       		if (!(fp = fopen("/tmp/ppp/pap-secrets", "w"))) {
       	        	perror("/tmp/ppp/pap-secrets");
        	       	return -1;
       		}
       		fprintf(fp, "\"%s\" * \"%s\" *\n",
			username,
			passwd);
       		fclose(fp);
		chmod("/tmp/ppp/pap-secrets", 0600);

       		/* Generate chap-secrets file */
       		if (!(fp = fopen("/tmp/ppp/chap-secrets", "w"))) {
        	       	perror("/tmp/ppp/chap-secrets");
               		return -1;
       		}
       		fprintf(fp, "\"%s\" * \"%s\" *\n",
			username,
			passwd);
       		fclose(fp);
		chmod("/tmp/ppp/chap-secrets", 0600);

		/* Enable Forwarding */
		if ((fp = fopen("/proc/sys/net/ipv4/ip_forward", "r+"))) {
			fputc('1', fp);
			fclose(fp);
		} else
			perror("/proc/sys/net/ipv4/ip_forward");
	}
	
	/* Bring up  WAN interface */
	//ifconfig(nvram_safe_get("wan_ifname"), IFUP,
	//	 nvram_safe_get("wan_ipaddr"), nvram_safe_get("wan_netmask"));

	ret = _eval(l2tp_argv, NULL, 0, NULL);
	sleep(1);
	snprintf(l2tpctrl, sizeof(l2tpctrl), "/usr/sbin/l2tp-control \"start-session %s\"", nvram_safe_get("l2tp_server_ip"));
	//system(l2tpctrl);
	
	if (nvram_match("ppp_demand", "1")){
		/* Trigger Connect On Demand if user press Connect button in Status page */
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
		if(nvram_match("action_service","start_l2tp") || nvram_match("hnap_force_to_dial","1")){
			//force_to_dial();
			force_to_dial(nvram_safe_get("action_service"));
			nvram_set("action_service","");
	//modified by michael to fixed the hnap renew_wan_connection can't connected in DOC mode at 20090225
			nvram_set("hnap_force_to_dial","");	
		}
		/* Trigger Connect On Demand if user ping pptp server */
		else
			eval("listen", nvram_safe_get("lan_ifname"));
	}
	else
		system(l2tpctrl);

	dprintf("done\n");
	return ret;
}

int
stop_l2tp(void)
{
	int ret;
	int j;
	char sigusr[] = "-XX";

	unlink("/tmp/ppp/link");
	/*Taide add to fix RDQA bug 0024857  ----2010_9_23--begin*/
	ret = eval("killall", "-15","pppd");	// Send PPP Termination Request
	for(j=0;j < 2;j++)
	{			
		usleep(150000);		
	}
        ret = eval("killall","-9","pppd");		
	sprintf(sigusr, "-%d", SIGTERM);		
	eval("killall", sigusr, "l2tpd");		
		
	for(j=0;j < 2;j++)
	{			
		usleep(200000);		
	}
        
	/*end by Taide--------------------------------------*/
        ret += eval("killall","-9","l2tpd");
        ret += eval("killall","-9","listen");

	dprintf("done\n");
	return ret ;
}
#endif

#ifdef IGMP_X_MLD_SUPPORT
int
start_mld_proxy(void)
{
	int ret = 0;
	char *mld_proxy_argv[] = { "igmpxmld",
		"-v",
		"-b",
		"-u", nvram_safe_get("wan_ifname"),
		"-d", nvram_safe_get("lan_ifname"),
		"-q", "0",
		"-m", "6to6",
		NULL
	};

	if(nvram_match("ipv6_multicast_pass", "1")) {
		ret = _eval(mld_proxy_argv, NULL, 0, NULL);
	}

	if(nvram_match("ipv6_multicast_pass", "1"))
	{
		system("/usr/bin/brcm53115_util arl write 0 333300000001 1 1 0 0 286"); // ff02::1 can sent to WAN port
		system("/usr/bin/brcm53115_util arl write 0 333300000002 1 1 0 0 288"); // ff02::2 can sent to WAN port
		system("/usr/bin/brcm53115_util arl write 0 333300000016 1 1 0 0 318"); // ff02::16 can sent to WAN and LAN ports
	}

	return ret;
}

int
stop_mld_proxy(void)
{
	int ret;

	ret = eval("killall", "igmpxmld");
	return ret;
}
#endif /*IGMP_X_MLD_SUPPORT*/

#ifdef MULTICAST_SUPPORT
int
start_igmp_proxy(void)
{
#ifndef IGMP_SNOOP_SUPPORT 
	int ret = 0;
	char *igmp_proxy_argv[] = { "igmprt",
				    "-f",
				    "-i", nvram_safe_get("wan_iface"),
				    NULL
	};

	if (nvram_match("multicast_pass", "1"))
		ret = _eval(igmp_proxy_argv, NULL, 0, NULL); 

	dprintf("done\n");
	return ret;
#else
	int ret = 0;
	if (nvram_match("multicast_pass", "1"))
	{
		char buf[64],tmp[6];

		memset(tmp,0,6);
		memset(buf,64,0);
		/*@.@ Support IGMP_Snooping Join Lan/WLan interface*/
		strncpy(tmp,nvram_get("lan_ifnames"),5);/*here eth0 eth1 ....etc, we will capture first name*/
		sprintf(buf,"ifconfig %s:0 127.0.0.2 netmask 255.255.255.255\n",tmp);/*Lan*/
		/*eval("ifconfig","eth0:0","127.0.0.2","netmask","255.255.255.255"); */
		system(buf);
		memset(buf,0,64);
		sprintf(buf,"ifconfig %s:0 127.0.0.3 netmask 255.255.255.255\n", nvram_get("wl0_ifname"));/*WLan*/
		/*eval("ifconfig","eth2:0","127.0.0.3","netmask","255.255.255.255"); */
		system(buf);
#ifdef SIMUL_DUAL_BAND_SUPPORT
		memset(buf,0,64);
		sprintf(buf,"ifconfig %s:0 127.0.0.4 netmask 255.255.255.255\n", nvram_get("wl1_ifname"));/*WLan*/
		/*eval("ifconfig","eth2:0","127.0.0.3","netmask","255.255.255.255"); */
		system(buf);
#endif
		memset(buf,0,64);
		sprintf(buf,"igmprt -f -i %s",nvram_get("wan_iface"));
		sleep(3); /*why to do? if none waitting . the next time initial,DUI will crash.
TODO:Waitting kernel free cache memory function*/
		system(buf);
	}
	dprintf("done\n");
	return ret;

#endif
}

int
stop_igmp_proxy(void)
{
	int ret = eval("killall","igmprt");

	dprintf("done\n");
	return ret ;
}
#endif

#ifdef PARENTAL_CONTROL_SUPPORT
int
start_parental_control(void)
{
	int ret = 0;
	struct stat buf;

	if(nvram_match("artemis_enable", "1")){
		char *argv[] = { "artemis", 
#if LOCALE != EUROPE
				 "-i", nvram_safe_get("wan_ifname"), 	// For get MAC
#endif
				 "-L", nvram_safe_get("lan_ifname"),	// For get MAC & IP Address
				 "-W", nvram_safe_get("wan_iface"), 	// For get IP address
				 NULL };
		pid_t pid;
		if ( nvram_match("artemis_provisioned","1")  ) {
			/* Create directory */
        		if( stat("/var/artemis", &buf) != 0 )
                		mkdir("/var/artemis", 0700);
			nvram2file("artemis_SVCGLOB","/var/artemis/SVCGLOB");
			nvram2file("artemis_HB_DB","/var/artemis/HB_DB");
			nvram2file("artemis_GLOB","/var/artemis/GLOB");
                        nvram2file("artemis_NOS_CTR","/var/artemis/NOS_CTR");
		}
		ret = _eval(argv, "/dev/console", 0, &pid);	// To avoid signal fail
		//ret = eval("artemis");
	}
	
	dprintf("done\n");
	return ret ;
}

int
stop_parental_control(void)
{
	int ret;

	ret = eval("killall","artemis");
	ret = eval("killall","artmain");

	dprintf("done");
	return ret;
}
#endif
#ifdef SNMP_SUPPORT
//----------------- for snmp ----------------------------	
int
start_snmp(void)
{
	int ret = 0;
	pid_t pid;
	char *snmpd_argv[] = { "snmpd",
				"-c","/tmp/snmpd.conf",	// chroot to /tmp
			      NULL
	};
        eval("gen_snmpd_conf");
	ret = _eval(snmpd_argv, NULL, 0, &pid); 

	dprintf("done\n");
	return ret;

}

int 
stop_snmp(void)
{
	int ret;

        ret = eval("killall","-9","snmpd");

	dprintf("done\n");
	return ret ;
}
// ---------------- for snmp <----------------------
#endif

#ifdef LLTD_SUPPORT
int
start_lltd(void)
{

	
	if (nvram_match("lltd_enable", "1")) {
		char buf[256];
		sprintf(buf, "echo %s > /proc/sys/kernel/hostname", nvram_safe_get("machine_name"));
		system(buf);
		fprintf(stderr,"lltd:%s \n" ,buf);
		
		sprintf(buf, "/usr/sbin/lld2d %s", nvram_safe_get("lan_ifname") );
		system(buf);
	}

	return 0;
}

int
stop_lltd(void)
{
	int ret = 0;

	ret = eval("killall", "lld2d");

	dprintf("done\n");
	return ret;
}
#endif


#ifdef PPPOE_SERVER_SUPPORT
int
start_pppoe_server(void)
{
	FILE *fp;
	pid_t pid;

	mkdir("/tmp/ppp/", 0777);

       	if (!(fp = fopen("/tmp/ppp/pppoe-server-options", "w"))) {
		perror("/tmp/ppp/pppoe-server-options");
		return -1;
	}
	fprintf(fp, "require-pap\n");
	fprintf(fp, "mtu %s\n", nvram_safe_get("wan_mtu"));

	fclose(fp);

	/* Generate pap-secrets file */
	if (!(fp = fopen("/tmp/ppp/pap-secrets", "w"))) {
		perror("/tmp/ppp/pap-secrets");
		return -1;
	}
	fprintf(fp, "\"%s\" * \"%s\" *\n", "honor", "123456");
	fclose(fp);

	/* Generate chap-secrets file */
	if (!(fp = fopen("/tmp/ppp/chap-secrets", "w"))) {
		perror("/tmp/ppp/chap-secrets");
		return -1;
	}
	fprintf(fp, "\"%s\" * \"%s\" *\n", "honor", "123456");
	fclose(fp);

	char *pppoe_argv[] = { "pppoe-server",
			       "-I", nvram_safe_get("lan_ifname"),
			       "-C", MODEL_NAME,
			       NULL
	};

	if(nvram_match("pppoe_server", "enable"))
		_eval(pppoe_argv, NULL, 0, &pid);
}

int
stop_pppoe_server(void)
{
	int ret;

	ret = eval("killall", "-9", "pppoe-server");

	dprintf("done\n");
	return ret;
}
#endif

#ifdef PPPOE_RELAY_SUPPORT
int
start_pppoe_relay(void)
{
	pid_t pid;
	char *pppoe_argv[] = { "pppoe-relay",
			       "-S", nvram_safe_get("wan_ifname"),
			       "-C", nvram_safe_get("lan_ifname"),
			       NULL
	};

	if(nvram_match("pppoe_pass", "1")){
		_eval(pppoe_argv, NULL, 0, &pid);
	}
	
}

int
stop_pppoe_relay(void)
{
	int ret;

	ret = eval("killall", "-9", "pppoe-relay");

cprintf("tallest:=====( stop pppoe relay !! )=====\n");
	dprintf("done\n");
	return ret;
}
#endif

#ifdef HSIAB_SUPPORT
int
start_hsiabd(void)
{
	int ret=0;
	
	mkdir("/tmp/hsiab", 0777);
	init_hsiabd();	
	
	if(nvram_match("hsiab_mode","1")){
		char *argv[] = { "hsiabd", NULL };
                pid_t pid;
		nvram_set("hsiab_admin_key","");
		ret = _eval(argv, "/dev/console", 0, &pid);
	}
	
	dprintf("done\n");
	return ret;
}

int
stop_hsiabd(void)
{
	int ret = 0;
	FILE *fp;
	
	//stop_configmon();
	//stop_statsmon();
	//stop_hsiabsys();

	if((fp = fopen("/var/run/hsiabd.pid", "r"))){
       		fclose(fp);
		eval("killall", "hsiabd");
		sleep(5);	// We must wait
	}

	if(nvram_match("hsiab_mode", "0")){
		eval("killall", "-9", "hsiabd");
	}
	
	dprintf("done\n");
	return ret;
}
#endif

/* -- begin wuzhihua add ftp firewall rule if remote ftp access enabled 2009.3.17-- */
static
void
add_remoteftp_rule(void)
{
	int ftp_port;
	char rule[256];
	char wanaddr[]="xxx.xxx.xxx.xxx";

	if (!(nvram_match("ftp_enable", "1") && nvram_invmatch("ftp_port", "") && nvram_match("remote_ftp", "1")))
		return ;

	if (nvram_match("wan_proto", "pptp"))
		strncpy(wanaddr, nvram_safe_get("pptp_get_ip"), sizeof(wanaddr));
	#ifdef L2TP_SUPPORT
    	else if (nvram_match("wan_proto", "l2tp"))
        	strncpy(wanaddr, nvram_safe_get("l2tp_get_ip"), sizeof(wanaddr));
	#endif
    	else
		strncpy(wanaddr, nvram_safe_get("wan_ipaddr"), sizeof(wanaddr));

    	if (nvram_match("wan_proto", "pptp") || nvram_match("wan_proto", "l2tp"))
    	{
		/*
		 * If wanaddr is NUL that means ppp connection is down and vlan2 has
		 * got a dynamic IP address, so we just use vlan2 ip as wanaddr
		 */
		if(wanaddr[0]=='\0')
			strncpy(wanaddr, nvram_safe_get("wan_ipaddr"), sizeof(wanaddr));
        }

	if(wanaddr[0]=='\0' || strcmp(wanaddr, "0.0.0.0")==0) return ;

	ftp_port = atoi(nvram_safe_get("ftp_port"));
	sprintf(rule, "iptables -t nat -I PREROUTING -p tcp -m tcp -d %s --dport %d -j ACCEPT", wanaddr, ftp_port);
	system(rule);

	return ;
}

static
void
del_remoteftp_rule(void)
{
	int ftp_port;
	char rule[256];
	char wanaddr[]="xxx.xxx.xxx.xxx";

	if (!(nvram_match("ftp_enable", "1") && nvram_invmatch("ftp_port", "") && nvram_match("remote_ftp", "1")))
		return ;

	if (nvram_match("wan_proto", "pptp"))
		strncpy(wanaddr, nvram_safe_get("pptp_get_ip"), sizeof(wanaddr));
	#ifdef L2TP_SUPPORT
    	else if (nvram_match("wan_proto", "l2tp"))
        	strncpy(wanaddr, nvram_safe_get("l2tp_get_ip"), sizeof(wanaddr));
	#endif
    	else
		strncpy(wanaddr, nvram_safe_get("wan_ipaddr"), sizeof(wanaddr));

    	if (nvram_match("wan_proto", "pptp") || nvram_match("wan_proto", "l2tp"))
    	{
		/*
		 * If wanaddr is NUL that means ppp connection is down and vlan2 has
		 * got a dynamic IP address, so we just use vlan2 ip as wanaddr
		 */
		if(wanaddr[0]=='\0')
			strncpy(wanaddr, nvram_safe_get("wan_ipaddr"), sizeof(wanaddr));
        }

	if(wanaddr[0]=='\0' || strcmp(wanaddr, "0.0.0.0")==0) return ;

	ftp_port = atoi(nvram_safe_get("ftp_port"));
	sprintf(rule, "iptables -t nat -D PREROUTING -p tcp -m tcp -d %s --dport %d -j ACCEPT", wanaddr, ftp_port);
	system(rule);

	return ;
}
/* -- end   wuzhihua add ftp firewall rule if remote ftp access enabled 2009.3.17-- */

#ifdef FTP_SUPPORT
#ifdef VSFTPD_SUPPORT
int
start_ftp(void)
{
	int value;
	FILE *fp;
	pid_t pid;
	char string[80]="";
	//remove the inetd by michael at 20081208
//	char *argv[] = {"inetd", NULL };
	char *argv[] = {"usr/sbin/vsftpd", NULL };
	int ret=0;

	//wuzhihua add for ftp priority issue
	if(strcmp(nvram_safe_get("partition_name_0"), "")==0) {
		printf("Disk disconnected, dont start ftp server\n");
		return 0;
	}

	if (nvram_match("ftp_enable","1"))
	{
		if (strcmp(nvram_safe_get("ftp_port"), "") == 0 || strcmp(nvram_safe_get("ftp_share_folder"), "") == 0 || strcmp(nvram_safe_get("ftp_share_access"), "") == 0)
		{
			nvram_set("ftp_port", "21");
			nvram_set("ftp_all", "1");
			nvram_set("ftp_share_folder", "/");
			nvram_set("ftp_share_access", "1:admin:rw");
		}
		if(chdir("/var/empty")!=0)
			value = eval("mkdir", "/var/empty");
		chdir("/");
		//remove the inetd by michael at 20081208
		//ret = _eval(argv, ">/dev/console", 0, &pid);
		if (write_ftp_conf_user() >= 0)
		{
			printf("ftp start ok\n");
			//add by michael to fix the ftp port can't be change to another one at 20081208
			if(write_vsftpd_conf() >0){
				ret = _eval(argv, ">/dev/console", 0, &pid);
				//wuzh add 2009.3.17
				add_remoteftp_rule();
			}
			else 
				return -1;
		}
		else
			return -1;
	}
	dprintf("done\n");
	return ret;

}
int stop_ftp(void)
{
	int ret;
	FILE *fp;
				
	//wuzh add 2009.3.17
	del_remoteftp_rule();
	//ret = eval("killall","-9","inetd");
	ret = eval("killall","-9","vsftpd");
	printf("do not work\n");
	if(!chdir("/tmp/ftproot/"))
	{
		if((fp = popen("/bin/ls -1", "r")))
		{
			char line[32];
			while(fgets(line, sizeof(line), fp)!= NULL)
			{
				char homedir[32];
				int last_char = strlen(line);
				line[last_char-1] = '\0';
				printf("liyi debug line == %s\n", line);
				memset(homedir, 0, sizeof(homedir));
				sprintf(homedir, "/tmp/ftproot/%s/",line);
				printf("homedir == %s\n", homedir);
				if(!chdir(homedir))
				{
					printf("Umounting FTP mounted dirs\n");
					system("if [ \"`ls`\" != \"\" ]; then /bin/ls | xargs umount ; fi");
				}
			}
			pclose(fp);
			sleep(1);
			chdir("/tmp/");
			system("/bin/rm /tmp/ftproot/*  -rf");
		}
	}	
	else
	{
		printf("Enter into FTP root dir fail!It's not exist.\n");
	}

	dprintf("done\n");
	return ret;
}

//add by michael to fix the ftp port can't be change to another one at 20081208
static int write_vsftpd_conf()
{
	FILE *fp = NULL;
	char tmp[3000];
	char buf[55];
	int ret = -1;

	memset(tmp,'\0',sizeof(tmp));	

	if((fp = fopen("/etc/vsftpd.conf","r")) == NULL)
		return -1;

	while(!feof(fp))
	{
		memset(buf,0,sizeof(buf));	
		fgets(buf,sizeof(buf),fp);
		buf[strlen(buf)] = '\0';	
		//Jemmy Fixed issue IR-B0013168
		if(strstr(buf,"ftpd_banner") != 0)
		{
#if ((LINKSYS_MODEL == E300) || (LINKSYS_MODEL == E3200) || (LINKSYS_MODEL == E4200))
			snprintf(buf,sizeof(buf),"ftpd_banner=Welcome to %s's FTP service\n",nvram_safe_get("ftp_server_name"));
#else
			snprintf(buf,sizeof(buf),"ftpd_banner=Welcome to WRT610N Router's FTP service\n");
#endif
		}

		if(strstr(buf,"listen_port") != 0)
			snprintf(buf,sizeof(buf),"listen_port=%s\n",nvram_safe_get("ftp_port"));
		//add by hyw to support charset at 20090821
		if(strstr(buf,"ftp_characterset") != 0)
			snprintf(buf,sizeof(buf),"ftp_characterset=%s\n",nvram_safe_get("ftp_characterset"));
		strcat(tmp,buf);
	}
	fclose(fp);

	if((fp = fopen("/tmp/vsftpd.conf","w")) == NULL)
		return -1;

	ret = fwrite(tmp,strlen(tmp),1,fp);
	fflush(fp);
	fclose(fp);

	return ret;

}
//end by michael

static int write_ftp_conf_user()
{
	char var[1024], buf[4096], *next;
	FILE *fp;
	struct stat fs;
	int FS_scan_folder_num = 0;
	char FS_scan_folder_num_char[4];
	int folder_num = 0;


	for(folder_num=0; folder_num<11; folder_num++)
	{
		char ftp_share_access_Num[25];
		sprintf(ftp_share_access_Num, "ftp_share_access_%d", folder_num);
		if(!strcmp(nvram_safe_get(ftp_share_access_Num),""))
		{
			continue;
		}
		FS_scan_folder_num++;
	}
	sprintf(FS_scan_folder_num_char, "%d", FS_scan_folder_num);
	nvram_set("FS_scan_folder_num", FS_scan_folder_num_char);
#if 0
	if (stat("/tmp/passwd", &fs) != 0)
		add_accounts();
#endif
	if (!(fp = fopen("/var/logins.txt", "w")))
	{
		perror("/var/logins.txt");
	}

	//Jemmy add for anonymous access ftp 2010.08.24
	if (nvram_match("anonymous_ftp", "1"))
	{
		int i;
		char partition_name[32], share_name[256], ftp_share_path[64];	
		char cmd[128];
		struct stat aftp;

		fprintf(fp, "%s\n", "anonymous");
		fprintf(fp, "%s\n", "anonymous");		
		if(stat("/tmp/ftproot", &buf) != 0 )
		{
			system("/bin/mkdir -m 775 /tmp/ftproot");
		}
		
		sprintf(cmd, "/bin/mkdir -m 555 /tmp/ftproot/anonymous");
		system(cmd);

		eval("adduser", "-p", "anonymous", "anonymous", "-g", "guest", "-h", "/tmp/ftproot/anonymous");
		
		sprintf(cmd,"passwd -m anonymous");
		system(cmd);

		sprintf(cmd, "/bin/chmod 555 /tmp/ftproot/anonymous");
		system(cmd);

		//chdir("/tmp/ftproot/anonymous");
		for(i= 0; i< 11; i ++ )
		{
			char ftp_share_name[20];
			char ftp_share_path[600];
			char disk_mount_path[600];
			char ftp_share_folder[512];

			memset(ftp_share_name, 0, sizeof(ftp_share_name));	
			memset(ftp_share_path, 0, sizeof(ftp_share_path));
			memset(ftp_share_folder, 0, sizeof(ftp_share_folder));
			memset(disk_mount_path, 0, sizeof(disk_mount_path));

			sprintf(ftp_share_name, "ftp_share_name_%d", i);
			
			if (nvram_match(ftp_share_name, "")) continue;

			sprintf(ftp_share_path, "/tmp/ftproot/anonymous/%s", nvram_safe_get(ftp_share_name));
			printf("create anonymous share %d  == %s\n", i, ftp_share_path);

			if(stat(ftp_share_path, &aftp) != 0 )
			{
				eval("/bin/mkdir","-m","775", ftp_share_path);
			}
				
			sprintf(ftp_share_folder, "ftp_share_folder_%d", i);
			if (strcmp(nvram_safe_get(ftp_share_folder), "/") == 0)
			{
				printf("no mount disk folder\n");
			}
			else
			{
				//char cmdline[256];
				sprintf(disk_mount_path, "/foreign_shares%s", nvram_safe_get(ftp_share_folder));
				eval("/bin/mount","-o","umask=002", disk_mount_path, ftp_share_path,"-o","bind");
			}
		}

	}

	strncpy(buf, nvram_safe_get("ftp_homeuser_dir"), sizeof(buf));
	if(!strcmp(buf, ""))
	{
		printf("ftp_homeuser_dir is NULL\n");
		return -1;
	}
	foreach(var, buf, next)
	{
		int dirnum = 0;
		char path[64];
		char user_info_buf[512];
		char *basic_info[20];

		struct stat buf;

		memset(user_info_buf, 0, sizeof(user_info_buf));
		strcpy(user_info_buf, var);

		basic_info[0] = strtok(user_info_buf, ":");
		dirnum = dirnum + 1;
		while(1)
		{
			basic_info[dirnum] = strtok(NULL, ":");
			if(!basic_info[dirnum])
			{
				dirnum = dirnum -1 ;
				break;
			}
			dirnum = dirnum + 1;
		}
//add by michael to translate the pw before adding user at 20090807
		char new_passwd[128];
		memset(new_passwd,0,sizeof(new_passwd));
		filter_name(basic_info[1],new_passwd,sizeof(new_passwd),GET);
		fprintf(fp, "%s\n", basic_info[0]);
		//fprintf(fp, "%s\n", basic_info[1]);
		fprintf(fp, "%s\n", new_passwd);
		sprintf(path, "/tmp/ftproot/%s", basic_info[0]);
		if(stat("/tmp/ftproot", &buf) != 0 )
		{
			system("/bin/mkdir -m 775 /tmp/ftproot");
		}
		{
			char cmd[128];
			sprintf(cmd, "/bin/mkdir -m 555 %s", path);
			system(cmd);
		}
		if ( basic_info[0] && basic_info[1] )
		{
			if(!strncmp(basic_info[dirnum], "rw", 2))
//add by michael to translate the pw before adding user at 20090807
				//eval("adduser", "-p", basic_info[0], basic_info[1], "-g", "root", "-h",path);
				eval("adduser", "-p", basic_info[0], new_passwd, "-g", "root", "-G","root","-h",path);
			else if(!strncmp(basic_info[dirnum], "r", 1))
				//eval("adduser", "-p", basic_info[0], basic_info[1], "-g", basic_info[2], "-h",path);
				eval("adduser", "-p", basic_info[0], new_passwd, "-g", basic_info[2], "-h",path);
			else
				//eval("adduser", "-p", basic_info[0], basic_info[1]);
				eval("adduser", "-p", basic_info[0], new_passwd);
			if(!strcmp(basic_info[0],"guest"))
			{
				char cmd_tmp[100];
				memset(cmd_tmp,0,sizeof(cmd_tmp));
				sprintf(cmd_tmp,"passwd -m %s",basic_info[0]);
				system(cmd_tmp);
			}
			{
				char cmd[128];
				sprintf(cmd, "/bin/chmod 555 %s", path);
				system(cmd);
			}
			if(strcmp(basic_info[0],"guest"))
#ifdef SMB302_SUPPORT
				//eval("/usr/local/samba/bin/smbpasswd", "-a", basic_info[0], basic_info[1]);
				eval("/usr/local/samba/bin/smbpasswd", "-a", basic_info[0], new_passwd);
#endif
#if defined( SMB3025_SUPPORT ) || defined( SMB3215_SUPPORT )
				//eval("/usr/local/samba/bin/smbadduser", basic_info[0], basic_info[1]);
				eval("/usr/local/samba/bin/smbadduser", basic_info[0], new_passwd);
//end by michael
#endif
		}
		chdir(path);
		{
			int user_dir_num = 3;
			for(user_dir_num = 3 ;user_dir_num< dirnum; user_dir_num++)
			{
				if(basic_info[user_dir_num])
				{
					//add by michael to fix the ftp can't be use when ftp share name contain space at 20090214
					char share_name_tmp[257];
					memset(share_name_tmp,0,sizeof(share_name_tmp));
					filter_name(basic_info[user_dir_num],share_name_tmp,sizeof(share_name_tmp),GET);	
					//if(stat(basic_info[user_dir_num], &buf) != 0 )
					if(stat(share_name_tmp, &buf) != 0 )
					{
					#if 0
						{
							char cmd[128];
							sprintf(cmd, "/bin/mkdir -m 775 %s", basic_info[user_dir_num]);
							system(cmd);
						}
					#else
						eval("/bin/mkdir","-m","775",share_name_tmp);	
					#endif
					//end by michael
					}
					{
						int i = 0;
						for(i= 0; i< 11; i ++ )
						{
							char ftp_share_name[20];
							char ftp_share_name_content[32];
							memset(ftp_share_name,0,sizeof(ftp_share_name));
							sprintf(ftp_share_name, "ftp_share_name_%d", i);
							memset(ftp_share_name_content, 0, sizeof(ftp_share_name_content));
							strcpy(ftp_share_name_content, nvram_safe_get(ftp_share_name));
							printf("content == %s\n",ftp_share_name_content);
							printf("basic_info == %s\n",basic_info[user_dir_num]);
						//add by michael to fix the ftp can't be use when ftp share name contain space at 20090214
							//if(!strcmp(ftp_share_name_content, basic_info[user_dir_num]))
							if(!strcmp(ftp_share_name_content, share_name_tmp))	
							{
								char current_ftp_share_full_folder_buf[512];
								char current_ftp_share_folder[30]="";
								sprintf(current_ftp_share_folder, "ftp_share_folder_%d", i);

								if (strcmp(nvram_safe_get(current_ftp_share_folder), "/") == 0)
								{
									printf("no mount disk folder\n");
								}
								else
								{
									//char cmdline[256];
									sprintf(current_ftp_share_full_folder_buf, "/foreign_shares%s", nvram_safe_get(current_ftp_share_folder));
									//sprintf(cmdline, "/bin/mount -o umask=002 %s %s -o bind",current_ftp_share_full_folder_buf, basic_info[user_dir_num]);
									//eval("/bin/mount","-o","umask=002",current_ftp_share_full_folder_buf, basic_info[user_dir_num],"-o","bind");
									eval("/bin/mount","-o","umask=002",current_ftp_share_full_folder_buf, share_name_tmp,"-o","bind");
									//printf("cmdline== %s\n",cmdline);
									//system(cmdline);
									//eval("/bin/mount","-o umask=002", current_ftp_share_full_folder_buf, basic_info[user_dir_num],"-o","bind");
								}
								break;
							}
							else
								continue;
						}
					}
				}
				else
					break;
			}
		}
		chdir("/");
	}
	fclose(fp);
	return 0;
}
#endif

#ifdef PROFTPD_SUPPORT
int start_ftp(void)
{
	FILE *fp;

	//wuzhihua add for ftp priority issue
	if(strcmp(nvram_safe_get("partition_name_0"), "")==0) {
		printf("Disk disconnected, dont start ftp server\n");
		return 0;
	}

	if (nvram_match("ftp_enable","1")) {
		if (strcmp(nvram_safe_get("ftp_port"), "") == 0 || strcmp(nvram_safe_get("ftp_share_folder"), "") == 0 || strcmp(nvram_safe_get("ftp_share_access"), "") == 0) {
			nvram_set("ftp_port", "21");
			nvram_set("ftp_all", "1");
			nvram_set("ftp_share_folder", "/");
			nvram_set("ftp_share_access", "1:admin:rw");
		}

		if (write_ftp_conf("/tmp/proftpd.conf") >= 0) {
			eval("mkdir", "-p", "/tmp/proftpd/var/proftpd");
			fp = fopen("/tmp/proftpd/var/proftpd/proftpd.delay", "w");
			if (fp == NULL) {
				perror("ftp: proftpd.delay");
				return -1;
			}
			else{
				eval("proftpd", "-c", "/tmp/proftpd.conf");
				//wuzh add 2009.3.17
				add_remoteftp_rule();
			    }
		}
		else
			return -1;
	}

	
	dprintf("done\n");
	return 0;
}
int stop_ftp(void)
{
	//wuzh add 2009.3.17
	del_remoteftp_rule();
	eval("killall", "-9", "proftpd");
//	system("cd /tmp/ftproot");
	if(!chdir("/tmp/ftproot"))
	{
		printf("Umounting FTP mounted dirs\n");
		//system("/bin/ls | xargs umount");
		system("if [ \"`ls`\" != \"\" ]; then /bin/ls | xargs umount ; fi");
		sleep(1);
		system("/bin/rmdir /tmp/ftproot/*");
	}	
	else
	{
		printf("Enter into FTP root dir fail!It's not exist.\n");
	}
	dprintf("done\n");
	return 0;
}


static int write_ftp_conf(const char *file_name)
{
	int i, j, same_name = 0, guest_account_write = 0, guest_account_read = 0;
	struct stat fs;
	FILE *config_fp;
	char *group_num, *group_name, *group_right, *tmp;
	char ftp_read_list[4096], ftp_write_list[4096];
	char ftp_share_access[4096], group_users[4096];
	
	char current_ftp_share_access[30]="", current_ftp_share_folder[30]="";
	char current_ftp_share_full_folder_buf[512];
	char current_ftp_share_name[30]="";
	char ftp_share_name_buf[128];
	int current_ftp_share_num=0;
	int FS_scan_folder_num = 0;
	char FS_scan_folder_num_char[4];


	if (stat("/tmp/passwd", &fs) != 0)
		add_accounts();
	
	eval("/bin/mkdir", "/tmp/ftproot");
	config_fp = fopen(file_name, "w");
	if (config_fp == NULL) {
		fprintf(stderr,	"Error: Could not open FTP configuration file `%s': %s\n",
			file_name, strerror(errno));
		return -1;
	}
	
	fprintf(config_fp,
		"	ServerName	%s\n"
		"	DefaultAddress	%s\n"
		"	ServerType	standalone\n"
		"	Port	%s\n"
		//"	DefaultServer	on\n"
		"	MaxInstances	10\n"
		"	<VirtualHost %s>\n"
		"	PassivePorts	65000 65009\n"
		"	Port	%s\n"
		"	</VirtualHost>\n"
		"	<Global>      \n"
		"	AllowOverwrite	on\n"
		"	Umask	022\n"
//		"	User	guest\n"
//		"	Group	users\n"
		"	User	root\n"
		"	Group	root\n"

#if LINKSYS_MODEL == WRT350N
//		"	<IfModule mod_delay.c>\n"
//		"		DelayEngine off\n"
//		"	</IfModule>\n"
#endif
		//"	AnonymousGroup anonymous\n"
		"	DefaultRoot \"/tmp/ftproot\"\n"
		"	<Limit SITE_CHMOD>\n"
		"		DenyAll\n"
		"	</Limit>\n"
		"	<Limit SITE_UTIME>\n"
		"		AllowAll\n"
		"	</Limit>\n",
	//	"	<Directory />\n"
//		"		<Limit ALL>\n"
//		"            		DenyAll\n"
//		"		</Limit>\n"
//		"	</Directory>\n",
		nvram_safe_get("machine_name"), nvram_safe_get("lan_ipaddr"), nvram_safe_get("ftp_port"), nvram_safe_get("wan_ipaddr"), nvram_safe_get("ftp_port"));

	for(current_ftp_share_num=0; current_ftp_share_num<27; current_ftp_share_num++)
	{
	sprintf(current_ftp_share_access, "ftp_share_access_%d", current_ftp_share_num);
	if(!strcmp(nvram_safe_get(current_ftp_share_access),""))
	{
		continue;
	}
	FS_scan_folder_num++;
	sprintf(current_ftp_share_folder, "ftp_share_folder_%d", current_ftp_share_num);
	sprintf(current_ftp_share_name, "ftp_share_name_%d", current_ftp_share_num);
	strncpy(ftp_share_access, nvram_safe_get(current_ftp_share_access), sizeof(ftp_share_access));
	strncpy(group_users, nvram_safe_get("group_users"), sizeof(group_users));
	tmp = ftp_share_access;
	group_num = strsep(&tmp, ":");
//	strcpy(ftp_write_list, "admin");
	strcpy(ftp_write_list, "");
	strcpy(ftp_read_list, "");

	for (i = 0; i < atoi(group_num); i++) {
		char buf[512], buf2[4096], var[512], var2[512], *next, *next2;
		char *user_group, *user_num, *user_name;

		group_name = strsep(&tmp, ":");
		group_right = strsep(&tmp, ":");
		foreach(var, group_users, next) {
			strcpy(buf, var);
			user_group = strtok(buf, ":");
			user_num = strtok(NULL, ":");
			if (strcmp(group_name, user_group) != 0)
				continue;
			for (j = 0; j < atoi(user_num); j++) {
				user_name = strtok(NULL, ":");
//				if (strcmp(user_name, "admin") == 0)
//					continue;

				strcpy(buf2, "");
				foreach (var2, ftp_read_list, next2) {
					if (strcmp(var2, user_name) == 0) {
						if (strcmp(group_right, "r") == 0 )
							same_name = 1;
						else
							continue;	
					}		 
					if (strcmp(buf2, "") == 0)
						sprintf(buf2, "%s", var2);
					else
						sprintf(buf2, "%s %s", buf2, var2);
				}

				strcpy(ftp_read_list, buf2);
				foreach (var2, ftp_write_list, next2) {
					if (!strcmp(var2, user_name)) {
						same_name = 1;
						break;
					}		 
				}
				if (same_name == 1) {
					same_name = 0;
					//Jemmy fix other users except admin cant't access ftp server 2008.6.20
					//break;
					continue;
				}
				if (!strcmp(group_right, "rw")) {
					if(strcmp(group_name,"admin"))
					{
						if (!strcmp(user_name, "admin"))
						continue;
					}
					if (strcmp(user_name, "guest") == 0)
						guest_account_write = 1;
					if (strcmp(ftp_write_list, "") == 0)
						sprintf(ftp_write_list, "%s", user_name);
					else
						sprintf(ftp_write_list, "%s %s", ftp_write_list, user_name);
				}
				if (strcmp(group_right, "r") == 0) {
					if(strcmp(group_name,"admin"))
					{
						if (!strcmp(user_name, "admin"))
						continue;
					}

					if (strcmp(user_name, "guest") == 0)
						guest_account_read = 1;
					if (strcmp(ftp_read_list, "") == 0)
						sprintf(ftp_read_list, "%s", user_name);
					else 
						sprintf(ftp_read_list, "%s %s", ftp_read_list, user_name);
				}
			}							
		}
	}

	if (strcmp(nvram_safe_get(current_ftp_share_folder), "/") == 0) {
		DIR *dir;
		struct dirent *rdp;
		char dir_path[1024];
		char path_name[1024];
		struct stat ds;
		int dir_count = 0;

		sprintf(path_name, "/tmp/ftproot");
		if ((dir = opendir(path_name)) == NULL) {
			perror("ftp: open dir\n");
			return -1;
		}
		fprintf(config_fp,
			"	<Directory \"/tmp/ftproot/\">\n"
			"		<Limit READ>\n"
			"			AllowUser %s %s\n"
			"		</Limit>\n"
			"		<Limit DIRS>\n"
			"			AllowUser %s %s\n"
			"		</Limit>\n"
			"	</Directory>\n",
			ftp_write_list, ftp_read_list, ftp_write_list, ftp_read_list);
	
		fprintf(config_fp,
			"	<Directory \"/tmp/ftproot/*\">\n"
			"		<Limit WRITE>\n"
			"			AllowUser %s\n"
			"		</Limit>\n"
			"		<Limit READ>\n"
			"			AllowUser %s %s\n"
			"		</Limit>\n"
			"		<Limit DIRS>\n"
			"			AllowUser %s %s\n"
			"		</Limit>\n"
			"	</Directory>\n",
			ftp_write_list, ftp_write_list, ftp_read_list, ftp_write_list, ftp_read_list);

		while ((rdp = readdir(dir)) != NULL) {
			sprintf(dir_path, "%s/%s", path_name, rdp->d_name);
			if ((lstat(dir_path, &ds) == 0) && S_ISDIR(ds.st_mode)) {
				if (strcmp(rdp->d_name, ".") && strcmp(rdp->d_name, "..")) {
					fprintf(config_fp,
						"	<Directory \"%s\">\n"
						"		<Limit WRITE>\n"
						"			AllowUser %s\n"
						"		</Limit>\n"
						"		<Limit READ>\n"
						"			AllowUser %s %s\n"
						"		</Limit>\n"
						"		<Limit DIRS>\n"
						"			AllowUser %s %s\n"
						"		</Limit>\n"
						"	</Directory>\n",
						dir_path, ftp_write_list, ftp_read_list, ftp_write_list, ftp_read_list, ftp_write_list);
					dir_count++;

					if (guest_account_read == 1 || guest_account_write == 1) {

						//eval("tmpuseradd", "anonymous");
						//eval("tmpgroupadd", "anonymous");
						//eval("tmpuseraddgroup", "anonymous", "guest");
						fprintf(config_fp,
							"	<Anonymous \"/tmp/ftproot\">\n"
							"	User guest\n"
							"	Group users\n"
							"	AnonRequirePassword off\n"
							"	UserAlias anonymous guest\n"
							"	<Directory *>\n"
							"		<Limit WRITE>\n"
							"			%sAll\n"
							"		</Limit>\n"
							"		<Limit READ>\n"
							"			AllowAll\n"
							"		</Limit>\n"
							"		<Limit DIRS>\n"
							"			AllowAll\n"
							"		</Limit>\n"
							"	</Directory>\n"
							"	</Anonymous>\n",
							guest_account_write ? "Allow" : "Deny");
					}
				}
			}
		}		
	}
	else {
		//Jemmy fix storage issues : 12569, 12571, 12592, 12593 in 2008.5.20	
			//add by michael to fix ftp can't start if the folder writelist is empty at 20080814
			char write_cmd[4096];	//the same size of ftp_write_list
			char allow_cmd[8192];
			memset(write_cmd,0,sizeof(write_cmd));	
			memset(allow_cmd,0,sizeof(allow_cmd));
			if(!strcmp(ftp_write_list,""))
				strcpy(write_cmd,"DenyAll");
			else
				sprintf(write_cmd,"AllowUser %s",ftp_write_list);

			if(!strcmp(ftp_write_list,"") && !strcmp(ftp_read_list,""))
				strcpy(allow_cmd,"DenyAll");
			else
				sprintf(allow_cmd,"AllowUser %s %s",ftp_read_list,ftp_write_list);
			//end by michael

			guest_account_read =0;
			guest_account_write = 0;
                        fprintf(config_fp,
                        "       <Directory \"/tmp/ftproot/%s\">\n"
                        "               <Limit ALL>\n"
                        "                       DenyAll\n"
                        "               </Limit>\n"
                        "               <Limit DIRS>\n"
                        "                       %s\n"
                        "               </Limit>\n"
                        "       </Directory>\n",
//                        nvram_safe_get(current_ftp_share_name),ftp_read_list, ftp_write_list);
                        nvram_safe_get(current_ftp_share_name),allow_cmd);
 
		fprintf(config_fp,
			"	<Directory \"/tmp/ftproot/%s/*\">\n"	
			"		<Limit ALL>\n"
			"			DenyALL\n"
			"		</Limit>\n"
			"		<Limit WRITE>\n"
			"			%s\n"
			"		</Limit>\n"
			"		<Limit READ>\n"
			"			%s\n"
			"		</Limit>\n"
			"		<Limit DIRS>\n"
			"			%s\n"
			"		</Limit>\n"
			"	</Directory>\n",
	//		nvram_safe_get(current_ftp_share_name), ftp_write_list, ftp_read_list, ftp_write_list, ftp_read_list, ftp_write_list);
			nvram_safe_get(current_ftp_share_name), write_cmd, allow_cmd,allow_cmd);
		if (guest_account_read == 1 || guest_account_write == 1) {

			//eval("tmpuseradd", "anonymous");
			//eval("tmpgroupadd", "anonymous");
			//eval("tmpuseraddgroup", "anonymous", "guest");
			fprintf(config_fp,
				"	<Anonymous \"/tmp/ftproot/%s\">\n"
				"	User guest\n"
				"	Group users\n"
				"	AnonRequirePassword off\n"
				"	UserAlias anonymous guest\n"
				"	<Directory *>\n"
				"		<Limit WRITE>\n"
				"			%sAll\n"
				"		</Limit>\n"
				"		<Limit READ>\n"
				"			AllowAll\n"
				"		</Limit>\n"
				"		<Limit DIRS>\n"
				"			AllowAll\n"
				"		</Limit>\n"
				"	</Directory>\n"
				"	</Anonymous>\n",
				nvram_safe_get(current_ftp_share_name), guest_account_write ? "Allow" : "Deny");
		}
	}

//        nvram_set(ftp_share_access, shared_info);
//        sprintf(ftp_share_folder_buf, "%s", share_path);
        sprintf(ftp_share_name_buf, "/tmp/ftproot/%s", nvram_safe_get(current_ftp_share_name));
        eval("/bin/mkdir", ftp_share_name_buf);
	sprintf(current_ftp_share_full_folder_buf, "/foreign_shares%s", nvram_safe_get(current_ftp_share_folder));
        eval("/bin/mount", current_ftp_share_full_folder_buf, ftp_share_name_buf,"-o","bind");

	}
	fprintf(config_fp, "	</Global>\n");

	fflush(config_fp);
	if (ferror(config_fp)) {
		fclose(config_fp);
		fprintf(stderr,
			"Error: While writing FTP configuration file `%s': %s\n",
			file_name, strerror(errno));
		return -1;
	}
	fclose(config_fp);
	
	sprintf(FS_scan_folder_num_char, "%d", FS_scan_folder_num);
	nvram_set("FS_scan_folder_num", FS_scan_folder_num_char);
	return 0;
}
#endif
#endif


#ifdef MEDIA_SERVER_SUPPORT
int start_media_server(void)
{
	int ret;
	pid_t pid;
	char *MS_name;
//	char *MS_scan_folder;
	FILE *fp;	
	char tmp[512], MS_scan_folder[20];
	int i;
	//char *MS_argv[] = { "/usr/local/upnpmms/upnpmms", NULL};
	//HYW change twonkymedia.db path to USB disk 2010.9.17
        char cdbpath[256];
        sprintf(cdbpath, "/foreign_shares/%s/", nvram_safe_get("partition_name_0"));

	if (strcmp(nvram_safe_get("MServer"), "1") != 0)
		return 0;
	
        //Jemmy add for not start media server when not plug in disk 2010.9.3
        if(strcmp(nvram_safe_get("partition_name_0"), "") == 0) {
                printf("Disk disconnected, don't start Twonky MediaServer\n");
                return 0;
        }

	//HYW change twonkymedia.db path to USB disk 2010.9.17
        //sprintf(tmp,"rm -rf %stwonkymedia.db",cdbpath);
        //printf(tmp);
        //system(tmp);
        //sleep(1);

	if((fp=fopen("/tmp/twonkymedia-default.ini","w")) == NULL)
	{
		printf("Error: Can't write media server config file\n");
	}
	else
	{
		fprintf(fp,"contentbase=\n");
		//HYW change twonkymedia.db path to USB disk 2010.9.17
		//fprintf(fp,"dbdir=/tmp/twonkymedia.db\n");
                fprintf(fp,"dbdir=%stwonkymedia.db\n",cdbpath);
		fprintf(fp,"norescale=1\n");
		fprintf(fp,"maxmem=%d\n", 40800);
		fprintf(fp,"maxitems=80000\n");
		fprintf(fp,"ip=%s\n", nvram_safe_get("lan_ipaddr"));
		fprintf(fp,"enableweb=0\n");
		fprintf(fp,"cachemaxsize=%d\n", 4096);
		fprintf(fp,"friendlyname=%s\n", nvram_safe_get("media_server_name"));	//Alpha Modified 2010-02-10
		fprintf(fp,"followlinks=0\n");
		fprintf(fp,"radio=0\n");
		fprintf(fp,"scantime=0\n");
    		fprintf(fp,"readdbondemand=0\n");
		fprintf(fp,"uploadenabled=0\n");
    		fprintf(fp,"ignoredir=AppleDouble,AppleDB,AppleDesktop,TemporaryItems,twonkymedia.db\n");
	
		fflush(fp);
	fclose(fp);

	}
	
	//YY
/*
	system("/bin/cp /usr/local/TwonkyVision /tmp -a");
	sleep(1);
*/
//	sprintf(tmp, "/tmp/TwonkyVision/twonkymedia -contentdir \"");
	//modified by michael to support writable Server name	
        //sprintf(tmp,"/usr/local/TwonkyVision/twonkymedia -friendlyname %s",nvram_safe_get("machine_name"));
        sprintf(tmp,"/usr/local/TwonkyVision/twonkymedia -friendlyname %s",nvram_safe_get("media_server_name"));
        strcat(tmp," -contentdir \"");	
	//sprintf(tmp, "/usr/local/TwonkyVision/twonkymedia -contentdir \"");
#if 0
//add by michael to fix the media_server all scan can't work at 20080828
	if(nvram_match("scan_all","1"))
	{
		nvram_set("scan_all","0");
		strcat(tmp,"+A|/foreign_shares");
	}
	else
#endif
    {
	int list_empty= 0;

	for (i=0; i<10; i++)
	{
		sprintf(MS_scan_folder, "MS_scan_folder%d", i);
		if(strcmp(nvram_safe_get(MS_scan_folder), ""))
		{
			strcat(tmp, "+A|/foreign_shares");
			strcat(tmp, nvram_safe_get(MS_scan_folder));
			sprintf(MS_scan_folder, "MS_scan_folder%d", i+1);
			if(strcmp(nvram_safe_get(MS_scan_folder), ""))
			{
				strcat(tmp, ",");
			}
			list_empty++;
		}
	}
//fix the media will scan all the disk when datalist is empty at 20080826
	if(list_empty == 0)
		strcat(tmp,"+A|/var/tmp");
    }
//end by michael
	strcat(tmp,"\"");
	if(!strcmp(nvram_safe_get("MS_auto_scan"),"1"))
	{
		//add by michael to turn the hour to minute at 20081024
		char minute[6];
		int tmp_minute;
		tmp_minute = atoi(nvram_safe_get("MS_scan_time")) * 60;
		snprintf(minute,sizeof(minute),"%d",tmp_minute);
		strcat(tmp," -scantime ");
		//strcat(tmp, nvram_safe_get("MS_scan_time"));
		strcat(tmp, minute);
		//end by michael
	}
	else
	{
		strcat(tmp," -scantime -1");
	}
	strcat(tmp," -inifile /tmp/twonkymedia-default.ini");
	strcat(tmp," &");
	//ret = _eval(MS_argv, NULL, 0, &pid); 
	//sleep(1);
	printf("Start media server [%s]\n", tmp);
	system(tmp);
	
	//record the start time to show the last scan time of media server at 20100319
        {
                time_t scan_time = 0;
                char scan_tm[32];
                memset(scan_tm,0,sizeof(scan_tm));
                time_wrap_new(&scan_time);
                snprintf(scan_tm,sizeof(scan_tm),"%d",scan_time);
                nvram_set("last_scan_time",scan_tm);
        }
//	MS_name = nvram_safe_get("machine_name");
//	if (MS_name)
  //      	eval("/usr/local/upnpmms/mmsio", "-wname", MS_name);
	
	/*
	MS_scan_folder = nvram_safe_get("MS_scan_folder_value");
	if (MS_scan_folder)
		eval("usr/local/upnpmms/mmsio", "-su", MS_scan_folder);
	*/
	dprintf("done\n");
	return ret;
}
int stop_media_server(void)
{
//	eval("killall", "-9", "mmssetup stop");
	//eval("killall", "-9", "upnpmms");
	eval("killall", "twonkymedia");
	eval("killall", "twonkymediaserv");
	eval("killall", "twonkymediaserver");
	dprintf("done\n");
	return 0;
}
#endif
#ifdef GUEST_NETWORK_SUPPORT 
#if defined( SMB3025_SUPPORT ) || defined( SMB3215_SUPPORT )
void start_gn_nmbd(void)
{

       if(!strcmp(nvram_safe_get("gn_enable"), "1") &&
	  !strcmp(nvram_safe_get("wk_mode"), "gateway") &&
           strcmp(nvram_safe_get("wl0_gmode"), "-1"))
	{
		symlink("/usr/local/samba/sbin/nmbd", "/tmp/gn-nmbd");
		write_nmbd_config_file(GUEST_NETWORK, GUEST_NMBD_CONF_FILE);
		eval("/tmp/gn-nmbd", "-s", GUEST_NMBD_CONF_FILE);
	}
}
void stop_gn_nmbd(void)
{
	eval("killall", "-9", "gn-nmbd");
	unlink("/tmp/gn-nmbd");

	dprintf("done\n");
	return 0;
}
static int
write_nmbd_config_file(int role, const char * file_name)
{
        FILE *config_fp;
        const char *machine_name;
        bool member_of_domain;
        bool member_of_domain_only; /* member, not pdc */
        char *printer_pool_info;
        const char * security_mode;
        const char * cifs_guest_account = "guest";
        char gn_nbios_name[20];
 
        /*
                Needs to be built before we build smb.conf.
         */
        machine_name = nvram_safe_get("machine_name");
        if ((machine_name == NULL) || (machine_name[0] == 0))
                machine_name = "WirelessNAS";
 
        config_fp = fopen(file_name, "w");
        if (config_fp == NULL)
        {
                fprintf(stderr,
                        "Error: Could not open SAMBA configuration file `%s': %s\n",
                        file_name, strerror(errno));
                return -1;
        }
 
        if(role == HOME_NETWORK)
                fprintf(config_fp,
                "[global]\n"
                "        netbios name = %s\n"
                "        log file = /var/log/samba.log\n"
                "        interfaces = lo br0\n", machine_name);
        else{
		//Jemmy fix to read guest network ssid to replace machine name 2009.12.3 
                strncpy(gn_nbios_name, nvram_safe_get("wl0.1_ssid"), 15);
                fprintf(config_fp,
                "[global]\n"
                "        netbios name = %s\n"
                "        log file = /var/log/samba-gn.log\n"
                "        interfaces = lo br1\n", gn_nbios_name);
	}
 
        fprintf(config_fp,
                //"        netbios aliases = 192.168.1.1\n"
                "        server string = \"%s\"\n"
                "        workgroup = \"\"\n"          /*Jemmy Fix that homePC can see guest network device in vista network place 2009.12.16*/
                "        security = %s\n"
                "        guest account = %s\n"
                //"        log file = /var/log/samba.log\n"
                //add smb-fast feature at 20101015
                //"        socket options = TCP_NODELAY SO_RCVBUF=16384 "
                "        socket options = TCP_SMB_FAST TCP_NODELAY SO_RCVBUF=16384 "
                        "SO_SNDBUF=8192\n"
                "        encrypt passwords = yes\n"
                //"        use spnego = no\n"
                //"        client use spnego = no\n"
                "        wins server = %s\n"
                "        wins support = %s\n"
                //"        host msdfs = %s\n"
                //"        interfaces = lo br0\n"
 
                "        os level = %d\n"                       /* Value for PDC. */
                "        preferred master = %s\n"       /* Value for PDC. */
                "        domain master = %s\n"          /* Value for PDC. */
                "        local master = yes\n"          /* Value for PDC- default. */
                "        domain logons = %s\n"          /* Value for PDC. */
                "        log level = 0\n"
                "        max log size = 100\n"
                "        null passwords = yes\n",
		//did not add this rule into home samba conf to fix IR-B0014250 at 20100108
                //"        bind interfaces only = yes\n",  /*Jemmy add to restrict access right 2009.12.16*/
                //nvram_safe_get("machine_comment"), nvram_safe_get("workgroup"),
                nvram_safe_get("machine_comment"),
                "user", //(!member_of_domain ? "share" : (!pdc_is_enabled ? "domain" : "user")),
                "guest",
                /* Security values:
                       share: member of workgroup
                           domain: member of domain
                           user: primary domain controller
                 */
                "" ,
                 "no",
                //((strcmp(nvram_safe_get("cifs_msdfs_enable"), "enabled") == 0) ?
                // "yes" : "no"), 
 
 
                20,                     /* 20 is default.  64 from PdcHowto. */
                "auto",         /* preferred master */
                "auto",         /* domain master */
                "no"            /* domain logons */
        );
	//did not add this rule into home samba conf to fix IR-B0014250 at 20100108
        if(role == GUEST_NETWORK)
        	fprintf(config_fp,
			"	bind interfaces only = yes\n");  /*Jemmy add to restrict access right 2009.12.16*/
 
 
        fprintf(config_fp,
                        "        hosts allow = %s/%s\n", nvram_safe_get("gn_lan_ipaddr"), nvram_safe_get("gn_lan_netmask")
                );

        fprintf(config_fp,
                        "        passdb backend = smbpasswd:/tmp/smbpasswd\n"
                );
 
 
 
        fflush(config_fp);
        if (ferror(config_fp))
        {
                fclose(config_fp);
                fprintf(stderr,
                        "Error: While writing SAMBA configuration file `%s': %s\n",
                        file_name, strerror(errno));
                return -1;
        }
        fclose(config_fp);
 
 
        //add_account_ex();
 
        return 0;
}
 
#endif //SMB3025_SUPPORT||SMB3215_SUPPORT
#endif

#ifdef STORAGE_SUPPORT
//add to support netbois access GUI at 20090605
void start_nmbd(void)
{
        all_disk_info_t *all_disk_info=NULL;
        int config_file_result;
        all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);
        config_file_result = write_cifs_config_file("/tmp/samba/lib/smb.conf", all_disk_info);

        eval("/usr/local/samba/sbin/nmbd");
        clear_all_disk_info(all_disk_info);

	//Jemmy add for guest network 2009.9.26
#ifdef GUEST_NETWORK_SUPPORT 
	start_gn_nmbd();
#endif
}
/*
void start_nmbd(void)
{
        write_nmbd_config_file(HOME_NETWORK, HOME_NMBD_CONF_FILE);
        write_nmbd_config_file(GUEST_NETWORK, GUEST_NMBD_CONF_FILE);
        eval("/usr/local/samba/sbin/nmbd", "-s", HOME_NMBD_CONF_FILE);
        eval("/usr/local/samba/sbin/nmbd", "-s", GUEST_NMBD_CONF_FILE);
}
*/

void stop_nmbd(void)
{
#ifdef GUEST_NETWORK_SUPPORT
	stop_gn_nmbd();
#endif
	eval("killall", "-9", "nmbd");
	dprintf("done\n");
	return 0;
}


int
start_cifs(void)
{
	FILE *test_fp;
	all_disk_info_t *all_disk_info = NULL;
	int config_file_result;
	pool_info_t *printer_pool;
	const char *pdc_pool_name;
	const pool_info_t *pdc_pool;
	char *smbd_path;
	int result;

	if (strcmp(nvram_safe_get("cifs_master_enable"), "enabled") != 0)
		return 0;

	test_fp = fopen("/tmp/samba_disable", "r");
	if (test_fp != NULL)
	{
		fclose(test_fp);
		return 0;
	}

	/* 
		Create the user related files that Samba uses: passwd, smbpasswd, and
	   	smbusers.  

	   	Note: This must be done before write_cifs_config_file().
	 */
//	export_user_info();
//	link_passwd();

	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);
	config_file_result = write_cifs_config_file("/tmp/samba/lib/smb.conf", all_disk_info);

	if (config_file_result != 0)
	{
		clear_all_disk_info(all_disk_info);
		return config_file_result;
	}

	printer_pool = require_mounted_pool(nvram_safe_get("printer_pool_name"),
			"Printer Support", all_disk_info);

	if (printer_pool != NULL)
	{
	  setup_printer_tdb_links(printer_pool);
	}

	pdc_pool_name = nvram_safe_get("pdc_pool");
	pdc_pool =
			(((pdc_pool_name == NULL) || (pdc_pool_name[0] == 0) ||
			  (all_disk_info == NULL)) ? NULL :
			 find_pool(pdc_pool_name, all_disk_info));
	if ((pdc_pool != NULL) && (pdc_pool->mount_name != NULL))
	{
        char path_buffer[1000];
		
		sprintf(path_buffer, "/shares/%s/__pdc/group_mapping.tdb",
				pdc_pool->mount_name);
		/*
			When we first enable PDC mode, Samba creates this file before
			we get to this logic.  So, we remove any existing file, to allow us
			to create a soft link.
		 */

		eval("rm", "-f", "/tmp/samba/var/locks/group_mapping.tdb");
		eval("ln", "-s", path_buffer,
			 "/tmp/samba/var/locks/group_mapping.tdb");
	}

	clear_all_disk_info(all_disk_info);
	smbd_path = nvram_safe_get("smbd_path");
	if ((smbd_path == NULL) || (*smbd_path == 0))
		smbd_path = "/usr/local/samba/sbin/smbd";
	result = eval(smbd_path);

	if (result != 0)
		return result;

	result = eval("/usr/local/samba/sbin/nmbd");
	if (result != 0)
		return result;

	dprintf("done\n");
	return 0;
}

int
stop_cifs(void)
{
	/* Try for a graceful shutdown. */
	
#ifdef SMB302_SUPPORT
	eval("/usr/local/samba/bin/smbcontrol","smbd","shutdown");
	eval("/usr/local/samba/bin/smbcontrol","nmbd","shutdown");
	sleep(2);
#endif
	eval("killall", "-9", "smbd");
	eval("killall", "-9", "nmbd");
	sleep(1);
	dprintf("done\n");
	return 0;
}

int
share_update(void)
{
	FILE *test_fp;
	all_disk_info_t *all_disk_info;
	int config_file_result;

	if (strcmp(nvram_safe_get("cifs_master_enable"), "enabled") != 0)
		return 0;

	test_fp = fopen("/tmp/samba_disable", "r");
	if (test_fp != NULL)
	{
		fclose(test_fp);
		return 0;
	}

	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);

	config_file_result = write_cifs_config_file("/tmp/samba/lib/smb.conf.new", all_disk_info);
	clear_all_disk_info(all_disk_info);
	if (config_file_result != 0)
		return config_file_result;

	eval("mv", "/tmp/samba/lib/smb.conf.new", "/tmp/samba/lib/smb.conf");
	eval("killall", "-HUP", "smbd");

	return 0;
}


/*
	Note: this currently is identical to share_update().  However, this 
	function can be used to regenerate smb.conf regardless of the reason.
 */
int
regen_cifs_config_file( void )
{
	FILE *test_fp;
	all_disk_info_t *all_disk_info;
	int config_file_result;

	if (strcmp(nvram_safe_get("cifs_master_enable"), "enabled") != 0)
		return 0;

	test_fp = fopen("/tmp/samba_disable", "r");
	if (test_fp != NULL)
	{
		fclose(test_fp);
		return 0;
	}

	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);

	config_file_result = write_cifs_config_file("/tmp/samba/lib/smb.conf.new",
												all_disk_info);
	clear_all_disk_info(all_disk_info);
	if (config_file_result != 0)
		return config_file_result;

	eval("mv", "/tmp/samba/lib/smb.conf.new", "/tmp/samba/lib/smb.conf");

	return 0;
}

//void
//regen_passwd_files( void )
//{
//	/* Create the user related files that Samba uses: passwd, smbpasswd, and 
//	   smbusers. */
//	export_user_info();
//}


static void
export_one_nfs_share(const pool_info_t *pool, const char *share_name)
{
	/* @@@ */
	/*
	 *  @@@
	 *  This code should be extended to read permissions and other
	 *  attributes for the share from a private file specific to that share
	 *  and use those attributes to set the mount options as well as the
	 *  list of hosts to which the file is accessable.
	 *  @@@
	 */
	char *share_disable_value;
	char *path;

	assert(pool != NULL);
	assert(pool->mount_name != NULL);

	share_disable_value = pool_share_var_get(pool, share_name, "nfs_enable");
	if ((share_disable_value != NULL) &&
		(strcmp(share_disable_value, "disabled") == 0))
	{
		free(share_disable_value);
		return;
	}
	if (share_disable_value != NULL)
		free(share_disable_value);

	path = (char *)(malloc(
			strlen(pool->mount_name) + strlen(share_name) + 100));
	if (path == NULL)
		return;

	create_pool_share_marker("pool_share_nfs_exports", pool->mount_name,
							 share_name);
	sprintf(path, "*:/shares/%s/%s", pool->mount_name, share_name);
	eval("exportfs", "-i", "-o", "rw,no_root_squash", path);
	free(path);
	/* @@@ */
}

static void
export_nfs_shares(void)
{
	all_disk_info_t *all_disk_info;
	pool_info_t *follow_pools;
	mounted_info_t *mount_info;

	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);

	mkdir("/tmp/pool_share_nfs_exports", 0777);
	for (follow_pools = get_pool_info(all_disk_info); follow_pools != NULL;
		 follow_pools = follow_pools->next)
	{
		char **share_names;
		u32 share_num;

		if (pool_is_going(follow_pools))
			continue;
		share_names = shares_in_pool(follow_pools);
		if (share_names == NULL)
			continue;

		assert(follow_pools->mount_name != NULL);
		create_marker_pool_directory("pool_share_nfs_exports",
									 follow_pools->mount_name);
		for (share_num = 0; share_names[share_num] != NULL; ++share_num)
			export_one_nfs_share(follow_pools, share_names[share_num]);
		clear_share_info(share_names);
	}

	mount_info = read_mount_info(get_disk_info(all_disk_info));
	if (mount_info != NULL)
	{
		size_t mount_count;
		size_t mount_num;

		mount_count = mount_info->mount_count;
		for (mount_num = 0; mount_num < mount_count; ++mount_num)
		{
			mounted_entry_t *this_entry;
			const char *share_name;
			char *mark_file;
			FILE *fp;
			const char *share_disable_value;
			char *path;

			this_entry = &(mount_info->entries[mount_num]);
			if (strncmp(this_entry->mount_point, "/foreign_shares/",
						strlen("/foreign_shares/")) != 0)
			{
				continue;
			}
			share_name =
					&(this_entry->mount_point[strlen("/foreign_shares/")]);
			if (this_entry->partition == NULL)
				continue;

			/* Check for a mark left to say to omit this share because it is
			 * about to be removed. */
			mark_file = (char *)(malloc(strlen(share_name) + 100));
			if (mark_file == NULL)
			{
				fprintf(stderr,
						"Error: failed trying to allocate %llu bytes of memory"
						" while exporting NFS share `%s'.\n",
						(unsigned long long)(strlen(share_name) + 100),
						share_name);
				clear_mount_info(mount_info);
				clear_all_disk_info(all_disk_info);
				return;
			}
			sprintf(mark_file, "/tmp/foreign_shares_going/%s", share_name);
			fp = fopen(mark_file, "r");
			if (fp != NULL)
			{
				fclose(fp);
				free(mark_file);
				continue;
			}
			free(mark_file);

			share_disable_value =
					partition_var_get(this_entry->partition, "nfs_enable");
			if ((share_disable_value != NULL) &&
				(strcmp(share_disable_value, "disabled") == 0))
			{
				continue;
			}

			path = (char *)(malloc(strlen(share_name) + 100));
			if (path == NULL)
				continue;

			sprintf(path, "*:/foreign_shares/%s", share_name);
			eval("exportfs", "-i", "-o", "rw,no_root_squash", path);
			free(path);
		}
		clear_mount_info(mount_info);
	}

	clear_all_disk_info(all_disk_info);

}

int
start_nfs(void)
{
	int result;
	int iteration;

	if (strcmp(nvram_safe_get("nfs_master_enable"), "enabled") != 0)
		return 0;

	result = eval("portmap");
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start portmapper failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	for (iteration = 0; iteration < 20; ++iteration)
	{
		if (iteration > 0)
		{
			fprintf(stderr,
					"Attempt to start mountd failed.  It may be because the "
					"portmapper wasn't done\n");
			fprintf(stderr,
					"initializing yet.  We'll give it another try...\n");
		}
		result = eval("rpc.mountd");
		if (result == 0)
		{
			fprintf(stderr, "mountd started successfully on try number %d.\n",
					iteration + 1);
			break;
		}
	}
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start mountd failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	result = eval("rpc.nfsd");
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start nfsd failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	result = eval("rpc.statd");
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start statd failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	result = eval("rpc.lockd");
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start lockd failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	result = eval("rpc.rquotad");
	if (result != 0)
	{
		fprintf(stderr,
				"ERROR: Attempt to start rquotad failed.  Aborting NFS "
				"startup.\n");
		return result;
	}

	export_nfs_shares();

	dprintf("done\n");
	return 0;
}

int
stop_nfs(void)
{
	eval("killall", "-9", "rpc.rquotad");
	eval("killall", "-9", "[rpciod]");
	eval("killall", "-9", "lockd");
	eval("killall", "-9", "[lockd]");
	eval("killall", "-9", "rpc.statd");
	eval("killall", "-9", "nfsd");
	eval("killall", "-9", "[nfsd]");
	eval("killall", "-9", "rpc.mountd");
	eval("killall", "-9", "portmap");
	dprintf("done\n");
	return 0;
}
#endif

int
start_configmon()
{
	pid_t pid;
	char *argv[] = {"configmon", NULL};
	int ret = _eval(argv, NULL, 10, NULL);

	dprintf("done\n");
	return ret;
}

int
start_statsmon()
{
	pid_t pid;
	char *argv[] = {"statsmon", NULL};
	int ret = _eval(argv, NULL, 10, NULL);

	dprintf("done\n");
	return ret;
}

int
start_monitor_ip()
{
	pid_t pid;
	char *argv[] = {"monitor_ip", NULL};
	int ret = _eval(argv, NULL, 10, NULL);

	dprintf("done\n");
	return ret;
}

/*
 * Call when keepalive mode
 */
int
redial_main(int argc, char **argv)
{
	int need_redial = 0;
	int status;
	pid_t pid;
	int count = 1;
#ifdef MPPPOE_SUPPORT
	char buf[80];
	int pid1=0, pid2=0;
#endif
	int num;

	while(1)
	{

#ifdef MPPPOE_SUPPORT	
		sleep(20);	
		if(nvram_invmatch("mpppoe_enable","1"))	// Multi PPPoE is disabled.
			num = 0;			// Always check PPPoE 0
		else
			num = count%2;			// Check PPPoE 0 and PPPoE 1 take turn.
#else
		if (argv[1] == NULL)
			sleep(PPPoE_REDIAL_PERIOD);
		else
			sleep(atoi(argv[1]));	
		num = 0;
#endif
		count ++;

		//fprintf(stderr, "check PPPoE %d\n", num);
		if(!check_wan_link(num)){
			//fprintf(stderr, "PPPoE %d need to redial\n", num);
			need_redial = 1;
		}
		else{
			//fprintf(stderr, "PPPoE %d not need to redial\n", num);
			continue;
		}

#ifdef MPPPOE_SUPPORT	
		pid1 = get_ppp_pid("/tmp/ppp/link");
		pid2 = get_ppp_pid("/tmp/ppp/link_1");
		//printf("%s(): pid1=[%d] pid2=[%d]\n", __FUNCTION__, pid1, pid2);
#endif
			
		if(need_redial){
			pid = fork();
			SET_LED(GET_IP_ERROR);
			switch(pid)
			{
				case -1:
					perror("fork failed");
					exit(1);
				case 0:
					if(nvram_match("wan_proto","pppoe")
#ifdef UNNUMBERIP_SUPPORT
                                        ||nvram_match("wan_proto","unnumberip")
#endif
#ifdef WAN_AUTO_DETECT_SUPPORT
                                        ||nvram_match("wan_proto","auto_pppoe")
#endif
					){
#ifdef MPPPOE_SUPPORT
						// We only want to kill un-connected pppoecd
						// So we want to find which pppoecd is connected.
						int *pidList = find_all_pid_by_ps("pppoecd");		
						for(; pidList && *pidList!=0; pidList++) {
							//printf("%s(): find pid=[%d]\n", __FUNCTION__, *pidList);
							if(*pidList != pid1 && *pidList != pid2){
								char p[10];
								snprintf(p, sizeof(p), "%d", *pidList);
								//printf("%s(): We want to kill %s\n", __FUNCTION__, p);
								eval("kill", "-9", p);
							}
						}
						if(pidList)	free(pidList);
						
						if(num == 0)
							 start_pppoe(PPPOE0);
                                                        //start_wan(REDIAL);
						else if(num == 1)
							start_pppoe(PPPOE1);
                                                        //start_pppoe2();
#else
						stop_pppoe();
						eval("killall", "-9", "pppoecd");
						sleep(1);
						start_wan(REDIAL);
#endif
					}
					else if(nvram_match("wan_proto","pptp")){
						stop_pptp();
						sleep(1);
						//wuzh modify 2008-5-20
						//start_wan(REDIAL);
						start_pptp(REDIAL);
                                        }
#ifdef L2TP_SUPPORT
                                        else if(nvram_match("wan_proto","l2tp")){
                                                stop_l2tp();
                                                sleep(1);
                                                start_l2tp(REDIAL);
                                        }
#endif
#ifdef HEARTBEAT_SUPPORT					
					else if(nvram_match("wan_proto","heartbeat")){
						stop_heartbeat();
						sleep(1);
						start_heartbeat(REDIAL);
                                        }
#endif
#ifdef WAN_AUTO_DETECT_SUPPORT	
					else if(nvram_match("wan_proto","auto")){
						sleep(1);
						start_wan(REDIAL);
						eval("killall", "redial");
					}
#endif
					exit(0);
					break;
				default:
					waitpid(pid, &status, 0);
					//dprintf("parent\n");
					break;
			} // end switch
		} // end if
	} // end while
} // end main

#ifdef PUSH_BUTTON_TEST
int
ses_led_main(int argc, char **argv)
{
	int i;
	int times;
	int interval;
	int count;
	char buf[20];

	switch (fork()) {
	case -1:
		exit(0);
		break;
	case 0:		
		/* child process */
		(void) setsid();
		break;
	default:	
		/* parent process should just die */
		_exit(0);
	}
	
	times = atoi(argv[1]);
	interval = atoi(argv[2]);

	/* For Setup Wizard */
	count = atoi(nvram_safe_get("ses_count"));
	snprintf(buf, sizeof(buf), "%d", count+1);
	nvram_set("ses_count", buf);

	if((check_hw_type() == BCM4712_CHIP) || (check_hw_type() ==  BCM4702_CHIP))
		return 0;

	diag_led(SES_LED2,STOP_LED);

	for(i=0 ; i<times ; i++) {
		/* White led */
		diag_led(SES_LED1,START_LED);			
		usleep(1000 * interval);
		diag_led(SES_LED1,STOP_LED);
		usleep(1000 * interval);
	}
	return 0;
}
#endif

void dmz_monitor_main(timer_t t, int arg)
{
	/* Cann't find ip of dmz_mac from firewall.c */
	if(!nvram_get("dmz_mac_ip") || nvram_match("dmz_mac_ip","")) {
		char *dmz_mac = nvram_safe_get("dmz_mac");
		char *ip;

		ip = get_ip_from_mac(dmz_mac);

		if(strcmp(ip, "")) {
			cprintf("Restart firewall for DMZ MAC\n");	
			stop_firewall();
			start_firewall();
		}
	}
}

#ifdef STORAGE_SUPPORT
/*
	This function builds the operational password files when we are in 
	workgroup mode.  Workgroup mode means that Samba security=shared, and
	that the passwords in the password files are share access passwords.

	In this function, we simply concatenate the partial backup password files
	found in each share into unified operational password files.  The root
	and guest entries needed to be added somewhere else.
 */
 
void
restore_workgroup_passwd_files( const char * passwd_name, const char * smbpasswd_name )
{
	FILE *passwd_fp;
	FILE *smbpasswd_fp;
	all_disk_info_t *all_disk_info;
	pool_info_t *follow_pools;
	mounted_info_t *mount_info;

	passwd_fp = fopen(passwd_name, "a");
	if (passwd_fp == NULL)
		return;
	smbpasswd_fp = fopen(smbpasswd_name, "a");
	if (smbpasswd_fp == NULL)
	{
		fclose(passwd_fp);
		return;
	}

	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);

	for (follow_pools = get_pool_info(all_disk_info); follow_pools != NULL;
		 follow_pools = follow_pools->next)
	{
		char **share_info;
		size_t share_num;

		share_info = shares_in_pool(follow_pools);
		if (share_info == NULL)
			continue;
		share_num = 0;
		while (share_info[share_num] != NULL)
		{
			const char *share_name;
			char *exported_as;
			char *uid;
			char *password_stuff;

			share_name = share_info[share_num];
			++share_num;
			exported_as = share_exported_as_name(follow_pools->mount_name,
												 share_name);
			if (exported_as == NULL)
				continue;
			uid = pool_share_var_get(follow_pools, share_name,
									 "cifs_protection_uid");
			if (uid == NULL)
				continue;
			password_stuff = pool_share_var_get(follow_pools, share_name,
					"cifs_protection_password_stuff");
			if (password_stuff == NULL)
			{
				free(uid);
				continue;
			}
			fprintf(passwd_fp, "%s::%s:%s:%s:/dev/null:/bin/false\n",
					exported_as, uid, nvram_safe_get("users_gid"), share_name);
			fprintf(smbpasswd_fp, "%s:%s:%s\n", exported_as, uid,
					password_stuff);
			free(uid);
			free(password_stuff);
		}
		clear_share_info(share_info);
	}

	mount_info = read_mount_info(get_disk_info(all_disk_info));
	if (mount_info != NULL)
	{
		size_t mount_count;
		size_t mount_num;

		mount_count = mount_info->mount_count;
		for (mount_num = 0; mount_num < mount_count; ++mount_num)
		{
			mounted_entry_t *this_entry;
			const char *uid;
			const char *password_stuff;
			const char *share_name;

			this_entry = &(mount_info->entries[mount_num]);
			if (strncmp(this_entry->mount_point, "/foreign_shares/",
						strlen("/foreign_shares/")) != 0)
			{
				continue;
			}
			if (this_entry->partition == NULL)
				continue;
			uid = partition_var_get(this_entry->partition,
									"cifs_protection_uid");
			if (uid == NULL)
				continue;
			password_stuff = partition_var_get(this_entry->partition,
					"cifs_protection_password_stuff");
			if (password_stuff == NULL)
				continue;
			share_name =
					&(this_entry->mount_point[strlen("/foreign_shares/")]);
			fprintf(passwd_fp, "%s::%s:%s:%s:/dev/null:/bin/false\n",
					share_name, uid, nvram_safe_get("users_gid"), share_name);
			fprintf(smbpasswd_fp, "%s:%s:%s\n", share_name, uid,
					password_stuff);
		}
		clear_mount_info(mount_info);
	}

	clear_all_disk_info(all_disk_info);
	fclose(passwd_fp);
	fclose(smbpasswd_fp);
}


 /*
	This function creates a user note if the given pool is not mounted.
 */

static pool_info_t *
require_mounted_pool(const char *pool_name, const char *purpose,
					 all_disk_info_t *all_disk_info)
{
	pool_info_t *result = NULL;

	if ((pool_name != NULL) && (*pool_name != '\0'))
	{
		const char *key_format = "pool_%s_unmounted";
		char *key;
		size_t len = strlen(key_format) + strlen(pool_name) + 32;
		pool_info_t *pool;

		key = malloc(len);
		if (key == NULL)
		{
			fprintf(stderr, "ERROR: Could not allocate %d bytes for key.\n",
					len);
			key = "pool_unmounted";
		}
		else
		{
			sprintf(key, key_format, pool_name);
		}

		pool = find_pool(pool_name, all_disk_info);

		if (pool != NULL)
		{
			if ((pool->encryption_status != PEM_UNENCRYPTED &&
				 pool->encryption_password_is_missing) || pool_is_going(pool)
				 || (pool->mount_name == NULL))
			{
				char *summary;
				char *details;

				if (purpose == NULL)
					purpose = "";

				len = strlen(pool_name) + strlen(purpose);
				summary = malloc(len + 400);
				if (summary == NULL)
				{
					fprintf(stderr,
							"ERROR: Could not allocate %d bytes for "
							"summary.\n", len + 400);
					free(key);
					return NULL;
				}
				else
				{
					sprintf(summary,
							"Error: Pool %s is not mounted%s%s.",
							pool->name,
							(*purpose) ? " and is needed for " : "",
							purpose);
				}
					
				details = malloc(len + 5000);
				if (details == NULL)
				{
					fprintf(stderr,
							"ERROR: Could not allocate %d bytes for "
							"details.\n", len + 5000);
					details = "Pool is not yet mounted.\n";
				}
				else
				{
					sprintf(details,
							"Pool %s is not yet mounted%s%s.\n",
							pool->name,
							(*purpose) ? " and is needed for " : "",
							purpose);

					strcat(details,
"\n"
"This pool is encrypted and must be mounted by entering the password.\n"
"You can enter the password by clicking on the appropriate button on \n"
"'Disk Management- Basic' web page.\n"
					);
				}

				create_user_note(summary, key, NULL, details);
				
				free(summary);
				free(details);
			}
			else
			{
				delete_user_note(key);
				result = pool;
			}
		}
		else
		{
			char *summary;
			char *details;

			if (purpose == NULL)
				purpose = "";

			len = strlen(pool_name) + strlen(purpose);
			summary = malloc(len + 400);
			if (summary == NULL)
			{
				fprintf(stderr,
						"ERROR: Could not allocate %lu bytes for summary.\n",
						(unsigned long)(len + 400));
				free(key);
				return NULL;
			}
			else
			{
				sprintf(summary,
						"Error: Pool %s was not found%s%s.",
						pool_name,
						((*purpose) ? " and is needed for " : ""),
						purpose);
			}

			details = malloc(len + 5000);
			if (details == NULL)
			{
				fprintf(stderr,
						"ERROR: Could not allocate %d bytes for details.\n",
						len + 5000);
				free(summary);
				free(key);
				return NULL;
			}
			else
			{
				sprintf(details, "Pool %s was not found%s%s.\n",
						pool_name,
						((*purpose) ? " and is needed for " : ""),
						purpose);

				strcat(details,
"\n"
"This pool is encrypted and must be mounted by entering the password.\n"
"You can enter the password by clicking on the appropriate button on \n"
"'Disk Management- Basic' web page.\n"
						);
			}

			create_user_note(summary, key, NULL, details);

			free(summary);
			free(details);
		}
		free(key);
	}
	
	return result;
}



/*
	This function builds the operational password files when we are in 
	workgroup mode.  Workgroup mode means that Samba security=shared, and
	that the passwords in the password files are share access passwords.

	In this function, we CANNOT simply concatenate the partial password files.
	We have to look for uid/gid conflicts.  The root and guest entries needed 
	to be added somewhere else.
 */

void
restore_domain_passwd_files(	const char * passwd_name, 
								const char * smbpasswd_name,
								const char * group_name )
{
	all_disk_info_t *all_disk_info;
	pool_info_t *follow_pools;

	size_t num_pools = 0;
	size_t size_pool_names = 0;
	char *new_pool_names, *save_new_pool_names;
	char *pool_names, *save_pool_names;
	char *active_pools;
	char *new_active_pools, *save_new_active_pools;
	char *pool_name;

	dprintf("restore_domain_passwd_files: entered passwd=%s smbpasswd=%s\n",passwd_name, smbpasswd_name);
	all_disk_info = read_all_disk_info(POOL_MODE_READ_ONLY);


	/* Pass 1: Find out how much space is necessary for the list of pools. */
	follow_pools = get_pool_info(all_disk_info);
	while (follow_pools != NULL)
	{
		++num_pools;
		size_pool_names += strlen(follow_pools->name);
		
		follow_pools = follow_pools->next;
	}

	size_pool_names += num_pools + 1 + 32; /* num_pools for delimiter, 1 for terminator, 32 for safety */
	dprintf("restore_domain_passwd_files: size=%d\n",size_pool_names);
	
	new_pool_names = save_new_pool_names = malloc(size_pool_names);	
	pool_names = save_pool_names = malloc(size_pool_names);
	new_active_pools = save_new_active_pools = malloc(size_pool_names);
	if (new_pool_names == NULL || pool_names == NULL || new_active_pools == NULL)
	{
		fprintf(stderr, "ERROR file %s, line %d: Could not allocate three buffers of size %d.\n",
			__FILE__, __LINE__, size_pool_names);

		free(save_new_pool_names);
		free(save_pool_names);
		free(save_new_active_pools);

		return;
	}	
	new_pool_names[0] = '\0';
	pool_names[0] = '\0';
	new_active_pools[0] = '\0';
	
	active_pools = nvram_safe_get("domain_active_pools");
	dprintf("restore_domain_passwd_files: active=%s\n", active_pools);


	/* Pass 2: Build the pool list. */
	follow_pools = get_pool_info(all_disk_info);
	while (follow_pools != NULL)
	{
		if (ug_find_string_in_list(follow_pools->name, active_pools, ":") == FALSE)
		{
			/* Then it must be a new pool. */
			if (new_pool_names[0] != '\0')
				strcat(new_pool_names, ":");
			strcat(new_pool_names, follow_pools->name);
		}
		else
		{
			/* This is a previously active pool.  So put it early in the list. */
			if (pool_names[0] != '\0')
				strcat(pool_names, ":");
			strcat(pool_names, follow_pools->name);
		}

		
		follow_pools = follow_pools->next;
	}
	if (pool_names[0] != '\0')
		strcat(pool_names, ":");
	strcat(pool_names, new_pool_names);
	
	dprintf("restore_domain_passwd_files: pool names=%s\n", pool_names);

	
	/* Pass 3: Using order given in 'pool_names", go over pools. */
	/* This code destroys 'pool_names', but we don't care. */
	while ((pool_name = strsep(&pool_names, ":")) != NULL)
	{
		char *path_name;
		char *partial_passwd_name;
		char *partial_group_name;
		struct stat status;

		if (pool_name[0] == '\0') continue; /* For colon at the end of a line. */

		dprintf("restore_domain_passwd_files: iterate: pool name=%s\n", pool_name);

		for (follow_pools = get_pool_info(all_disk_info); follow_pools != NULL;
			 follow_pools = follow_pools->next)
		{
			if (strcmp(follow_pools->name,pool_name) == 0)
				break;
		}
		if (follow_pools == NULL)
			continue;

		path_name = make_domain_file(follow_pools, NULL);
		if (path_name == NULL)
			continue;
		partial_passwd_name = make_domain_file(follow_pools, "passwd");
		if (partial_passwd_name == NULL)
		{
			free(path_name);
			continue;
		}
		partial_group_name = make_domain_file(follow_pools, "group");
		if (partial_group_name == NULL)
		{
			free(path_name);
			free(partial_passwd_name);
			continue;
		}

		dprintf("restore_domain_passwd_files: iterate: passwd=%s group=%s\n", partial_passwd_name, partial_group_name);

		if (stat(partial_passwd_name, &status) == -1)
		{
			/* If the file doesn't exist.  Does the directory? */
			if (stat(path_name, &status) == -1)
			{
				/* The directory for our partial password files does not exist. */
				mkdir(path_name, 0777);
			}
			creat(partial_passwd_name, 0660);
			creat(partial_group_name, 0660);

			strcat(new_active_pools, pool_name);
			strcat(new_active_pools, ":");

			dprintf("restore_domain_passwd_files: initialized %s\n", partial_passwd_name);
		}
		else
		{
			/*
				Merge the files from the partial password files to the
				operational password files.

				NOTE: We don't need the smbpasswd file in domain member mode.
			 */
			bool res1, res2;
			dprintf("restore_domain_passwd_files: merging with %s\n", partial_passwd_name);

			res1 = ug_merge_file(passwd_name, partial_passwd_name, ":");
			res2 = ug_merge_file(group_name, partial_group_name, ":");

			if (res1 == FALSE || res2 == FALSE)
			{
				/* Deactivate the pool. */
				/* To deactive, all we have to do is NOT add it to the
					list of active pools. */
				dprintf("restore_domain_passwd_files: Deactivating %s\n", pool_name);
			}
			else
			{
				strcat(new_active_pools, pool_name);
				strcat(new_active_pools, ":");
			}
		}

		free(path_name);
		free(partial_passwd_name);
		free(partial_group_name);
	}


	/* Record the valid (i.e., active) pools. */
	dprintf("restore_domain_passwd_files: new active = '%s'\n",new_active_pools);
	nvram_set("domain_active_pools", new_active_pools);
	nvram_commit();


	/* Pass 4: Now that we have the single unified password file.  Write it 
		out to all the active pools. */
	/* This code destroys 'new_active_pools', but we don't care. */
	while ((pool_name = strsep(&new_active_pools, ":")) != NULL)
	{
		char *partial_passwd_name;
		char *partial_group_name;

		if (pool_name[0] == '\0') continue; /* For colon at the end of a line. */

		dprintf("restore_domain_passwd_files: iterate2: pool name=%s\n", pool_name);
		
		for (follow_pools = get_pool_info(all_disk_info); follow_pools != NULL;
			 follow_pools = follow_pools->next)
		{
			if (strcmp(follow_pools->name,pool_name) == 0)
				break;
		}
		if (follow_pools == NULL)
			continue;

		partial_passwd_name = make_domain_file(follow_pools, "passwd");
		partial_group_name = make_domain_file(follow_pools, "group");

		if (partial_passwd_name != NULL)
		{
			unlink(partial_passwd_name);
			eval("cp", passwd_name, partial_passwd_name);
		}

		if (partial_group_name != NULL)
		{
			unlink(partial_group_name);
			eval("cp", group_name, partial_group_name);
		}
		
		free(partial_passwd_name);
		free(partial_group_name);
	}
	

	free(save_new_pool_names);
	free(save_pool_names);
	free(save_new_active_pools);
	clear_all_disk_info(all_disk_info);
}

/*
	This function builds the password files and smbusers, if necessary.  
	For workgroup and domain member mode, we always need to build 
	the password files.  And for PDC mode, we
	only need to create the files if they don't yet exist.
 */
static void
export_user_info( void )
{
	char *passwd_name;
	char *smbpasswd_name;
	char *groups_name;
	struct stat file_status;
	SecurityMode security_mode = get_security_mode();

	smbpasswd_name = NULL;
	groups_name = NULL;
	/* Find the name of the operational password files. */
	if ((passwd_name = make_passwds_file("passwd")) == NULL ||
		(smbpasswd_name = make_passwds_file("smbpasswd")) == NULL ||
		(groups_name = make_passwds_file("group")) == NULL)
	{
		free(passwd_name);
		free(smbpasswd_name);
		free(groups_name);

		return;
	}

	dprintf("export_user_info: passwd=%s smbpasswd=%s groups=%s\n", passwd_name, smbpasswd_name, groups_name);


	/* Initialize the operational password files, if we are in workgroup or
		domain member mode.  Or, if they don't exist. */
	if (security_mode != SECURITY_USER || stat(passwd_name, &file_status) != 0)
	{ /* Assume file doesn't exist. */
		ug_passwds_init( passwd_name, smbpasswd_name, groups_name );
		
		/* Restore passwd files from backup if necessary. */
		if (security_mode == SECURITY_SHARE)
		{
			/* Note: we don't need groups in workgroup mode. */
			restore_workgroup_passwd_files( passwd_name, smbpasswd_name );
		}
		else if (security_mode == SECURITY_DOMAIN)
		{
			

			/* Build the operational passwd and group files from the per 
				pool ones. */
			restore_domain_passwd_files( passwd_name, smbpasswd_name, groups_name );

			/* 	Note:
				We also have to restore the secrets.tdb file.  However, we have
				to wait until after smb.conf has been rebuilt.
			 */
		}
	}
		

	/*
		Need to have allow non-root users to write to these files because they will
		be updated by samba using a _samba_ root account.
	 */
	if (chmod( passwd_name, 0666 ) != 0)
	{
		cprintf("WARNING: could not chmod %s.\n", passwd_name);
	}
	if (chmod( smbpasswd_name, 0666 ) != 0)
	{
		cprintf("WARNING: could not chmod %s.\n", smbpasswd_name);
	}

	free(passwd_name);
	free(smbpasswd_name);
	free(groups_name);

}


void
restore_secrets( void )
{
	char * domain;
	
	char password_var[64];
	char lct_var[64];
	char sct_var[64];
	char sid_var[64];

	const char *password;
	const char *lct;
	const char *sct;
	const char *sid;

	
	/* This function only applies in domain member mode. */
	if (get_security_mode() != SECURITY_DOMAIN)
		return;


	/* Note: need to do nvram_get() after restore_domain_passwd_files(),
		because the latter does an nvram_commit(). */
	domain = nvram_get("workgroup");
	if (domain == NULL)
	{
		fprintf(stderr,"ERROR: No domain name!\n");
	}
	else
	{
		/* We need to restore Samba's secrets.tdb file. */
		
		int i;
		char * DOMAIN = malloc(strlen(domain)+1+32);
					
		/* Samba uses an uppercase domain name. */
		for (i=0; domain[i]!='\0' ;i++)
			DOMAIN[i] = toupper(domain[i]);
		DOMAIN[i] = '\0';
		
		sprintf(password_var, "domain_%s_password", DOMAIN);
		sprintf(lct_var, "domain_%s_lct", DOMAIN);
		sprintf(sct_var, "domain_%s_sct", DOMAIN);
		sprintf(sid_var, "domain_%s_sid", DOMAIN);


		password = nvram_get(password_var);
		lct = nvram_get(lct_var);
		sct = nvram_get(sct_var);
		sid = nvram_get(sid_var);
		
		if (password == NULL || lct == NULL || sct == NULL || sid == NULL)
		{
			// This is causing a headache when joining a domain.  
			// When we have not yet joined the domain, we run through
			// this code (to build smb.conf) and get this error. --GEW
			//
			//fprintf(stderr,"ERROR: Could not restore secrets.\n");
		}
		else
		{
			eval("/usr/local/samba/bin/tdb_restore_secrets",DOMAIN,password,lct,sct,sid);
		}
		free(DOMAIN);
	}
}


static void
create_marker_pool_directory(const char *base_name,
							 const char *pool_mount_name)
{
	char *directory_path;

	assert(pool_mount_name != NULL);
	directory_path =
			(char *)(malloc(strlen(base_name) + strlen(pool_mount_name) + 7));
	if (directory_path == NULL)
	{
		fprintf(stderr,
				"Error: failed trying to allocate %llu bytes of memory for a "
				"pool marker directory path.\n",
				(unsigned long long)
						(strlen(base_name) + strlen(pool_mount_name) + 7));
	}
	else
	{
		sprintf(directory_path, "/tmp/%s/%s", base_name, pool_mount_name);
		mkdir(directory_path, 0777);
		free(directory_path);
	}
}


static void
create_pool_share_marker(const char *base_name, const char *pool_mount_name,
						 const char *share_name)
{
	char *marker_path;

	marker_path = (char *)(malloc(
			strlen(base_name) + strlen(pool_mount_name) + strlen(share_name) +
			8));
	if (marker_path == NULL)
	{
		fprintf(stderr,
				"Error: failed trying to allocate %llu bytes of memory for "
				"pool share marker path.\n",
				(unsigned long long)
						(strlen(base_name) + strlen(pool_mount_name) +
						 strlen(share_name) + 8));
	}
	else
	{
		FILE *marker_fp;

		sprintf(marker_path, "/tmp/%s/%s/%s", base_name, pool_mount_name,
				share_name);
		marker_fp = fopen(marker_path, "w");
		if (marker_fp == NULL)
		{
			fprintf(stderr,
					"Error: failed trying to create marker file `%s': %s.\n",
					marker_path, strerror(errno));
		}
		else
		{
			fclose(marker_fp);
		}
		free(marker_path);
	}
}


static void
export_one_cifs_share(const pool_info_t *pool, const char *share_name,
					  FILE *config_fp, bool member_of_domain)
{
	/*
	 *  @@@
	 *  This code should be extended to read permissions and other
	 *  attributes for the share from a private file specific to that share
	 *  and use those attributes to set the mount options and permissions.
	 *
	 *  Note(GEW): Until this work is done, we need to detect certain special
	 *  sections: netlogon and profiles.
	 *
	 *  @@@
	 */

	persistent_var_collection_t *share_vars;
	char *mark_file;
	FILE *fp;
	char *share_disable_value;

	assert(pool != NULL);
	assert(pool->mount_name != NULL);

	share_vars = pool_share_var_collection(pool, share_name);
	if (share_vars == NULL)
		return;

	/* Check for a mark left to say to omit this share because it is about to
	 * be removed. */
	mark_file = (char *)(malloc(
			strlen(pool->mount_name) + strlen(share_name) + 100));
	if (mark_file == NULL)
	{
		fprintf(stderr,
				"Error: failed trying to allocate %llu bytes of memory while "
				"exporting CIFS share `%s'.\n",
				(unsigned long long)
						(strlen(pool->mount_name) + strlen(share_name) + 100),
				share_name);
		deallocate_persistent_var_collection(share_vars);
		return;
	}
	sprintf(mark_file, "/tmp/shares_going/%s/%s", pool->mount_name,
			share_name);
	fp = fopen(mark_file, "r");
	if (fp != NULL)
	{
		fclose(fp);
		free(mark_file);
		deallocate_persistent_var_collection(share_vars);
		return;
	}
	free(mark_file);

	share_disable_value = persistent_var_get(share_vars, "cifs_enable");
	if ((share_disable_value != NULL) &&
		(strcmp(share_disable_value, "disabled") == 0))
	{
		deallocate_persistent_var_collection(share_vars);
		return;
	}

	/* @@@ */
	if (strcmp( share_name, "netlogon" ) == 0)
	{
		fprintf(config_fp,
			"\n"
			"[%s]\n"
			"       path = /shares/%s/%s\n"
		      	"       inherit permissions = yes\n"
		        "       inherit acls = yes\n"
			"       read only = yes\n"
			"       write list = %s\n",
			share_name, pool->mount_name, share_name,
			nvram_safe_get("smb_admin_user"));

		create_pool_share_marker("pool_share_cifs_exports", pool->mount_name,
								 share_name);
	}
	else if (strcmp( share_name, "profiles" ) == 0)
	{
		fprintf(config_fp,
			"\n"
			"[%s]\n"
			"       path = /shares/%s/%s\n"
			"       inherit permissions = yes\n"
			"       inherit acls = yes\n"
			"       read only = no\n"
			"		browseable = no\n"
			"       create mask = 0600\n"
			"       directory mask = 0700\n"
			"       profile acls = yes\n", 
			share_name, pool->mount_name, share_name
		);

		create_pool_share_marker("pool_share_cifs_exports", pool->mount_name,
								 share_name);
	}
	else 
	{
		char *exported_as;

		exported_as = share_exported_as_name(pool->mount_name, share_name);

		if (exported_as == NULL)
		{
			deallocate_persistent_var_collection(share_vars);
			return;
		}

		/* 
			For domain members, a pool is deactivated (w.r.t. CIFS) if 
			it is not on the active list.
		 */
		if (get_security_mode() == SECURITY_DOMAIN)
		{
			/* Reread nvram every time in case some has done a commit. */
			const char * active_pools = nvram_safe_get("domain_active_pools");
			
			if (ug_find_string_in_list(pool->name, active_pools, ":") == FALSE)
			{
				free(exported_as);
				deallocate_persistent_var_collection(share_vars);
				return;
			}
		}


	    fprintf(config_fp,
		"\n"
		"[%s]\n"
		"       path = /shares/%s/%s\n"
		"       writeable = yes\n"
		"       browsable = yes\n"
		"       inherit permissions = yes\n"
		"       inherit acls = yes\n"
		"       msdfs root = %s\n",
		exported_as, pool->mount_name, share_name, 
		((strcmp(nvram_safe_get("cifs_msdfs_enable"), "enabled") == 0) ?
		 "yes" : "no"));

		create_pool_share_marker("pool_share_cifs_exports", pool->mount_name,
								 exported_as);

		free(exported_as);

		if (member_of_domain == TRUE)
		{
			if (is_ubsa_mode())
			{
				char *invalid_users, *read_users, *full_users;
				const char * ubsa_guest_account;

				if (get_share_user_permissions(share_vars, pool,
											share_name, 
											&invalid_users,
											&read_users,
											&full_users ) == FALSE)
				{
					deallocate_persistent_var_collection(share_vars);
					return;
				}

			    fprintf(config_fp,
						"       invalid users = %s\n"
						"       read list = %s\n"
						"       write list = %s\n",
						invalid_users, read_users, full_users);
				
				free(invalid_users);
				free(read_users);
				free(full_users);


				/*
					Make the share a guest (aka, public) share if the guest account has
					access privilege (read or full).  If ubsa_guest_account is NULL, then
					no (regular) share can be a guest share.
				 */
				ubsa_guest_account = nvram_safe_get("ubsa_guest_account"); //Defaults to blank.
				if (*ubsa_guest_account != '\0' &&
					get_share_user_permission(share_vars, pool, share_name,
											  ubsa_guest_account) != PERM_NO)
				{
					const char * guest_access = nvram_safe_get("ubsa_special_guest_access");
					if (*guest_access == '\0')
						guest_access = "yes";
				    fprintf(config_fp,
							"       guest ok = %s\n"
							"       guest only = %s\n",
							guest_access, guest_access
					);
				}
			}
			else
			{
			    fprintf(config_fp,
				"       guest ok = yes\n" );
			}
		}
		else /* Share access control is not enabled when we are in a domain. */
		{
			char *uid;
			char *password_stuff;

			uid = persistent_var_get(share_vars, "cifs_protection_uid");
			password_stuff = persistent_var_get(share_vars,
					"cifs_protection_password_stuff");
			if ((uid == NULL) || (password_stuff == NULL))
			{
			    fprintf(config_fp,
				"       guest ok = yes\n"
				"       guest only = yes\n" );
			}
			else
			{
			    fprintf(config_fp,
				"       valid users = %%S\n"
				"       user = %%S\n"
				"       guest ok = no\n"
				"       guest only = no\n");
			}
		}
	}
	/* @@@ */
	deallocate_persistent_var_collection(share_vars);
}

#ifdef __CONFIG_IGMP_PROXY__
void
start_igmp_proxy(void)
{
	/* Start IGMP Proxy in Router mode only */
	if ((!nvram_match("router_disable", "1")) && nvram_match("emf_enable", "1"))
		eval("igmp", nvram_get("wan_ifname"));
	return;
}

void
stop_igmp_proxy(void)
{
	eval("killall", "igmp");
	return;
}
#endif /* __CONFIG_IGMP_PROXY__ */


/*
	Note: In order for us to properly handle the deactivation of domain member
	pools, if export_user_info() needs to be called, then it must be called
	_before_ this function.  export_user_info() sets the domain_active_pools
	NVRAM variable that this function uses.
 */
static void
export_cifs_shares(FILE *config_fp, bool member_of_domain,
				   all_disk_info_t *all_disk_info)

{
/* just export private shares */
#if 0
	pool_info_t *follow_pools;
	mounted_info_t *mount_info;
	/* Handle pool shares. */
	mkdir("/tmp/pool_share_cifs_exports", 0777);
	for (follow_pools = get_pool_info(all_disk_info); follow_pools != NULL;
		 follow_pools = follow_pools->next)
	{
		char **share_names;
		u32 share_num;

		if (pool_is_going(follow_pools))
			continue;
		share_names = shares_in_pool(follow_pools);
		if (share_names == NULL)
			continue;

		assert(follow_pools->mount_name != NULL);
		create_marker_pool_directory("pool_share_cifs_exports",
									 follow_pools->mount_name);
		for (share_num = 0; share_names[share_num] != NULL; ++share_num)
		{
			export_one_cifs_share(follow_pools, share_names[share_num],
								  config_fp, member_of_domain);
		}
		clear_share_info(share_names);
	}

	/* Handle foreign shares. */
	mount_info = read_mount_info(get_disk_info(all_disk_info));
	if (mount_info != NULL)
	{
		size_t mount_count;
		size_t mount_num;

		mount_count = mount_info->mount_count;
		for (mount_num = 0; mount_num < mount_count; ++mount_num)
		{
			mounted_entry_t *this_entry;
			const char *share_name;
			char *mark_file;
			FILE *fp;
			const char *share_disable_value;

			this_entry = &(mount_info->entries[mount_num]);
			if (strncmp(this_entry->mount_point, "/foreign_shares/",
						strlen("/foreign_shares/")) != 0)
			{
				continue;
			}

			share_name =
					&(this_entry->mount_point[strlen("/foreign_shares/")]);
			if (this_entry->partition == NULL)
				continue;

			/* Check for a mark left to say to omit this share because it is
			 * about to be removed. */
			mark_file = (char *)(malloc(strlen(share_name) + 100));
			if (mark_file == NULL)
			{
				fprintf(stderr,
						"Error: failed trying to allocate %llu bytes of memory"
						" while exporting CIFS share `%s'.\n",
						(unsigned long long)(strlen(share_name) + 100),
						share_name);
				clear_mount_info(mount_info);
				return;
			}
			sprintf(mark_file, "/tmp/foreign_shares_going/%s", share_name);
			fp = fopen(mark_file, "r");
			if (fp != NULL)
			{
				fclose(fp);
				free(mark_file);
				continue;
			}
			free(mark_file);

			share_disable_value =
					partition_var_get(this_entry->partition, "cifs_enable");
			if ((share_disable_value != NULL) &&
				(strcmp(share_disable_value, "disabled") == 0))
			{
				continue;
			}

			fprintf(config_fp,
					"\n"
					"[%s]\n"
					"       path = /foreign_shares/%s\n"
					"       writeable = yes\n"
					"       browsable = yes\n"
					"       inherit permissions = yes\n"
					"       inherit acls = yes\n"
					"       msdfs root = %s\n",
					share_name, share_name, 
					((strcmp(nvram_safe_get("cifs_msdfs_enable"), "enabled") ==
					  0) ? "yes" : "no"));
			if (member_of_domain == TRUE)
			{
				if (is_ubsa_mode())
				{
					char *invalid_users, *read_users, *full_users;
					const char * ubsa_guest_account;
					
					if (get_foreign_share_user_permissions(	this_entry->partition, 
														&invalid_users,
														&read_users,
														&full_users ) == FALSE)
					{
						clear_mount_info(mount_info);
						return;
					}
					
				    fprintf(config_fp,
							"       invalid users = %s\n"
							"       read list = %s\n"
							"       write list = %s\n"
							"       guest ok = no\n"
							"       guest only = no\n", 
							invalid_users, read_users, full_users);
					
					free(invalid_users);
					free(read_users);
					free(full_users);


					/*
						Make the share a guest (aka, public) share if the guest account has
						access privilege (read or full).  If ubsa_guest_account is NULL, then
						no (regular) share can be a guest share.
					 */
					ubsa_guest_account = nvram_safe_get("ubsa_guest_account"); // Default to blank.
					if (*ubsa_guest_account != '\0' &&
						get_foreign_share_user_permission(this_entry->partition, ubsa_guest_account)
							!= PERM_NO)
					{
						const char * guest_access = nvram_safe_get("ubsa_special_guest_access");
						if (*guest_access == '\0')
							guest_access = "yes";
					    fprintf(config_fp,
								"       guest ok = %s\n"
								"       guest only = %s\n",
								guest_access, guest_access
						);
					}
					
				}
				else
				{
					fprintf(config_fp,
							"       guest ok = yes\n" );
				}
			}
			else /* Share access control is not enabled when we are in a
				  * domain. */
			{
				if ((partition_var_get(this_entry->partition,
									   "cifs_protection_uid") == NULL) ||
					(partition_var_get(this_entry->partition,
									   "cifs_protection_password_stuff") ==
					 NULL))
				{
				    fprintf(config_fp,
							"       guest ok = yes\n"
							"       guest only = yes\n");
				}
				else
				{
				    fprintf(config_fp,
							"       valid users = %%S\n"
							"       user = %%S\n"
							"       guest ok = no\n"
							"       guest only = no\n");
				}
			}
		}
		clear_mount_info(mount_info);
	}
#endif
	char shared_info[4096], group_users[4096], private_shares[4096];
        //Jemmy add buf size from 128 to 512 for fixing http crash when create 
        //one share with 20 groups access 2009.11.20
	char var[512], *next, var2[512], *next2, var3[128], *next3, var4[128], *next4;
	char *buf1, buf2[512], buf3[512], buf4[4096];
	char user_list[4096] = "", read_list[4096] = "", write_list[4096] = "";
	char *share_name, *group_num, *group_name, *group_right;
	char *user_group, *user_num, *user_name;
	char *private_name, *private_part, *private_folder, *private_comm;
	char anonymous_samba[4] = "";
	int i, j, same_name = 0;
	int no_group = 0;
	mounted_info_t *mount_info;

	strncpy(shared_info, nvram_safe_get("shared_info"), sizeof(shared_info));
	strncpy(group_users, nvram_safe_get("group_users"), sizeof(group_users));
	strncpy(private_shares, nvram_safe_get("private_shares"), sizeof(private_shares));

	//Jemmy add for anonymous access samba 2010.8.20
	if (nvram_match("anonymous_samba", "1"))
		strcpy(anonymous_samba, "yes");  
	else		
		strcpy(anonymous_samba, "no");
  
	foreachtoken (var3, private_shares, next3, "|") {
		strcpy(buf3, var3);
		private_name = strtok(buf3, ":");
		private_part = strtok(NULL, ":");
		private_comm = strtok(NULL, ":");
		private_folder = strtok(NULL, ":");
//		strcpy(user_list, "admin");
//		strcpy(write_list, "admin");
		strcpy(user_list, "");
		strcpy(write_list, "");

		strcpy(read_list, "");

//modified by michael to fix the share name with space will led to httpd crash at 20090709
		foreachtoken (var, shared_info, next,"|") {
			buf1 = var;
			share_name = strsep(&buf1, ":");
			if (strcmp(share_name, private_name) != 0)
				continue;
			group_num = strsep(&buf1, ":");
			if(!strcmp(group_num, "0"))
			{
				no_group = 1;
				continue;
			}
			for (i = 0; i < atoi(group_num); i++) {

				group_name = strsep(&buf1, ":");
				group_right = strsep(&buf1, ":");
				//add by michael to fix the new add group to non-group share can't be use at 20090806
                                if (!strcmp(group_name, "share_write_user") && group_num == 1)
                                {
                                        no_group = 1;
                                        break;
                                }
				if (group_right == NULL)
					group_right = buf1;

				foreach(var2, group_users, next2) {
					strcpy(buf2, var2);
					user_group = strtok(buf2, ":");
					user_num = strtok(NULL, ":");

					if (strcmp(group_name, user_group) != 0)
						continue;
					for (j = 0; j < atoi(user_num); j++) {
						user_name = strtok(NULL, ":");
						if(strcmp(group_name,"admin"))
						{
							if (!strcmp(user_name, "admin"))
								continue;
						}
						strcpy(buf4, "");
						foreach (var4, read_list, next4) {
							if (!strcmp(var4, user_name)) {
								if (!strcmp(group_right, "r"))
									same_name = 1;
								else 
									continue;	
							}		 
							if (!strcmp(buf4, ""))
								sprintf(buf4, "%s", var4);
							else
								sprintf(buf4, "%s %s", buf4, var4);
						}
						strcpy(read_list, buf4);

						foreach (var4, write_list, next4) {
							if (!strcmp(var4, user_name)) {
								same_name = 1;
								break;
							}		 
						}
					/*
						foreach (var4, user_list, next4) {
							if (!strcmp(var4, user_name)) {
								same_name = 1;
								break;	
							}
						}
						*/

						if (same_name == 1) {
							same_name = 0;
							break;
						}

						if (!strcmp(user_list, ""))
							sprintf(user_list, "%s", user_name);
						else
							sprintf(user_list, "%s %s", user_list, user_name);

						if (!strcmp(group_right, "rw")) {
							if (!strcmp(write_list, ""))
								sprintf(write_list, "%s", user_name);
							else
								sprintf(write_list, "%s %s", write_list, user_name);
						}

						if (!strcmp(group_right, "r")) {
							if (!strcmp(read_list, ""))
								sprintf(read_list, "%s", user_name);
							else 
								sprintf(read_list, "%s %s", read_list, user_name);
						}
					}	
				}
			}
		}
		
		if(no_group == 1)
		{
			no_group = 0;
			continue;
		}

		if (!strcmp(private_name, "All_Partitions")) {
			if (!strcmp(nvram_safe_get("all_partitions_share"), "1")) {
				/* Handle foreign shares. */
				mount_info = read_mount_info(get_disk_info(all_disk_info));
				if (mount_info != NULL)
				{			
					size_t mount_count;
					size_t mount_num;

					mount_count = mount_info->mount_count;
					for (mount_num = 0; mount_num < mount_count; ++mount_num)
					{
						mounted_entry_t *this_entry;
						const char *share_name;
						char *mark_file;
						FILE *fp;
						const char *share_disable_value;

						this_entry = &(mount_info->entries[mount_num]);
						if (strncmp(this_entry->mount_point, "/foreign_shares/",
							strlen("/foreign_shares/")) != 0)
						{
							continue;
						}

						share_name =
							&(this_entry->mount_point[strlen("/foreign_shares/")]);
						if (this_entry->partition == NULL)
							continue;

						/* Check for a mark left to say to omit this share because 
						 * it is about to be removed. */
						mark_file = (char *)(malloc(strlen(share_name) + 100));
						if (mark_file == NULL)
						{
							fprintf(stderr,
							"Error: failed trying to allocate %llu bytes of memory"
							" while exporting CIFS share `%s'.\n",
							(unsigned long long)(strlen(share_name) + 100),
							share_name);
							clear_mount_info(mount_info);
							return;
						}
						sprintf(mark_file, "/tmp/foreign_shares_going/%s", share_name);
						fp = fopen(mark_file, "r");
						if (fp != NULL)
						{
							fclose(fp);
							free(mark_file);
							continue;
						}
						free(mark_file);

						share_disable_value =
						partition_var_get(this_entry->partition, "cifs_enable");
						if ((share_disable_value != NULL) &&
							(strcmp(share_disable_value, "disabled") == 0))
						{
							continue;
						}
#if 0
				fprintf(config_fp,
					"\n"
					"[All_Partitions]\n"
					"	path = /foreign_shares/\n"
					"	valid users = %s\n"
					//"	admin users = admin\n"
					"	guest ok = no\n"
					"	read list = %s\n"
					"	write list = %s\n"
					"	writeable = yes\n"
					"	create mask = 0777\n"
					"	directory mask = 0777\n",
					//"       profile acls = yes\n", 
					user_list, read_list, write_list);
#endif
					//HYW add 2009.11.23
#if 0
						fprintf(config_fp,
							"\n"
							"[%s]\n"
							"       path = /foreign_shares/%s\n"
							"	valid users = %s\n"
							//"	admin users = admin\n"
							"	guest ok = no\n"
							"	read list = %s\n"
							"	write list = %s\n"
							"	writeable = yes\n"
							"	create mask = 0777\n"
							"	directory mask = 0777\n",
							//"       profile acls = yes\n", 
							share_name, share_name, 
							user_list, read_list, write_list);
#else
						if(user_list!=0 && strlen(user_list)>0)
						{
							fprintf(config_fp,
							"\n"
							"[%s]\n"
							"       path = /foreign_shares/%s\n"
							"	valid users = %s\n"
							//"	admin users = admin\n"
							"	guest ok = %s\n"
							"	read list = %s\n"
							"	write list = %s\n"
							"	writeable = yes\n"
							"	create mask = 0777\n"
							"	directory mask = 0777\n",
							//"       profile acls = yes\n", 
							share_name, share_name, anonymous_samba,
							user_list, read_list, write_list);
						}
						else
						{
                                                        fprintf(config_fp,
                                                        "\n"
                                                        "[%s]\n"
                                                        "       path = /foreign_shares/%s\n"
                                                        "       valid users = \"\"\n"
                                                        //"     admin users = admin\n"
                                                        "       guest ok = %s\n"
                                                        "       read list = %s\n"
                                                        "       write list = %s\n"
                                                        "       writeable = yes\n"
                                                        "       create mask = 0777\n"
                                                        "       directory mask = 0777\n",
                                                        //"       profile acls = yes\n",
                                                        share_name, share_name,anonymous_samba,
                                                        read_list, write_list);
						}
#endif
					}
				}
			}
		}
		else {
			//HYW add 2009.11.23
#if 0
			fprintf(config_fp,
				"\n"
				"[%s]\n"
				"	path = /foreign_shares%s\n"
				"	inherit permissions = yes\n"
				"	valid users = %s\n"
				"	admin users = admin\n"
	//			"       guest account = guest\n"
	//			"       guest ok = yes\n"
				"	read list = %s\n"
				"	write list = %s\n"
				"	inherit acls = yes\n"
				"	writeable = yes\n"
				"	browseable = yes\n"
				"	create mask = 0777\n"
				"	directory mask = 0777\n",
				//"       profile acls = yes\n", 
				private_name, private_folder, user_list, read_list, write_list);	
#endif
			if(user_list!=0 && strlen(user_list)>0)
			{
				fprintf(config_fp,
				"\n"
				"[%s]\n"
				"	path = /foreign_shares%s\n"
				"	inherit permissions = yes\n"
				"	valid users = %s\n"
				"	admin users = admin\n"
	//			"       guest account = guest\n"
				"       guest ok = %s\n"
				"	read list = %s\n"
				"	write list = %s\n"
				"	inherit acls = yes\n"
				"	writeable = yes\n"
				"	browseable = yes\n"
				"	create mask = 0777\n"
				"	directory mask = 0777\n",
				//"       profile acls = yes\n", 
				private_name, private_folder, user_list, anonymous_samba, read_list, write_list);
			}
			else
			{
                                fprintf(config_fp,
                                "\n"
                                "[%s]\n"
                                "       path = /foreign_shares%s\n"
                                "       inherit permissions = yes\n"
                                "       valid users = \"\"\n"
                                "       admin users = admin\n"
        //                      "       guest account = guest\n"
        	                "       guest ok = %s\n"
                                "       read list = %s\n"
                                "       write list = %s\n"
                                "       inherit acls = yes\n"
                                "       writeable = yes\n"
                                "       browseable = yes\n"
                                "       create mask = 0777\n"
                                "       directory mask = 0777\n",
                                //"       profile acls = yes\n",
                                private_name, private_folder, anonymous_samba, read_list, write_list);

			}
		}
	}	
}				

static int
write_cifs_config_file(const char *file_name, all_disk_info_t *all_disk_info)
{
	const pool_info_t *pdc_pool;
	const char *machine_name;
    	const char *qos_enable;
	const char *qos_level2_file_ext, *qos_level1_file_ext;
	FILE *config_fp;
	bool pdc_is_enabled;
	bool is_ubsa;
	bool pdc_only; /* i.e., not stand alone server */
	bool member_of_domain;
	bool member_of_domain_only; /* member, not pdc */
	pool_info_t *printer_pool;
	char *printer_pool_info;
	const char * security_mode;
	const char * cifs_guest_account = "guest";

	printer_pool_info = extract_printer_pool_info();

	if (strcmp(nvram_safe_get("workgroup_or_domain"), "domain") == 0)
		member_of_domain = TRUE;
	else
		member_of_domain = FALSE;

	pdc_only = FALSE;
	is_ubsa = is_ubsa_mode();
	if (strcmp(nvram_safe_get("pdc_enable"), "enabled") == 0)
	{
		pdc_is_enabled = TRUE;	
		if (is_ubsa == FALSE)
			pdc_only = TRUE;
	}
	else
	{
		pdc_is_enabled = FALSE;
	}


	pdc_pool = NULL;
	if (pdc_is_enabled)
	{
		pdc_pool = require_mounted_pool(nvram_get("pdc_pool"),
				"Primary Domain Controller (PDC) support",
				all_disk_info);
		if (pdc_pool == NULL)
			return -1;
	}

	/*
		Needs to be built before we build smb.conf.
	 */
	/* clean account&password files first */
	clean_account_passwd_files();
	export_user_info();
	link_passwd();

	if (pdc_is_enabled == TRUE && member_of_domain == FALSE)
	{
		fprintf(stderr, "Error: PDC mode requested but not a domain.\n");
		pdc_is_enabled = FALSE;
		is_ubsa = FALSE;
	}
	if (is_ubsa == TRUE && pdc_is_enabled == FALSE)
	{
		fprintf(stderr, "Error: User based share access not correctly configured.\n");
		member_of_domain = FALSE;
		is_ubsa = FALSE;
	}

	member_of_domain_only = member_of_domain && !pdc_is_enabled;

	qos_enable = nvram_safe_get("qos_enable");
	if ((strcasecmp(qos_enable, "yes") == 0) ||
		(strcasecmp(qos_enable, "on") == 0) ||
		(strcasecmp(qos_enable, "true") == 0) ||
		(strcasecmp(qos_enable, "enabled") == 0))
	{
        qos_enable = "yes";
	}
	else
	{
		qos_enable = "no";
	}

	qos_level1_file_ext = nvram_safe_get("qos_level1_file_extensions");
	qos_level2_file_ext = nvram_safe_get("qos_level2_file_extensions");

	config_fp = fopen(file_name, "w");
	if (config_fp == NULL)
	{
		fprintf(stderr,
			"Error: Could not open SAMBA configuration file `%s': %s\n",
			file_name, strerror(errno));
		return -1;
	}

	machine_name = nvram_safe_get("machine_name");
	if ((machine_name == NULL) || (machine_name[0] == 0))
		machine_name = "WirelessNAS";

	if (!member_of_domain)
		security_mode = "share";
	else if (!pdc_is_enabled)
		security_mode = "domain";
	else if (!is_ubsa) /* PDC mode */
		security_mode = "user";
	else /* SAS mode */
	{
		security_mode = nvram_safe_get("ubsa_security_mode");
		if (security_mode[0] == '\0')
			security_mode = "user";
	}

//Michael, security_mode = user
	//Jemmy add for anonymous access share 2010.08.20
	if (nvram_match("anonymous_samba", "1") || (all_disk_info->disk_info == NULL))
	{
		security_mode = "share";
	}else{
	security_mode = "user";
	}
	//end

	if (is_ubsa)
	{
		cifs_guest_account = nvram_safe_get("ubsa_guest_account"); // Defaults to blank.
		if (*cifs_guest_account == '\0') /* If there is no guest account name... */
			cifs_guest_account = "guest"; /* then default the name. */
	}

	//Jemmy add for anonymous access share 2010.08.20
	if (nvram_match("anonymous_samba", "1"))
		cifs_guest_account = "admin";
	//end

	fprintf(config_fp,
		"[global]\n"
		"        netbios name = %s\n", machine_name);
	fprintf(config_fp,
		//"        netbios aliases = 192.168.1.1\n"
		"        server string = \"%s\"\n"
		"        workgroup = %s\n"
		"        security = %s\n"
		"        guest account = %s\n"
		"        log file = /var/log/samba.log\n"
		//add smb-fast feature at 20101015
		//"        socket options = TCP_NODELAY SO_RCVBUF=16384 "
              "        socket options = TCP_SMB_FAST TCP_NODELAY SO_RCVBUF=16384 "
			"SO_SNDBUF=8192\n"
		"        encrypt passwords = yes\n"
		//"        use spnego = no\n"
		//"        client use spnego = no\n"
		"        wins server = %s\n"
		"        wins support = %s\n"
		//"        host msdfs = %s\n"
		"        interfaces = lo br0\n"
#ifdef SMB302_SUPPORT
		"        qos enable = %s\n"
		//"        unicode = yes\n"
		//"        dos charset = UTF8\n"
		//"        display charset = UTF8\n"
		//"        unix charset = UTF8\n"
		"        level1 file extensions = %s\n"
		"        level2 file extensions = %s\n"
#endif
		"        os level = %d\n"			/* Value for PDC. */
		"        preferred master = %s\n"	/* Value for PDC. */
		"        domain master = %s\n"		/* Value for PDC. */
		"        local master = yes\n"		/* Value for PDC- default. */
		"        domain logons = %s\n"		/* Value for PDC. */
		"        log level = 0\n"
		"        max log size = 100\n"
		"        disable spoolss = yes\n"	/*Jemmy add to disable printer 2010.9.16*/
		"        null passwords = yes\n",
		//did not add this rule into home samba conf to fix IR-B0014250 at 20100108
                //"        bind interfaces only = yes\n",   /*Jemmy add for restrice access client 2009.12.16 */
		nvram_safe_get("machine_comment"), nvram_safe_get("workgroup"),
		security_mode, //(!member_of_domain ? "share" : (!pdc_is_enabled ? "domain" : "user")),
		cifs_guest_account,
		/* Security values:
		       share: member of workgroup
			   domain: member of domain
			   user: primary domain controller
		 */
		(pdc_only ? "" : nvram_safe_get("lan_wins")),
		(pdc_only ? "yes": "no"),
		//((strcmp(nvram_safe_get("cifs_msdfs_enable"), "enabled") == 0) ?
		// "yes" : "no"), 
#ifdef SMA302_SUPPORT
		qos_enable, qos_level1_file_ext,
		qos_level2_file_ext,
#endif
		pdc_only ? 64 : 20,			/* 20 is default.  64 from PdcHowto. */
		pdc_only ? "yes": "auto",		/* preferred master */
		pdc_only ? "yes": "auto",		/* domain master */
		pdc_only ? "yes": "no"		/* domain logons */
	);

	//Jemmy add for forbid guest network user to access samba 2009.9.26
#ifdef GUEST_NETWORK_SUPPORT
       fprintf(config_fp,
		"        hosts allow = %s/%s\n", nvram_safe_get("lan_ipaddr"), nvram_safe_get("lan_netmask")
                );
#endif

	/* Output the path to the smbpasswd file. */
	if (pdc_is_enabled)
	{
		/*
			In PDC mode, we need to use the tdbsam backend because it provides
			more functionality.  Specifically, it allows for account fields (e.g., the 
			home directory) to be updated via the net user command.
		 */
		fprintf(config_fp,
			"        passdb backend = tdbsam\n" /* File defaults to passdb.tdb in private directory. */
		);
	}
	else
	{
		fprintf(config_fp,
			"        passdb backend = smbpasswd:/tmp/smbpasswd\n"
		);
	}

	if (member_of_domain)
	{
		if (member_of_domain_only)
		{
			/* These values are only needed for being a member of a domain 
			   (as opposed to member of workgroup or pdc).
			 */
			
			fprintf(config_fp,
				"        password server = *\n"
			);
		}
		else /* i.e., pdc_is_enabled */
		{
			const char * logon_drive = nvram_get( "logon_drive" );
			const char * logon_script = nvram_get( "logon_script" );

			if (!is_ubsa)
			{
				fprintf(config_fp,
					"        logon path = \\\\%%N\\profiles\\%%U\n"
					"        logon home = \\\\%%N\\%%U\\profile\n" /* For Win98/ME clients. */
				);
			}


			assert(pdc_pool != NULL);
			assert(pdc_pool->mount_name != NULL);
			fprintf(config_fp, "        private dir = /shares/%s/__pdc\n",
					pdc_pool->mount_name);

			if (!is_ubsa)
			{
				if (logon_drive != NULL)
				{
					fprintf(config_fp,
						"        logon drive = %s\n",
						logon_drive
					);
				}
				if (logon_script != NULL)
				{
					fprintf(config_fp,
						"        logon script = %s\n",
						logon_script
					);
				}
			}
		}

		if (is_ubsa)
		{
			const char * ubsa_map_to_guest = nvram_safe_get("ubsa_map_to_guest");
			if (ubsa_map_to_guest[0] == '\0')
			{
				ubsa_map_to_guest = "bad user";
			}
			fprintf(config_fp,
				"        map to guest = %s\n", ubsa_map_to_guest
			);
		}
		else
		{
			fprintf(config_fp,
				"        add user script = /sbin/tmpuseradd \"%%u\"\n"
				"        add machine script = /sbin/tmpuseradd %%u\\\\\\$\n"
				"        delete user script = /sbin/tmpuserdel\"%%u\"\n"
			);

			fprintf(config_fp,
				"        add group script = /sbin/tmpgroupadd \"%%g\"\n"
				"        delete group script = /sbin/tmpgroupdel \"%%g\"\n"
			);


			fprintf(config_fp,
				"        add user to group script = /sbin/tmpuseraddgroup \"%%g\" \"%%u\"\n"
				"        delete user from group script = /sbin/tmpuserdelgroup \"%%g\" \"%%u\"\n"
			);

			fprintf(config_fp,
				"        set primary group script = /sbin/tmpusersetgroup \"%%u\" \"%%g\"\n");
		}
	}

	/*
		If the printer support is enabled but the printer pool doesn't exist
		(it could be encrypted or the drive could be missing) then we do
		not enable printer support.
		
		Note: We must reget the printer pool name because a lot of code has
		been executed since we got it last, and so the pointer may no longer
		be valid.
	 */
	printer_pool_info = extract_printer_pool_info();
	printer_pool = require_mounted_pool(printer_pool_info,
			"Printer Support", all_disk_info);
	if (printer_pool != NULL)
	{
		if (strcmp(nvram_safe_get("printer_driver_on_client"), "disabled") != 0)
	      {
	        fprintf(config_fp,
			 "        use client driver = yes\n");		
	      }

	    fprintf(config_fp,
		"        printer admin = root, guest\n"
		"        show add printer wizard = yes\n"
		"        load printers = yes\n"
		"        default devmode = yes\n"
		"        printcap name = /tmp/etc/printcap\n");		

	    fprintf(config_fp,
		"\n[printers]\n"
		"       comment = All Printers\n"
		"       path=/shares/%s/__var/spool/samba\n"
		"       printing = brcm\n"
		"       guest ok = yes\n"
		"       printable = yes\n"
		"       browseable = no\n"
		"       print command = chmod 666 %%s; printcmd jobsubmit %%p '%%J' %%x '%%u'\n"
		"       lpq command = printcmd queuestat %%p\n"
		"       lprm command = printcmd jobcancel %%p %%j\n"
		"       lppause command = printcmd jobpause %%p %%j\n"
		"       lpresume command = printcmd jobresume %%p %%j\n"
		"       queuepause command = printcmd queuepause %%p\n"
		"       queueresume command = printcmd queueresume %%p\n",
		printer_pool->mount_name
	     );			

            if (strcmp(nvram_safe_get("printer_driver_on_client"), "disabled") == 0)
	      {
	        fprintf(config_fp,
		      "\n[print$]\n"
		      "       path = /shares/%s/__drivers\n"
		      "       guest ok = yes\n"
		      "       browseable = no\n"
		      "       read only = yes\n"
		      "       write list = guest, root\n"
		      "       create mask = 0644\n"
		      "       directory mask = 0755\n",
		      printer_pool->mount_name
		   );
	      }
	}
//delete by michael to remove the config share folder at 20090205
#if 0
	fprintf(config_fp,
		"\n"
		"[Config]\n"
		"       path = /tmp/configuration_share\n"
		"       guest ok = yes\n"
		"       writeable = no\n"
		"       browsable = yes\n"
		"       guest only = yes\n");
#endif
//end by michael

	export_cifs_shares(config_fp, member_of_domain, all_disk_info);

	fflush(config_fp);
	if (ferror(config_fp))
	{
		fclose(config_fp);
		fprintf(stderr,
			"Error: While writing SAMBA configuration file `%s': %s\n",
			file_name, strerror(errno));
		return -1;
	}
	fclose(config_fp);

	/*
		Must be called after smb.conf is built.
	 */
	restore_secrets(); /* Must be called after regen_cifs_config_file(). */
	reattempt_failed_note_delivery();
	
	//michael, add NAS account
	add_accounts();

	return 0;
}
#endif

extern struct nvram_tuple router_defaults[];

typedef struct wl_store_tuple {
	char *name;
	char *wl_value;
	char *open_value;
} wl_restore_tuple_t;

wl_restore_tuple_t wl_restore[] = {
#if 1	/* Wireless Basic Settings */
	{"wl_ssid","linksys", ""},
	{"wl_radio", "1", ""},			/* Enable (1) or disable (0) radio */
	{"wl_closed", "0", ""},			/* Closed (hidden) network */
	{"wl_nbw", "40", ""},			/* N-BW */
	{"wl_nbw_cap", "2", ""},		/* BW Cap; def 20inB and 40inA */
	{"wl_net_mode", "mixed", ""},		/* Wireless mode (mixed|g-only|b-only|disable) */
	{"wl_channel", "11", ""},		/* Channel number */
#endif	/*Wireless Basic Settings */

#if 1	/* Wireless Advanced Settings */
	{"wl_nctrlsb", "none", ""},		/* N-CTRL SB */
	{"wl_nband", "2", ""},			/* N-BAND */
	{"wl_nmode", "-1", ""},			/* N-mode */
	{"wl_nreqd", "0", ""},			/* Require 802.11n support */
	{"wl_ap_isolate", "0", ""},		/* AP isolate mode */
	{"wl_rate", "0", ""},			/* Rate (bps, 0 for auto) */
	{"wl_mrate", "0", ""},			/* Mcast Rate (bps, 0 for auto) */
	{"wl_rateset", "default", ""},		/* "default" or "all" or "12" */
	{"wl_frag", "2346", ""},		/* Fragmentation threshold */
	{"wl_rts", "2347", ""},			/* RTS threshold */
	{"wl_dtim", "1", ""},			/* DTIM period (3.11.5)*/	/* It is best value for WiFi test */
	{"wl_nmcsidx", "-1", ""},		/* MCS Index for N - rate */
	{"wl_bcn", "100", ""},			/* Beacon interval */
	{"wl_gmode", "1", ""},			/* 54g mode */
	{"wl_gmode_protection", "auto", ""},	/* 802.11g RTS/CTS protection (off|auto) */
	{"wl_nmode_protection", "auto", ""},	/* 802.11g RTS/CTS protection (off|auto) */
	{"wl_afterburner", "off", ""},		/* AfterBurner */
	{"wl_frameburst", "on", ""},		/* BRCM Frambursting mode (off|on) */
#endif	/* Wireless Advanced Settings */

#if 1	/* Wireless Security Settings */
	{"wl_wep", "disabled", ""},		/* WEP data encryption (enabled|disabled) */
	{"wl_auth", "0", ""},			/* Shared key authentication optional (0) or
						 * required (1) */
	{"wl_key", "1", ""},			/* Current WEP key */
	{"wl_key1", "", ""},			/* 5/13 char ASCII or 10/26 char hex */
	{"wl_key2", "", ""},			/* 5/13 char ASCII or 10/26 char hex */
	{"wl_key3", "", ""},			/* 5/13 char ASCII or 10/26 char hex */
	{"wl_key4", "", ""},			/* 5/13 char ASCII or 10/26 char hex */
	{"wl_wep_last", "", ""},		/* Save last wl_wep mode */	
	{"wl_passphrase", "", ""},		/* Passphrase */	
	{"wl_wep_bit", "64", ""},		/* WEP encryption [64 | 128] */ 
	{"wl_wep_buf", "", ""},			/* save all settings for web */ 
	{"wl_wep_gen", "", ""},			/* save all settings for generate button */	/* Add */

	/* WPA parameters */
	{"security_mode2", "disabled", ""},	/* WPA mode (disabled|radius|wpa_personal|wpa_enterprise|wep|wpa2_personal|wpa2_enterprise) for WEB */
	{"security_mode", "disabled", ""},	/* WPA mode (disabled|radius|wpa|psk|wep|psk psk2|wpa wpa2) for WEB */
	{"security_mode_last", "", ""},		/* Save last WPA mode */
	{"wl_auth_mode", "none", ""},		/* Network authentication mode (radius|none) */
	{"wl_wpa_psk", "", ""},			/* WPA pre-shared key */
	{"wl_wpa_gtk_rekey", "3600", ""},	/* WPA GTK rekey interval */	
	{"wl_radius_ipaddr", "", ""},		/* RADIUS server IP address */
	{"wl_radius_key", "", ""},		/* RADIUS shared secret */
	{"wl_radius_port", "1812", ""},		/* RADIUS server UDP port */
	{"wl_crypto", "tkip", ""},		/* WPA data encryption */
	{"wl_net_reauth", "36000", ""},		/* Network Re-auth/PMK caching duration */
	{"wl_akm", "", ""},			/* WPA akm list */
#endif	/* Wireless Security Settings */

#if 0 	/* Wireless MAC Filter
	{"wl_mac_filter", "0", ""},		/* for WEB */	
	{"wl_mac_list", "", ""},		/* filter MAC */	
	{"wl_mac_deny", "", ""},		/* filter MAC */	
	{"wl_maclist", "", ""},			/* xx:xx:xx:xx:xx:xx ... */
	{"wl_active_mac", "", ""},		/* xx:xx:xx:xx:xx:xx ... */	
	{"wl_macmode", "disabled", ""},		/* "allow" only, "deny" only, or "disabled" (allow all) */
#endif	/* Wireless MAC Filter */

#if 1	/* Wireless WPS Settings */
	{"wl_wsc_mode","enabled", ""},
	{"wsc_enable","1", ""},
        {"wsc_ie","enabled", ""},
        {"wsc_ap_role", "proxy", ""},
        {"wsc_config_method", "pin", ""},
        {"wsc_config","0", ""},
        {"wsc_result","0", ""},
        {"wsc_akm","disabled", ""}, 
	{"wsc_msg_timeout", "15", ""},
	{"wsc_security_auto","1", ""},
#endif	/* Wireless WPS Settings */
	{ NULL, NULL }
};

int wl_gui_reset(void)
{
	wl_restore_tuple_t *wl_t;
	struct nvram_tuple *def_t;

	for (wl_t = wl_restore; wl_t->name; wl_t++) {
		for (def_t = router_defaults; def_t->name; def_t++) {
			if (!strcmp(def_t->name, wl_t->name))
				nvram_set(wl_t->name, def_t->value);
		}
	}
}


